//
//   Copyright 2015 Pixar
//
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//
//   You may obtain a copy of the Apache License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//

#include "OpenSubdiv/OSDSurfaceGLSLPatchShaderSource.h"
#include <sstream>
#include <string>

namespace OpenSubdiv {
namespace OPENSUBDIV_VERSION {

namespace Osd {

static const char *commonShaderSource = 
"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"// The following callback functions are used when evaluating tessellation\n"
"// rates and when using legacy patch drawing.\n"
"mat4 OsdModelViewMatrix();\n"
"mat4 OsdProjectionMatrix();\n"
"float OsdTessLevel();\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Patch Parameters\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"//\n"
"// Each patch has a corresponding patchParam. This is a set of three values\n"
"// specifying additional information about the patch:\n"
"//\n"
"//    faceId    -- topological face identifier (e.g. Ptex FaceId)\n"
"//    bitfield  -- refinement-level, non-quad, boundary, transition, uv-offset\n"
"//    sharpness -- crease sharpness for single-crease patches\n"
"//\n"
"\n"
"int OsdGetPatchFaceId(ivec3 patchParam)\n"
"{\n"
"    return (patchParam.x & 0xfffffff);\n"
"}\n"
"\n"
"int OsdGetPatchFaceLevel(ivec3 patchParam)\n"
"{\n"
"    return (1 << ((patchParam.y & 0xf) - ((patchParam.y >> 4) & 1)));\n"
"}\n"
"\n"
"int OsdGetPatchRefinementLevel(ivec3 patchParam)\n"
"{\n"
"    return (patchParam.y & 0xf);\n"
"}\n"
"\n"
"int OsdGetPatchBoundaryMask(ivec3 patchParam)\n"
"{\n"
"    return ((patchParam.y >> 7) & 0x1f);\n"
"}\n"
"\n"
"int OsdGetPatchTransitionMask(ivec3 patchParam)\n"
"{\n"
"    return ((patchParam.x >> 28) & 0xf);\n"
"}\n"
"\n"
"ivec2 OsdGetPatchFaceUV(ivec3 patchParam)\n"
"{\n"
"    int u = (patchParam.y >> 22) & 0x3ff;\n"
"    int v = (patchParam.y >> 12) & 0x3ff;\n"
"    return ivec2(u,v);\n"
"}\n"
"\n"
"bool OsdGetPatchIsRegular(ivec3 patchParam)\n"
"{\n"
"    return ((patchParam.y >> 5) & 0x1) != 0;\n"
"}\n"
"\n"
"bool OsdGetPatchIsTriangleRotated(ivec3 patchParam)\n"
"{\n"
"    ivec2 uv = OsdGetPatchFaceUV(patchParam);\n"
"    return (uv.x + uv.y) >= OsdGetPatchFaceLevel(patchParam);\n"
"}\n"
"\n"
"float OsdGetPatchSharpness(ivec3 patchParam)\n"
"{\n"
"    return intBitsToFloat(patchParam.z);\n"
"}\n"
"\n"
"float OsdGetPatchSingleCreaseSegmentParameter(ivec3 patchParam, vec2 uv)\n"
"{\n"
"    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);\n"
"    float s = 0;\n"
"    if ((boundaryMask & 1) != 0) {\n"
"        s = 1 - uv.y;\n"
"    } else if ((boundaryMask & 2) != 0) {\n"
"        s = uv.x;\n"
"    } else if ((boundaryMask & 4) != 0) {\n"
"        s = uv.y;\n"
"    } else if ((boundaryMask & 8) != 0) {\n"
"        s = 1 - uv.x;\n"
"    }\n"
"    return s;\n"
"}\n"
"\n"
"ivec4 OsdGetPatchCoord(ivec3 patchParam)\n"
"{\n"
"    int faceId = OsdGetPatchFaceId(patchParam);\n"
"    int faceLevel = OsdGetPatchFaceLevel(patchParam);\n"
"    ivec2 faceUV = OsdGetPatchFaceUV(patchParam);\n"
"    return ivec4(faceUV.x, faceUV.y, faceLevel, faceId);\n"
"}\n"
"\n"
"vec4 OsdInterpolatePatchCoord(vec2 localUV, ivec3 patchParam)\n"
"{\n"
"    ivec4 perPrimPatchCoord = OsdGetPatchCoord(patchParam);\n"
"    int faceId = perPrimPatchCoord.w;\n"
"    int faceLevel = perPrimPatchCoord.z;\n"
"    vec2 faceUV = vec2(perPrimPatchCoord.x, perPrimPatchCoord.y);\n"
"    vec2 uv = localUV/faceLevel + faceUV/faceLevel;\n"
"    // add 0.5 to integer values for more robust interpolation\n"
"    return vec4(uv.x, uv.y, faceLevel+0.5f, faceId+0.5f);\n"
"}\n"
"\n"
"vec4 OsdInterpolatePatchCoordTriangle(vec2 localUV, ivec3 patchParam)\n"
"{\n"
"    vec4 result = OsdInterpolatePatchCoord(localUV, patchParam);\n"
"    if (OsdGetPatchIsTriangleRotated(patchParam)) {\n"
"        result.xy = vec2(1.0f) - result.xy;\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"void\n"
"OsdUnivar4x4(in float u, out float B[4], out float D[4])\n"
"{\n"
"    float t = u;\n"
"    float s = 1.0f - u;\n"
"\n"
"    float A0 = s * s;\n"
"    float A1 = 2 * s * t;\n"
"    float A2 = t * t;\n"
"\n"
"    B[0] = s * A0;\n"
"    B[1] = t * A0 + s * A1;\n"
"    B[2] = t * A1 + s * A2;\n"
"    B[3] = t * A2;\n"
"\n"
"    D[0] =    - A0;\n"
"    D[1] = A0 - A1;\n"
"    D[2] = A1 - A2;\n"
"    D[3] = A2;\n"
"}\n"
"\n"
"void\n"
"OsdUnivar4x4(in float u, out float B[4], out float D[4], out float C[4])\n"
"{\n"
"    float t = u;\n"
"    float s = 1.0f - u;\n"
"\n"
"    float A0 = s * s;\n"
"    float A1 = 2 * s * t;\n"
"    float A2 = t * t;\n"
"\n"
"    B[0] = s * A0;\n"
"    B[1] = t * A0 + s * A1;\n"
"    B[2] = t * A1 + s * A2;\n"
"    B[3] = t * A2;\n"
"\n"
"    D[0] =    - A0;\n"
"    D[1] = A0 - A1;\n"
"    D[2] = A1 - A2;\n"
"    D[3] = A2;\n"
"\n"
"    A0 =   - s;\n"
"    A1 = s - t;\n"
"    A2 = t;\n"
"\n"
"    C[0] =    - A0;\n"
"    C[1] = A0 - A1;\n"
"    C[2] = A1 - A2;\n"
"    C[3] = A2;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"struct OsdPerPatchVertexBezier {\n"
"    ivec3 patchParam;\n"
"    vec3 P;\n"
"#if defined OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    vec3 P1;\n"
"    vec3 P2;\n"
"    vec2 vSegments;\n"
"#endif\n"
"};\n"
"\n"
"vec3\n"
"OsdEvalBezier(vec3 cp[16], vec2 uv)\n"
"{\n"
"    vec3 BUCP[4] = vec3[4](vec3(0), vec3(0), vec3(0), vec3(0));\n"
"\n"
"    float B[4], D[4];\n"
"\n"
"    OsdUnivar4x4(uv.x, B, D);\n"
"    for (int i=0; i<4; ++i) {\n"
"        for (int j=0; j<4; ++j) {\n"
"            vec3 A = cp[4*i + j];\n"
"            BUCP[i] += A * B[j];\n"
"        }\n"
"    }\n"
"\n"
"    vec3 P = vec3(0);\n"
"\n"
"    OsdUnivar4x4(uv.y, B, D);\n"
"    for (int k=0; k<4; ++k) {\n"
"        P += B[k] * BUCP[k];\n"
"    }\n"
"\n"
"    return P;\n"
"}\n"
"\n"
"// When OSD_PATCH_ENABLE_SINGLE_CREASE is defined,\n"
"// this function evaluates single-crease patch, which is segmented into\n"
"// 3 parts in the v-direction.\n"
"//\n"
"//  v=0             vSegment.x        vSegment.y              v=1\n"
"//   +------------------+-------------------+------------------+\n"
"//   |       cp 0       |     cp 1          |      cp 2        |\n"
"//   | (infinite sharp) | (floor sharpness) | (ceil sharpness) |\n"
"//   +------------------+-------------------+------------------+\n"
"//\n"
"vec3\n"
"OsdEvalBezier(OsdPerPatchVertexBezier cp[16], ivec3 patchParam, vec2 uv)\n"
"{\n"
"    vec3 BUCP[4] = vec3[4](vec3(0), vec3(0), vec3(0), vec3(0));\n"
"\n"
"    float B[4], D[4];\n"
"    float s = OsdGetPatchSingleCreaseSegmentParameter(patchParam, uv);\n"
"\n"
"    OsdUnivar4x4(uv.x, B, D);\n"
"#if defined OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    vec2 vSegments = cp[0].vSegments;\n"
"    if (s <= vSegments.x) {\n"
"        for (int i=0; i<4; ++i) {\n"
"            for (int j=0; j<4; ++j) {\n"
"                vec3 A = cp[4*i + j].P;\n"
"                BUCP[i] += A * B[j];\n"
"            }\n"
"        }\n"
"    } else if (s <= vSegments.y) {\n"
"        for (int i=0; i<4; ++i) {\n"
"            for (int j=0; j<4; ++j) {\n"
"                vec3 A = cp[4*i + j].P1;\n"
"                BUCP[i] += A * B[j];\n"
"            }\n"
"        }\n"
"    } else {\n"
"        for (int i=0; i<4; ++i) {\n"
"            for (int j=0; j<4; ++j) {\n"
"                vec3 A = cp[4*i + j].P2;\n"
"                BUCP[i] += A * B[j];\n"
"            }\n"
"        }\n"
"    }\n"
"#else\n"
"    for (int i=0; i<4; ++i) {\n"
"        for (int j=0; j<4; ++j) {\n"
"            vec3 A = cp[4*i + j].P;\n"
"            BUCP[i] += A * B[j];\n"
"        }\n"
"    }\n"
"#endif\n"
"\n"
"    vec3 P = vec3(0);\n"
"\n"
"    OsdUnivar4x4(uv.y, B, D);\n"
"    for (int k=0; k<4; ++k) {\n"
"        P += B[k] * BUCP[k];\n"
"    }\n"
"\n"
"    return P;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Boundary Interpolation\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"void\n"
"OsdComputeBSplineBoundaryPoints(inout vec3 cpt[16], ivec3 patchParam)\n"
"{\n"
"    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);\n"
"\n"
"    //  Don't extrapolate corner points until all boundary points in place\n"
"    if ((boundaryMask & 1) != 0) {\n"
"        cpt[1] = 2*cpt[5] - cpt[9];\n"
"        cpt[2] = 2*cpt[6] - cpt[10];\n"
"    }\n"
"    if ((boundaryMask & 2) != 0) {\n"
"        cpt[7] = 2*cpt[6] - cpt[5];\n"
"        cpt[11] = 2*cpt[10] - cpt[9];\n"
"    }\n"
"    if ((boundaryMask & 4) != 0) {\n"
"        cpt[13] = 2*cpt[9] - cpt[5];\n"
"        cpt[14] = 2*cpt[10] - cpt[6];\n"
"    }\n"
"    if ((boundaryMask & 8) != 0) {\n"
"        cpt[4] = 2*cpt[5] - cpt[6];\n"
"        cpt[8] = 2*cpt[9] - cpt[10];\n"
"    }\n"
"\n"
"    //  Now safe to extrapolate corner points:\n"
"    if ((boundaryMask & 1) != 0) {\n"
"        cpt[0] = 2*cpt[4] - cpt[8];\n"
"        cpt[3] = 2*cpt[7] - cpt[11];\n"
"    }\n"
"    if ((boundaryMask & 2) != 0) {\n"
"        cpt[3] = 2*cpt[2] - cpt[1];\n"
"        cpt[15] = 2*cpt[14] - cpt[13];\n"
"    }\n"
"    if ((boundaryMask & 4) != 0) {\n"
"        cpt[12] = 2*cpt[8] - cpt[4];\n"
"        cpt[15] = 2*cpt[11] - cpt[7];\n"
"    }\n"
"    if ((boundaryMask & 8) != 0) {\n"
"        cpt[0] = 2*cpt[1] - cpt[2];\n"
"        cpt[12] = 2*cpt[13] - cpt[14];\n"
"    }\n"
"}\n"
"\n"
"void\n"
"OsdComputeBoxSplineTriangleBoundaryPoints(inout vec3 cpt[12], ivec3 patchParam)\n"
"{\n"
"    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);\n"
"    if (boundaryMask == 0) return;\n"
"\n"
"    int upperBits = (boundaryMask >> 3) & 0x3;\n"
"    int lowerBits = boundaryMask & 7;\n"
"\n"
"    int eBits = lowerBits;\n"
"    int vBits = 0;\n"
"\n"
"    if (upperBits == 1) {\n"
"        vBits = eBits;\n"
"        eBits = 0;\n"
"    } else if (upperBits == 2) {\n"
"        //  Opposite vertex bit is edge bit rotated one to the right:\n"
"        vBits = ((eBits & 1) << 2) | (eBits >> 1);\n"
"    }\n"
"\n"
"    bool edge0IsBoundary = (eBits & 1) != 0;\n"
"    bool edge1IsBoundary = (eBits & 2) != 0;\n"
"    bool edge2IsBoundary = (eBits & 4) != 0;\n"
"\n"
"    if (edge0IsBoundary) {\n"
"        if (edge2IsBoundary) {\n"
"            cpt[0] = cpt[4] + (cpt[4] - cpt[8]);\n"
"        } else {\n"
"            cpt[0] = cpt[4] + (cpt[3] - cpt[7]);\n"
"        }\n"
"        cpt[1] = cpt[4] + cpt[5] - cpt[8];\n"
"        if (edge1IsBoundary) {\n"
"            cpt[2] = cpt[5] + (cpt[5] - cpt[8]);\n"
"        } else {\n"
"            cpt[2] = cpt[5] + (cpt[6] - cpt[9]);\n"
"        }\n"
"    }\n"
"    if (edge1IsBoundary) {\n"
"        if (edge0IsBoundary) {\n"
"            cpt[6] = cpt[5] + (cpt[5] - cpt[4]);\n"
"        } else {\n"
"            cpt[6] = cpt[5] + (cpt[2] - cpt[1]);\n"
"        }\n"
"        cpt[9] = cpt[5] + cpt[8] - cpt[4];\n"
"        if (edge2IsBoundary) {\n"
"            cpt[11] = cpt[8] + (cpt[8] - cpt[4]);\n"
"        } else {\n"
"            cpt[11] = cpt[8] + (cpt[10] - cpt[7]);\n"
"        }\n"
"    }\n"
"    if (edge2IsBoundary) {\n"
"        if (edge1IsBoundary) {\n"
"            cpt[10] = cpt[8] + (cpt[8] - cpt[5]);\n"
"        } else {\n"
"            cpt[10] = cpt[8] + (cpt[11] - cpt[9]);\n"
"        }\n"
"        cpt[7] = cpt[8] + cpt[4] - cpt[5];\n"
"        if (edge0IsBoundary) {\n"
"            cpt[3] = cpt[4] + (cpt[4] - cpt[5]);\n"
"        } else {\n"
"            cpt[3] = cpt[4] + (cpt[0] - cpt[1]);\n"
"        }\n"
"    }\n"
"\n"
"    if ((vBits & 1) != 0) {\n"
"        cpt[3] = cpt[4] + cpt[7] - cpt[8];\n"
"        cpt[0] = cpt[4] + cpt[1] - cpt[5];\n"
"    }\n"
"    if ((vBits & 2) != 0) {\n"
"        cpt[2] = cpt[5] + cpt[1] - cpt[4];\n"
"        cpt[6] = cpt[5] + cpt[9] - cpt[8];\n"
"    }\n"
"    if ((vBits & 4) != 0) {\n"
"        cpt[11] = cpt[8] + cpt[9] - cpt[5];\n"
"        cpt[10] = cpt[8] + cpt[7] - cpt[4];\n"
"    }\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// BSpline\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"// compute single-crease patch matrix\n"
"mat4\n"
"OsdComputeMs(float sharpness)\n"
"{\n"
"    float s = pow(2.0f, sharpness);\n"
"    float s2 = s*s;\n"
"    float s3 = s2*s;\n"
"\n"
"    mat4 m = mat4(\n"
"        0, s + 1 + 3*s2 - s3, 7*s - 2 - 6*s2 + 2*s3, (1-s)*(s-1)*(s-1),\n"
"        0,       (1+s)*(1+s),        6*s - 2 - 2*s2,       (s-1)*(s-1),\n"
"        0,               1+s,               6*s - 2,               1-s,\n"
"        0,                 1,               6*s - 2,                 1);\n"
"\n"
"    m /= (s*6.0);\n"
"    m[0][0] = 1.0/6.0;\n"
"\n"
"    return m;\n"
"}\n"
"\n"
"// flip matrix orientation\n"
"mat4\n"
"OsdFlipMatrix(mat4 m)\n"
"{\n"
"    return mat4(m[3][3], m[3][2], m[3][1], m[3][0],\n"
"                m[2][3], m[2][2], m[2][1], m[2][0],\n"
"                m[1][3], m[1][2], m[1][1], m[1][0],\n"
"                m[0][3], m[0][2], m[0][1], m[0][0]);\n"
"}\n"
"\n"
"// Regular BSpline to Bezier\n"
"const mat4 Q = mat4(\n"
"    1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f,\n"
"    0.f,     4.f/6.f, 2.f/6.f, 0.f,\n"
"    0.f,     2.f/6.f, 4.f/6.f, 0.f,\n"
"    0.f,     1.f/6.f, 4.f/6.f, 1.f/6.f\n"
");\n"
"\n"
"// Infinitely Sharp (boundary)\n"
"const mat4 Mi = mat4(\n"
"    1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f,\n"
"    0.f,     4.f/6.f, 2.f/6.f, 0.f,\n"
"    0.f,     2.f/6.f, 4.f/6.f, 0.f,\n"
"    0.f,     0.f,     1.f,     0.f\n"
");\n"
"\n"
"// convert BSpline cv to Bezier cv\n"
"void\n"
"OsdComputePerPatchVertexBSpline(ivec3 patchParam, int ID, vec3 cv[16],\n"
"                                out OsdPerPatchVertexBezier result)\n"
"{\n"
"    result.patchParam = patchParam;\n"
"\n"
"    int i = ID%4;\n"
"    int j = ID/4;\n"
"\n"
"#if defined OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"\n"
"    vec3 P  = vec3(0); // 0 to 1-2^(-Sf)\n"
"    vec3 P1 = vec3(0); // 1-2^(-Sf) to 1-2^(-Sc)\n"
"    vec3 P2 = vec3(0); // 1-2^(-Sc) to 1\n"
"\n"
"    float sharpness = OsdGetPatchSharpness(patchParam);\n"
"    if (sharpness > 0) {\n"
"        float Sf = floor(sharpness);\n"
"        float Sc = ceil(sharpness);\n"
"        float Sr = fract(sharpness);\n"
"        mat4 Mf = OsdComputeMs(Sf);\n"
"        mat4 Mc = OsdComputeMs(Sc);\n"
"        mat4 Mj = (1-Sr) * Mf + Sr * Mi;\n"
"        mat4 Ms = (1-Sr) * Mf + Sr * Mc;\n"
"        float s0 = 1 - pow(2, -floor(sharpness));\n"
"        float s1 = 1 - pow(2, -ceil(sharpness));\n"
"        result.vSegments = vec2(s0, s1);\n"
"\n"
"        mat4 MUi = Q, MUj = Q, MUs = Q;\n"
"        mat4 MVi = Q, MVj = Q, MVs = Q;\n"
"\n"
"        int boundaryMask = OsdGetPatchBoundaryMask(patchParam);\n"
"        if ((boundaryMask & 1) != 0) {\n"
"            MVi = OsdFlipMatrix(Mi);\n"
"            MVj = OsdFlipMatrix(Mj);\n"
"            MVs = OsdFlipMatrix(Ms);\n"
"        }\n"
"        if ((boundaryMask & 2) != 0) {\n"
"            MUi = Mi;\n"
"            MUj = Mj;\n"
"            MUs = Ms;\n"
"        }\n"
"        if ((boundaryMask & 4) != 0) {\n"
"            MVi = Mi;\n"
"            MVj = Mj;\n"
"            MVs = Ms;\n"
"        }\n"
"        if ((boundaryMask & 8) != 0) {\n"
"            MUi = OsdFlipMatrix(Mi);\n"
"            MUj = OsdFlipMatrix(Mj);\n"
"            MUs = OsdFlipMatrix(Ms);\n"
"        }\n"
"\n"
"        vec3 Hi[4], Hj[4], Hs[4];\n"
"        for (int l=0; l<4; ++l) {\n"
"            Hi[l] = Hj[l] = Hs[l] = vec3(0);\n"
"            for (int k=0; k<4; ++k) {\n"
"                Hi[l] += MUi[i][k] * cv[l*4 + k];\n"
"                Hj[l] += MUj[i][k] * cv[l*4 + k];\n"
"                Hs[l] += MUs[i][k] * cv[l*4 + k];\n"
"            }\n"
"        }\n"
"        for (int k=0; k<4; ++k) {\n"
"            P  += MVi[j][k]*Hi[k];\n"
"            P1 += MVj[j][k]*Hj[k];\n"
"            P2 += MVs[j][k]*Hs[k];\n"
"        }\n"
"\n"
"        result.P  = P;\n"
"        result.P1 = P1;\n"
"        result.P2 = P2;\n"
"    } else {\n"
"        result.vSegments = vec2(0);\n"
"\n"
"        OsdComputeBSplineBoundaryPoints(cv, patchParam);\n"
"\n"
"        vec3 Hi[4];\n"
"        for (int l=0; l<4; ++l) {\n"
"            Hi[l] = vec3(0);\n"
"            for (int k=0; k<4; ++k) {\n"
"                Hi[l] += Q[i][k] * cv[l*4 + k];\n"
"            }\n"
"        }\n"
"        for (int k=0; k<4; ++k) {\n"
"            P += Q[j][k]*Hi[k];\n"
"        }\n"
"\n"
"        result.P  = P;\n"
"        result.P1 = P;\n"
"        result.P2 = P;\n"
"    }\n"
"#else\n"
"    OsdComputeBSplineBoundaryPoints(cv, patchParam);\n"
"\n"
"    vec3 H[4];\n"
"    for (int l=0; l<4; ++l) {\n"
"        H[l] = vec3(0);\n"
"        for (int k=0; k<4; ++k) {\n"
"            H[l] += Q[i][k] * cv[l*4 + k];\n"
"        }\n"
"    }\n"
"    {\n"
"        result.P = vec3(0);\n"
"        for (int k=0; k<4; ++k) {\n"
"            result.P += Q[j][k]*H[k];\n"
"        }\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchBezier(ivec3 patchParam, vec2 UV,\n"
"                   OsdPerPatchVertexBezier cv[16],\n"
"                   out vec3 P, out vec3 dPu, out vec3 dPv,\n"
"                   out vec3 N, out vec3 dNu, out vec3 dNv)\n"
"{\n"
"    //\n"
"    //  Use the recursive nature of the basis functions to compute a 2x2 set\n"
"    //  of intermediate points (via repeated linear interpolation).  These\n"
"    //  points define a bilinear surface tangent to the desired surface at P\n"
"    //  and so containing dPu and dPv.  The cost of computing P, dPu and dPv\n"
"    //  this way is comparable to that of typical tensor product evaluation\n"
"    //  (if not faster).\n"
"    //\n"
"    //  If N = dPu X dPv degenerates, it often results from an edge of the\n"
"    //  2x2 bilinear hull collapsing or two adjacent edges colinear. In both\n"
"    //  cases, the expected non-planar quad degenerates into a triangle, and\n"
"    //  the tangent plane of that triangle provides the desired normal N.\n"
"    //\n"
"\n"
"    //  Reduce 4x4 points to 2x4 -- two levels of linear interpolation in U\n"
"    //  and so 3 original rows contributing to each of the 2 resulting rows:\n"
"    float u    = UV.x;\n"
"    float uinv = 1.0f - u;\n"
"\n"
"    float u0 = uinv * uinv;\n"
"    float u1 = u * uinv * 2.0f;\n"
"    float u2 = u * u;\n"
"\n"
"    vec3 LROW[4], RROW[4];\n"
"#ifndef OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    LROW[0] = u0 * cv[ 0].P + u1 * cv[ 1].P + u2 * cv[ 2].P;\n"
"    LROW[1] = u0 * cv[ 4].P + u1 * cv[ 5].P + u2 * cv[ 6].P;\n"
"    LROW[2] = u0 * cv[ 8].P + u1 * cv[ 9].P + u2 * cv[10].P;\n"
"    LROW[3] = u0 * cv[12].P + u1 * cv[13].P + u2 * cv[14].P;\n"
"\n"
"    RROW[0] = u0 * cv[ 1].P + u1 * cv[ 2].P + u2 * cv[ 3].P;\n"
"    RROW[1] = u0 * cv[ 5].P + u1 * cv[ 6].P + u2 * cv[ 7].P;\n"
"    RROW[2] = u0 * cv[ 9].P + u1 * cv[10].P + u2 * cv[11].P;\n"
"    RROW[3] = u0 * cv[13].P + u1 * cv[14].P + u2 * cv[15].P;\n"
"#else\n"
"    vec2 vSegments = cv[0].vSegments;\n"
"    float s = OsdGetPatchSingleCreaseSegmentParameter(patchParam, UV);\n"
"\n"
"    for (int i = 0; i < 4; ++i) {\n"
"        int j = i*4;\n"
"        if (s <= vSegments.x) {\n"
"            LROW[i] = u0 * cv[ j ].P + u1 * cv[j+1].P + u2 * cv[j+2].P;\n"
"            RROW[i] = u0 * cv[j+1].P + u1 * cv[j+2].P + u2 * cv[j+3].P;\n"
"        } else if (s <= vSegments.y) {\n"
"            LROW[i] = u0 * cv[ j ].P1 + u1 * cv[j+1].P1 + u2 * cv[j+2].P1;\n"
"            RROW[i] = u0 * cv[j+1].P1 + u1 * cv[j+2].P1 + u2 * cv[j+3].P1;\n"
"        } else {\n"
"            LROW[i] = u0 * cv[ j ].P2 + u1 * cv[j+1].P2 + u2 * cv[j+2].P2;\n"
"            RROW[i] = u0 * cv[j+1].P2 + u1 * cv[j+2].P2 + u2 * cv[j+3].P2;\n"
"        }\n"
"    }\n"
"#endif\n"
"\n"
"    //  Reduce 2x4 points to 2x2 -- two levels of linear interpolation in V\n"
"    //  and so 3 original pairs contributing to each of the 2 resulting:\n"
"    float v    = UV.y;\n"
"    float vinv = 1.0f - v;\n"
"\n"
"    float v0 = vinv * vinv;\n"
"    float v1 = v * vinv * 2.0f;\n"
"    float v2 = v * v;\n"
"\n"
"    vec3 LPAIR[2], RPAIR[2];\n"
"    LPAIR[0] = v0 * LROW[0] + v1 * LROW[1] + v2 * LROW[2];\n"
"    RPAIR[0] = v0 * RROW[0] + v1 * RROW[1] + v2 * RROW[2];\n"
"\n"
"    LPAIR[1] = v0 * LROW[1] + v1 * LROW[2] + v2 * LROW[3];\n"
"    RPAIR[1] = v0 * RROW[1] + v1 * RROW[2] + v2 * RROW[3];\n"
"\n"
"    //  Interpolate points on the edges of the 2x2 bilinear hull from which\n"
"    //  both position and partials are trivially determined:\n"
"    vec3 DU0 = vinv * LPAIR[0] + v * LPAIR[1];\n"
"    vec3 DU1 = vinv * RPAIR[0] + v * RPAIR[1];\n"
"    vec3 DV0 = uinv * LPAIR[0] + u * RPAIR[0];\n"
"    vec3 DV1 = uinv * LPAIR[1] + u * RPAIR[1];\n"
"\n"
"    int level = OsdGetPatchFaceLevel(patchParam);\n"
"    dPu = (DU1 - DU0) * 3 * level;\n"
"    dPv = (DV1 - DV0) * 3 * level;\n"
"\n"
"    P = u * DU1 + uinv * DU0;\n"
"\n"
"    //  Compute the normal and test for degeneracy:\n"
"    //\n"
"    //  We need a geometric measure of the size of the patch for a suitable\n"
"    //  tolerance.  Magnitudes of the partials are generally proportional to\n"
"    //  that size -- the sum of the partials is readily available, cheap to\n"
"    //  compute, and has proved effective in most cases (though not perfect).\n"
"    //  The size of the bounding box of the patch, or some approximation to\n"
"    //  it, would be better but more costly to compute.\n"
"    //\n"
"    float proportionalNormalTolerance = 0.00001f;\n"
"\n"
"    float nEpsilon = (length(dPu) + length(dPv)) * proportionalNormalTolerance;\n"
"\n"
"    N = cross(dPu, dPv);\n"
"\n"
"    float nLength = length(N);\n"
"    if (nLength > nEpsilon) {\n"
"        N = N / nLength;\n"
"    } else {\n"
"        vec3 diagCross = cross(RPAIR[1] - LPAIR[0], LPAIR[1] - RPAIR[0]);\n"
"        float diagCrossLength = length(diagCross);\n"
"        if (diagCrossLength > nEpsilon) {\n"
"            N = diagCross / diagCrossLength;\n"
"        }\n"
"    }\n"
"\n"
"#ifndef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    dNu = vec3(0);\n"
"    dNv = vec3(0);\n"
"#else\n"
"    //\n"
"    //  Compute 2nd order partials of P(u,v) in order to compute 1st order partials\n"
"    //  for the un-normalized n(u,v) = dPu X dPv, then project into the tangent\n"
"    //  plane of normalized N.  With resulting dNu and dNv we can make another\n"
"    //  attempt to resolve a still-degenerate normal.\n"
"    //\n"
"    //  We don't use the Weingarten equations here as they require N != 0 and also\n"
"    //  are a little less numerically stable/accurate in single precision.\n"
"    //\n"
"    float B0u[4], B1u[4], B2u[4];\n"
"    float B0v[4], B1v[4], B2v[4];\n"
"\n"
"    OsdUnivar4x4(UV.x, B0u, B1u, B2u);\n"
"    OsdUnivar4x4(UV.y, B0v, B1v, B2v);\n"
"\n"
"    vec3 dUU = vec3(0);\n"
"    vec3 dVV = vec3(0);\n"
"    vec3 dUV = vec3(0);\n"
"\n"
"    for (int i=0; i<4; ++i) {\n"
"        for (int j=0; j<4; ++j) {\n"
"#ifdef OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"            int k = 4*i + j;\n"
"            vec3 CV = (s <= vSegments.x) ? cv[k].P\n"
"                 :   ((s <= vSegments.y) ? cv[k].P1\n"
"                                         : cv[k].P2);\n"
"#else\n"
"            vec3 CV = cv[4*i + j].P;\n"
"#endif\n"
"            dUU += (B0v[i] * B2u[j]) * CV;\n"
"            dVV += (B2v[i] * B0u[j]) * CV;\n"
"            dUV += (B1v[i] * B1u[j]) * CV;\n"
"        }\n"
"    }\n"
"\n"
"    dUU *= 6 * level;\n"
"    dVV *= 6 * level;\n"
"    dUV *= 9 * level;\n"
"\n"
"    dNu = cross(dUU, dPv) + cross(dPu, dUV);\n"
"    dNv = cross(dUV, dPv) + cross(dPu, dVV);\n"
"\n"
"    float nLengthInv = 1.0;\n"
"    if (nLength > nEpsilon) {\n"
"        nLengthInv = 1.0 / nLength;\n"
"    } else {\n"
"        //  N may have been resolved above if degenerate, but if N was resolved\n"
"        //  we don't have an accurate length for its un-normalized value, and that\n"
"        //  length is needed to project the un-normalized dNu and dNv into the\n"
"        //  tangent plane of N.\n"
"        //\n"
"        //  So compute N more accurately with available second derivatives, i.e.\n"
"        //  with a 1st order Taylor approximation to un-normalized N(u,v).\n"
"\n"
"        float DU = (UV.x == 1.0f) ? -1.0f : 1.0f;\n"
"        float DV = (UV.y == 1.0f) ? -1.0f : 1.0f;\n"
"\n"
"        N = DU * dNu + DV * dNv;\n"
"\n"
"        nLength = length(N);\n"
"        if (nLength > nEpsilon) {\n"
"            nLengthInv = 1.0f / nLength;\n"
"            N = N * nLengthInv;\n"
"        }\n"
"    }\n"
"\n"
"    //  Project derivatives of non-unit normals into tangent plane of N:\n"
"    dNu = (dNu - dot(dNu,N) * N) * nLengthInv;\n"
"    dNv = (dNv - dot(dNv,N) * N) * nLengthInv;\n"
"#endif\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Gregory Basis\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"struct OsdPerPatchVertexGregoryBasis {\n"
"    ivec3 patchParam;\n"
"    vec3 P;\n"
"};\n"
"\n"
"void\n"
"OsdComputePerPatchVertexGregoryBasis(ivec3 patchParam, int ID, vec3 cv,\n"
"                                     out OsdPerPatchVertexGregoryBasis result)\n"
"{\n"
"    result.patchParam = patchParam;\n"
"    result.P = cv;\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchGregory(ivec3 patchParam, vec2 UV, vec3 cv[20],\n"
"                    out vec3 P, out vec3 dPu, out vec3 dPv,\n"
"                    out vec3 N, out vec3 dNu, out vec3 dNv)\n"
"{\n"
"    float u = UV.x, v = UV.y;\n"
"    float U = 1-u, V = 1-v;\n"
"\n"
"    //(0,1)                              (1,1)\n"
"    //   P3         e3-      e2+         P2\n"
"    //      15------17-------11-------10\n"
"    //      |        |        |        |\n"
"    //      |        |        |        |\n"
"    //      |        | f3-    | f2+    |\n"
"    //      |       19       13        |\n"
"    //  e3+ 16-----18          14-----12 e2-\n"
"    //      |     f3+          f2-     |\n"
"    //      |                          |\n"
"    //      |                          |\n"
"    //      |     f0-         f1+      |\n"
"    //  e0- 2------4            8------6 e1+\n"
"    //      |        3 f0+    9        |\n"
"    //      |        |        | f1-    |\n"
"    //      |        |        |        |\n"
"    //      |        |        |        |\n"
"    //      0--------1--------7--------5\n"
"    //    P0        e0+      e1-         P1\n"
"    //(0,0)                               (1,0)\n"
"\n"
"    float d11 = u+v;\n"
"    float d12 = U+v;\n"
"    float d21 = u+V;\n"
"    float d22 = U+V;\n"
"\n"
"    OsdPerPatchVertexBezier bezcv[16];\n"
"\n"
"    bezcv[ 5].P = (d11 == 0.0) ? cv[3]  : (u*cv[3] + v*cv[4])/d11;\n"
"    bezcv[ 6].P = (d12 == 0.0) ? cv[8]  : (U*cv[9] + v*cv[8])/d12;\n"
"    bezcv[ 9].P = (d21 == 0.0) ? cv[18] : (u*cv[19] + V*cv[18])/d21;\n"
"    bezcv[10].P = (d22 == 0.0) ? cv[13] : (U*cv[13] + V*cv[14])/d22;\n"
"\n"
"    bezcv[ 0].P = cv[0];\n"
"    bezcv[ 1].P = cv[1];\n"
"    bezcv[ 2].P = cv[7];\n"
"    bezcv[ 3].P = cv[5];\n"
"    bezcv[ 4].P = cv[2];\n"
"    bezcv[ 7].P = cv[6];\n"
"    bezcv[ 8].P = cv[16];\n"
"    bezcv[11].P = cv[12];\n"
"    bezcv[12].P = cv[15];\n"
"    bezcv[13].P = cv[17];\n"
"    bezcv[14].P = cv[11];\n"
"    bezcv[15].P = cv[10];\n"
"\n"
"    OsdEvalPatchBezier(patchParam, UV, bezcv, P, dPu, dPv, N, dNu, dNv);\n"
"}\n"
"\n"
"//\n"
"//  Convert the 12 points of a regular patch resulting from Loop subdivision\n"
"//  into a more accessible Bezier patch for both tessellation assessment and\n"
"//  evaluation.\n"
"//\n"
"//  Regular patch for Loop subdivision -- quartic triangular Box spline:\n"
"//\n"
"//                           10 --- 11\n"
"//                           . .   . .\n"
"//                          .   . .   .\n"
"//                         7 --- 8 --- 9\n"
"//                        . .   . .   . .\n"
"//                       .   . .   . .   .\n"
"//                      3 --- 4 --- 5 --- 6\n"
"//                       .   . .   . .   .\n"
"//                        . .   . .   . .\n"
"//                         0 --- 1 --- 2\n"
"//\n"
"//  The equivalant quartic Bezier triangle (15 points):\n"
"//\n"
"//                              14\n"
"//                              . .\n"
"//                             .   .\n"
"//                           12 --- 13\n"
"//                           . .   . .\n"
"//                          .   . .   .\n"
"//                         9 -- 10 --- 11\n"
"//                        . .   . .   . .\n"
"//                       .   . .   . .   .\n"
"//                      5 --- 6 --- 7 --- 8\n"
"//                     . .   . .   . .   . .\n"
"//                    .   . .   . .   . .   .\n"
"//                   0 --- 1 --- 2 --- 3 --- 4\n"
"//\n"
"//  A hybrid cubic/quartic Bezier patch with cubic boundaries is a close\n"
"//  approximation and would only use 12 control points, but we need a full\n"
"//  quartic patch to maintain accuracy along boundary curves -- especially\n"
"//  between subdivision levels.\n"
"//\n"
"void\n"
"OsdComputePerPatchVertexBoxSplineTriangle(ivec3 patchParam, int ID, vec3 cv[12],\n"
"                                          out OsdPerPatchVertexBezier result)\n"
"{\n"
"    //\n"
"    //  Conversion matrix from 12-point Box spline to 15-point quartic Bezier\n"
"    //  patch and its common scale factor:\n"
"    //\n"
"    const float boxToBezierMatrix[12*15] = float[12*15](\n"
"    // L0   L1   L2     L3   L4   L5   L6     L7   L8   L9     L10  L11\n"
"        2,   2,   0,     2,  12,   2,   0,     2,   2,   0,     0,   0,  // B0\n"
"        1,   3,   0,     0,  12,   4,   0,     1,   3,   0,     0,   0,  // B1\n"
"        0,   4,   0,     0,   8,   8,   0,     0,   4,   0,     0,   0,  // B2\n"
"        0,   3,   1,     0,   4,  12,   0,     0,   3,   1,     0,   0,  // B3\n"
"        0,   2,   2,     0,   2,  12,   2,     0,   2,   2,     0,   0,  // B4\n"
"        0,   1,   0,     1,  12,   3,   0,     3,   4,   0,     0,   0,  // B5\n"
"        0,   1,   0,     0,  10,   6,   0,     1,   6,   0,     0,   0,  // B6\n"
"        0,   1,   0,     0,   6,  10,   0,     0,   6,   1,     0,   0,  // B7\n"
"        0,   1,   0,     0,   3,  12,   1,     0,   4,   3,     0,   0,  // B8\n"
"        0,   0,   0,     0,   8,   4,   0,     4,   8,   0,     0,   0,  // B9\n"
"        0,   0,   0,     0,   6,   6,   0,     1,  10,   1,     0,   0,  // B10\n"
"        0,   0,   0,     0,   4,   8,   0,     0,   8,   4,     0,   0,  // B11\n"
"        0,   0,   0,     0,   4,   3,   0,     3,  12,   1,     1,   0,  // B12\n"
"        0,   0,   0,     0,   3,   4,   0,     1,  12,   3,     0,   1,  // B13\n"
"        0,   0,   0,     0,   2,   2,   0,     2,  12,   2,     2,   2   // B14\n"
"    );\n"
"    const float boxToBezierMatrixScale = 1.0 / 24.0;\n"
"\n"
"    OsdComputeBoxSplineTriangleBoundaryPoints(cv, patchParam);\n"
"\n"
"    result.patchParam = patchParam;\n"
"    result.P = vec3(0);\n"
"\n"
"    int cvCoeffBase = 12 * ID;\n"
"\n"
"    for (int i = 0; i < 12; ++i) {\n"
"        result.P += boxToBezierMatrix[cvCoeffBase + i] * cv[i];\n"
"    }\n"
"    result.P *= boxToBezierMatrixScale;\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchBezierTriangle(ivec3 patchParam, vec2 UV,\n"
"                           OsdPerPatchVertexBezier cv[15],\n"
"                           out vec3 P, out vec3 dPu, out vec3 dPv,\n"
"                           out vec3 N, out vec3 dNu, out vec3 dNv)\n"
"{\n"
"    float u = UV.x;\n"
"    float v = UV.y;\n"
"    float w = 1.0 - u - v;\n"
"\n"
"    float uu = u * u;\n"
"    float vv = v * v;\n"
"    float ww = w * w;\n"
"\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    //\n"
"    //  When computing normal derivatives, we need 2nd derivatives, so compute\n"
"    //  an intermediate quadratic Bezier triangle from which 2nd derivatives\n"
"    //  can be easily computed, and which in turn yields the triangle that gives\n"
"    //  the position and 1st derivatives.\n"
"    //\n"
"    //  Quadratic barycentric basis functions (in addition to those above):\n"
"    float uv = u * v * 2.0;\n"
"    float vw = v * w * 2.0;\n"
"    float wu = w * u * 2.0;\n"
"\n"
"    vec3 Q0 = ww * cv[ 0].P + wu * cv[ 1].P + uu * cv[ 2].P +\n"
"              uv * cv[ 6].P + vv * cv[ 9].P + vw * cv[ 5].P;\n"
"    vec3 Q1 = ww * cv[ 1].P + wu * cv[ 2].P + uu * cv[ 3].P +\n"
"              uv * cv[ 7].P + vv * cv[10].P + vw * cv[ 6].P;\n"
"    vec3 Q2 = ww * cv[ 2].P + wu * cv[ 3].P + uu * cv[ 4].P +\n"
"              uv * cv[ 8].P + vv * cv[11].P + vw * cv[ 7].P;\n"
"    vec3 Q3 = ww * cv[ 5].P + wu * cv[ 6].P + uu * cv[ 7].P +\n"
"              uv * cv[10].P + vv * cv[12].P + vw * cv[ 9].P;\n"
"    vec3 Q4 = ww * cv[ 6].P + wu * cv[ 7].P + uu * cv[ 8].P +\n"
"              uv * cv[11].P + vv * cv[13].P + vw * cv[10].P;\n"
"    vec3 Q5 = ww * cv[ 9].P + wu * cv[10].P + uu * cv[11].P +\n"
"              uv * cv[13].P + vv * cv[14].P + vw * cv[12].P;\n"
"\n"
"    vec3 V0 = w * Q0 + u * Q1 + v * Q3;\n"
"    vec3 V1 = w * Q1 + u * Q2 + v * Q4;\n"
"    vec3 V2 = w * Q3 + u * Q4 + v * Q5;\n"
"#else\n"
"    //\n"
"    //  When 2nd derivatives are not required, factor the recursive evaluation\n"
"    //  of a point to directly provide the three points of the triangle at the\n"
"    //  last stage -- which then trivially provides both position and 1st\n"
"    //  derivatives.  Each point of the triangle results from evaluating the\n"
"    //  corresponding cubic Bezier sub-triangle for each corner of the quartic:\n"
"    //\n"
"    //  Cubic barycentric basis functions:\n"
"    float uuu = uu * u;\n"
"    float uuv = uu * v * 3.0;\n"
"    float uvv = u * vv * 3.0;\n"
"    float vvv = vv * v;\n"
"    float vvw = vv * w * 3.0;\n"
"    float vww = v * ww * 3.0;\n"
"    float www = ww * w;\n"
"    float wwu = ww * u * 3.0;\n"
"    float wuu = w * uu * 3.0;\n"
"    float uvw = u * v * w * 6.0;\n"
"\n"
"    vec3 V0 = www * cv[ 0].P + wwu * cv[ 1].P + wuu * cv[ 2].P\n"
"            + uuu * cv[ 3].P + uuv * cv[ 7].P + uvv * cv[10].P\n"
"            + vvv * cv[12].P + vvw * cv[ 9].P + vww * cv[ 5].P + uvw * cv[ 6].P;\n"
"\n"
"    vec3 V1 = www * cv[ 1].P + wwu * cv[ 2].P + wuu * cv[ 3].P\n"
"            + uuu * cv[ 4].P + uuv * cv[ 8].P + uvv * cv[11].P\n"
"            + vvv * cv[13].P + vvw * cv[10].P + vww * cv[ 6].P + uvw * cv[ 7].P;\n"
"\n"
"    vec3 V2 = www * cv[ 5].P + wwu * cv[ 6].P + wuu * cv[ 7].P\n"
"            + uuu * cv[ 8].P + uuv * cv[11].P + uvv * cv[13].P\n"
"            + vvv * cv[14].P + vvw * cv[12].P + vww * cv[ 9].P + uvw * cv[10].P;\n"
"#endif\n"
"\n"
"    //\n"
"    //  Compute P, du and dv all from the triangle formed from the three Vi:\n"
"    //\n"
"    P = w * V0 + u * V1 + v * V2;\n"
"\n"
"    int dSign = OsdGetPatchIsTriangleRotated(patchParam) ? -1 : 1;\n"
"    int level = OsdGetPatchFaceLevel(patchParam);\n"
"\n"
"    float d1Scale = dSign * level * 4;\n"
"\n"
"    dPu = (V1 - V0) * d1Scale;\n"
"    dPv = (V2 - V0) * d1Scale;\n"
"\n"
"    //  Compute N and test for degeneracy:\n"
"    //\n"
"    //  We need a geometric measure of the size of the patch for a suitable\n"
"    //  tolerance.  Magnitudes of the partials are generally proportional to\n"
"    //  that size -- the sum of the partials is readily available, cheap to\n"
"    //  compute, and has proved effective in most cases (though not perfect).\n"
"    //  The size of the bounding box of the patch, or some approximation to\n"
"    //  it, would be better but more costly to compute.\n"
"    //\n"
"    float proportionalNormalTolerance = 0.00001f;\n"
"\n"
"    float nEpsilon = (length(dPu) + length(dPv)) * proportionalNormalTolerance;\n"
"\n"
"    N = cross(dPu, dPv);\n"
"    float nLength = length(N);\n"
"\n"
"\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    //\n"
"    //  Compute normal derivatives using 2nd order partials, then use the\n"
"    //  normal derivatives to resolve a degenerate normal:\n"
"    //\n"
"    float d2Scale = dSign * level * level * 12;\n"
"\n"
"    vec3 dUU = (Q0 - 2 * Q1 + Q2)  * d2Scale;\n"
"    vec3 dVV = (Q0 - 2 * Q3 + Q5)  * d2Scale;\n"
"    vec3 dUV = (Q0 - Q1 + Q4 - Q3) * d2Scale;\n"
"\n"
"    dNu = cross(dUU, dPv) + cross(dPu, dUV);\n"
"    dNv = cross(dUV, dPv) + cross(dPu, dVV);\n"
"\n"
"    if (nLength < nEpsilon) {\n"
"        //  Use 1st order Taylor approximation of N(u,v) within patch interior:\n"
"        if (w > 0.0) {\n"
"            N =  dNu + dNv;\n"
"        } else if (u >= 1.0) {\n"
"            N = -dNu + dNv;\n"
"        } else if (v >= 1.0) {\n"
"            N =  dNu - dNv;\n"
"        } else {\n"
"            N = -dNu - dNv;\n"
"        }\n"
"\n"
"        nLength = length(N);\n"
"        if (nLength < nEpsilon) {\n"
"            nLength = 1.0;\n"
"        }\n"
"    }\n"
"    N = N / nLength;\n"
"\n"
"    //  Project derivs of non-unit normal function onto tangent plane of N:\n"
"    dNu = (dNu - dot(dNu,N) * N) / nLength;\n"
"    dNv = (dNv - dot(dNv,N) * N) / nLength;\n"
"#else\n"
"    dNu = vec3(0);\n"
"    dNv = vec3(0);\n"
"\n"
"    //\n"
"    //  Resolve a degenerate normal using the interior triangle of the\n"
"    //  intermediate quadratic patch that results from recursive evaluation.\n"
"    //  This addresses common cases of degenerate or colinear boundaries\n"
"    //  without resorting to use of explicit 2nd derivatives:\n"
"    //\n"
"    if (nLength < nEpsilon) {\n"
"        float uv  = u * v * 2.0;\n"
"        float vw  = v * w * 2.0;\n"
"        float wu  = w * u * 2.0;\n"
"\n"
"        vec3 Q1 = ww * cv[ 1].P + wu * cv[ 2].P + uu * cv[ 3].P +\n"
"                  uv * cv[ 7].P + vv * cv[10].P + vw * cv[ 6].P;\n"
"        vec3 Q3 = ww * cv[ 5].P + wu * cv[ 6].P + uu * cv[ 7].P +\n"
"                  uv * cv[10].P + vv * cv[12].P + vw * cv[ 9].P;\n"
"        vec3 Q4 = ww * cv[ 6].P + wu * cv[ 7].P + uu * cv[ 8].P +\n"
"                  uv * cv[11].P + vv * cv[13].P + vw * cv[10].P;\n"
"\n"
"        N = cross((Q4 - Q1), (Q3 - Q1));\n"
"        nLength = length(N);\n"
"        if (nLength < nEpsilon) {\n"
"            nLength = 1.0;\n"
"        }\n"
"    }\n"
"    N = N / nLength;\n"
"#endif\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchGregoryTriangle(ivec3 patchParam, vec2 UV, vec3 cv[18],\n"
"                            out vec3 P, out vec3 dPu, out vec3 dPv,\n"
"                            out vec3 N, out vec3 dNu, out vec3 dNv)\n"
"{\n"
"    float u = UV.x;\n"
"    float v = UV.y;\n"
"    float w = 1.0 - u - v;\n"
"\n"
"    float duv = u + v;\n"
"    float dvw = v + w;\n"
"    float dwu = w + u;\n"
"\n"
"    OsdPerPatchVertexBezier bezcv[15];\n"
"\n"
"    bezcv[ 6].P = (duv == 0.0) ? cv[3]  : ((u*cv[ 3] + v*cv[ 4]) / duv);\n"
"    bezcv[ 7].P = (dvw == 0.0) ? cv[8]  : ((v*cv[ 8] + w*cv[ 9]) / dvw);\n"
"    bezcv[10].P = (dwu == 0.0) ? cv[13] : ((w*cv[13] + u*cv[14]) / dwu);\n"
"\n"
"    bezcv[ 0].P = cv[ 0];\n"
"    bezcv[ 1].P = cv[ 1];\n"
"    bezcv[ 2].P = cv[15];\n"
"    bezcv[ 3].P = cv[ 7];\n"
"    bezcv[ 4].P = cv[ 5];\n"
"    bezcv[ 5].P = cv[ 2];\n"
"    bezcv[ 8].P = cv[ 6];\n"
"    bezcv[ 9].P = cv[17];\n"
"    bezcv[11].P = cv[16];\n"
"    bezcv[12].P = cv[11];\n"
"    bezcv[13].P = cv[12];\n"
"    bezcv[14].P = cv[10];\n"
"\n"
"    OsdEvalPatchBezierTriangle(patchParam, UV, bezcv, P, dPu, dPv, N, dNu, dNv);\n"
"}\n"
"\n"
"\n"
;
static const char *commonTessShaderSource = 
"//\n"
"//   Copyright 2013-2018 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Tessellation\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"// For now, fractional spacing is supported only with screen space tessellation\n"
"#ifndef OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"#undef OSD_FRACTIONAL_EVEN_SPACING\n"
"#undef OSD_FRACTIONAL_ODD_SPACING\n"
"#endif\n"
"\n"
"#if defined OSD_FRACTIONAL_EVEN_SPACING\n"
"  #define OSD_SPACING fractional_even_spacing\n"
"#elif defined OSD_FRACTIONAL_ODD_SPACING\n"
"  #define OSD_SPACING fractional_odd_spacing\n"
"#else\n"
"  #define OSD_SPACING equal_spacing\n"
"#endif\n"
"\n"
"//\n"
"// Organization of B-spline and Bezier control points.\n"
"//\n"
"// Each patch is defined by 16 control points (labeled 0-15).\n"
"//\n"
"// The patch will be evaluated across the domain from (0,0) at\n"
"// the lower-left to (1,1) at the upper-right. When computing\n"
"// adaptive tessellation metrics, we consider refined vertex-vertex\n"
"// and edge-vertex points along the transition edges of the patch\n"
"// (labeled vv* and ev* respectively).\n"
"//\n"
"// The two segments of each transition edge are labeled Lo and Hi,\n"
"// with the Lo segment occurring before the Hi segment along the\n"
"// transition edge's domain parameterization. These Lo and Hi segment\n"
"// tessellation levels determine how domain evaluation coordinates\n"
"// are remapped along transition edges. The Hi segment value will\n"
"// be zero for a non-transition edge.\n"
"//\n"
"// (0,1)                                         (1,1)\n"
"//\n"
"//   vv3                  ev23                   vv2\n"
"//        |       Lo3       |       Hi3       |\n"
"//      --O-----------O-----+-----O-----------O--\n"
"//        | 12        | 13     14 |        15 |\n"
"//        |           |           |           |\n"
"//        |           |           |           |\n"
"//    Hi0 |           |           |           | Hi2\n"
"//        |           |           |           |\n"
"//        O-----------O-----------O-----------O\n"
"//        | 8         | 9      10 |        11 |\n"
"//        |           |           |           |\n"
"// ev03 --+           |           |           +-- ev12\n"
"//        |           |           |           |\n"
"//        | 4         | 5       6 |         7 |\n"
"//        O-----------O-----------O-----------O\n"
"//        |           |           |           |\n"
"//    Lo0 |           |           |           | Lo2\n"
"//        |           |           |           |\n"
"//        |           |           |           |\n"
"//        | 0         | 1       2 |         3 |\n"
"//      --O-----------O-----+-----O-----------O--\n"
"//        |       Lo1       |       Hi1       |\n"
"//   vv0                  ev01                   vv1\n"
"//\n"
"// (0,0)                                         (1,0)\n"
"//\n"
"\n"
"#define OSD_MAX_TESS_LEVEL gl_MaxTessGenLevel\n"
"\n"
"float OsdComputePostProjectionSphereExtent(vec3 center, float diameter)\n"
"{\n"
"    vec4 p = OsdProjectionMatrix() * vec4(center, 1.0);\n"
"    return abs(diameter * OsdProjectionMatrix()[1][1] / p.w);\n"
"}\n"
"\n"
"float OsdComputeTessLevel(vec3 p0, vec3 p1)\n"
"{\n"
"    // Adaptive factor can be any computation that depends only on arg values.\n"
"    // Project the diameter of the edge's bounding sphere instead of using the\n"
"    // length of the projected edge itself to avoid problems near silhouettes.\n"
"    p0 = (OsdModelViewMatrix() * vec4(p0, 1.0)).xyz;\n"
"    p1 = (OsdModelViewMatrix() * vec4(p1, 1.0)).xyz;\n"
"    vec3 center = (p0 + p1) / 2.0;\n"
"    float diameter = distance(p0, p1);\n"
"    float projLength = OsdComputePostProjectionSphereExtent(center, diameter);\n"
"    float tessLevel = max(1.0, OsdTessLevel() * projLength);\n"
"\n"
"    // We restrict adaptive tessellation levels to half of the device\n"
"    // supported maximum because transition edges are split into two\n"
"    // halves and the sum of the two corresponding levels must not exceed\n"
"    // the device maximum. We impose this limit even for non-transition\n"
"    // edges because a non-transition edge must be able to match up with\n"
"    // one half of the transition edge of an adjacent transition patch.\n"
"    return min(tessLevel, OSD_MAX_TESS_LEVEL / 2);\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsUniform(ivec3 patchParam,\n"
"                        out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    // Uniform factors are simple powers of two for each level.\n"
"    // The maximum here can be increased if we know the maximum\n"
"    // refinement level of the mesh:\n"
"    //     min(OSD_MAX_TESS_LEVEL, pow(2, MaximumRefinementLevel-1)\n"
"    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);\n"
"    float tessLevel = min(OsdTessLevel(), OSD_MAX_TESS_LEVEL) /\n"
"                        pow(2, refinementLevel-1);\n"
"\n"
"    // tessLevels of transition edge should be clamped to 2.\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"    vec4 tessLevelMin = vec4(1) + vec4(((transitionMask & 8) >> 3),\n"
"                                       ((transitionMask & 1) >> 0),\n"
"                                       ((transitionMask & 2) >> 1),\n"
"                                       ((transitionMask & 4) >> 2));\n"
"\n"
"    tessOuterLo = max(vec4(tessLevel), tessLevelMin);\n"
"    tessOuterHi = vec4(0);\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsUniformTriangle(ivec3 patchParam,\n"
"                        out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    // Uniform factors are simple powers of two for each level.\n"
"    // The maximum here can be increased if we know the maximum\n"
"    // refinement level of the mesh:\n"
"    //     min(OSD_MAX_TESS_LEVEL, pow(2, MaximumRefinementLevel-1)\n"
"    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);\n"
"    float tessLevel = min(OsdTessLevel(), OSD_MAX_TESS_LEVEL) /\n"
"                        pow(2, refinementLevel-1);\n"
"\n"
"    // tessLevels of transition edge should be clamped to 2.\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"    vec4 tessLevelMin = vec4(1) + vec4(((transitionMask & 4) >> 2),\n"
"                                       ((transitionMask & 1) >> 0),\n"
"                                       ((transitionMask & 2) >> 1),\n"
"                                       0);\n"
"\n"
"    tessOuterLo = max(vec4(tessLevel), tessLevelMin);\n"
"    tessOuterHi = vec4(0);\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsRefinedPoints(vec3 cp[16], ivec3 patchParam,\n"
"                              out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    // Each edge of a transition patch is adjacent to one or two patches\n"
"    // at the next refined level of subdivision. We compute the corresponding\n"
"    // vertex-vertex and edge-vertex refined points along the edges of the\n"
"    // patch using Catmull-Clark subdivision stencil weights.\n"
"    // For simplicity, we let the optimizer discard unused computation.\n"
"\n"
"    vec3 vv0 = (cp[0] + cp[2] + cp[8] + cp[10]) * 0.015625 +\n"
"               (cp[1] + cp[4] + cp[6] + cp[9]) * 0.09375 + cp[5] * 0.5625;\n"
"    vec3 ev01 = (cp[1] + cp[2] + cp[9] + cp[10]) * 0.0625 +\n"
"                (cp[5] + cp[6]) * 0.375;\n"
"\n"
"    vec3 vv1 = (cp[1] + cp[3] + cp[9] + cp[11]) * 0.015625 +\n"
"               (cp[2] + cp[5] + cp[7] + cp[10]) * 0.09375 + cp[6] * 0.5625;\n"
"    vec3 ev12 = (cp[5] + cp[7] + cp[9] + cp[11]) * 0.0625 +\n"
"                (cp[6] + cp[10]) * 0.375;\n"
"\n"
"    vec3 vv2 = (cp[5] + cp[7] + cp[13] + cp[15]) * 0.015625 +\n"
"               (cp[6] + cp[9] + cp[11] + cp[14]) * 0.09375 + cp[10] * 0.5625;\n"
"    vec3 ev23 = (cp[5] + cp[6] + cp[13] + cp[14]) * 0.0625 +\n"
"                (cp[9] + cp[10]) * 0.375;\n"
"\n"
"    vec3 vv3 = (cp[4] + cp[6] + cp[12] + cp[14]) * 0.015625 +\n"
"               (cp[5] + cp[8] + cp[10] + cp[13]) * 0.09375 + cp[9] * 0.5625;\n"
"    vec3 ev03 = (cp[4] + cp[6] + cp[8] + cp[10]) * 0.0625 +\n"
"                (cp[5] + cp[9]) * 0.375;\n"
"\n"
"    tessOuterLo = vec4(0);\n"
"    tessOuterHi = vec4(0);\n"
"\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"\n"
"    if ((transitionMask & 8) != 0) {\n"
"        tessOuterLo[0] = OsdComputeTessLevel(vv0, ev03);\n"
"        tessOuterHi[0] = OsdComputeTessLevel(vv3, ev03);\n"
"    } else {\n"
"        tessOuterLo[0] = OsdComputeTessLevel(cp[5], cp[9]);\n"
"    }\n"
"    if ((transitionMask & 1) != 0) {\n"
"        tessOuterLo[1] = OsdComputeTessLevel(vv0, ev01);\n"
"        tessOuterHi[1] = OsdComputeTessLevel(vv1, ev01);\n"
"    } else {\n"
"        tessOuterLo[1] = OsdComputeTessLevel(cp[5], cp[6]);\n"
"    }\n"
"    if ((transitionMask & 2) != 0) {\n"
"        tessOuterLo[2] = OsdComputeTessLevel(vv1, ev12);\n"
"        tessOuterHi[2] = OsdComputeTessLevel(vv2, ev12);\n"
"    } else {\n"
"        tessOuterLo[2] = OsdComputeTessLevel(cp[6], cp[10]);\n"
"    }\n"
"    if ((transitionMask & 4) != 0) {\n"
"        tessOuterLo[3] = OsdComputeTessLevel(vv3, ev23);\n"
"        tessOuterHi[3] = OsdComputeTessLevel(vv2, ev23);\n"
"    } else {\n"
"        tessOuterLo[3] = OsdComputeTessLevel(cp[9], cp[10]);\n"
"    }\n"
"}\n"
"\n"
"//\n"
"//  Patch boundary corners are ordered counter-clockwise from the first\n"
"//  corner while patch boundary edges and their midpoints are similarly\n"
"//  ordered counter-clockwise beginning at the edge preceding corner[0].\n"
"//\n"
"void\n"
"Osd_GetTessLevelsFromPatchBoundaries4(vec3 corners[4], vec3 midpoints[4],\n"
"                 ivec3 patchParam, out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    tessOuterLo = vec4(0);\n"
"    tessOuterHi = vec4(0);\n"
"\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"\n"
"    if ((transitionMask & 8) != 0) {\n"
"        tessOuterLo[0] = OsdComputeTessLevel(corners[0], midpoints[0]);\n"
"        tessOuterHi[0] = OsdComputeTessLevel(corners[3], midpoints[0]);\n"
"    } else {\n"
"        tessOuterLo[0] = OsdComputeTessLevel(corners[0], corners[3]);\n"
"    }\n"
"    if ((transitionMask & 1) != 0) {\n"
"        tessOuterLo[1] = OsdComputeTessLevel(corners[0], midpoints[1]);\n"
"        tessOuterHi[1] = OsdComputeTessLevel(corners[1], midpoints[1]);\n"
"    } else {\n"
"        tessOuterLo[1] = OsdComputeTessLevel(corners[0], corners[1]);\n"
"    }\n"
"    if ((transitionMask & 2) != 0) {\n"
"        tessOuterLo[2] = OsdComputeTessLevel(corners[1], midpoints[2]);\n"
"        tessOuterHi[2] = OsdComputeTessLevel(corners[2], midpoints[2]);\n"
"    } else {\n"
"        tessOuterLo[2] = OsdComputeTessLevel(corners[1], corners[2]);\n"
"    }\n"
"    if ((transitionMask & 4) != 0) {\n"
"        tessOuterLo[3] = OsdComputeTessLevel(corners[3], midpoints[3]);\n"
"        tessOuterHi[3] = OsdComputeTessLevel(corners[2], midpoints[3]);\n"
"    } else {\n"
"        tessOuterLo[3] = OsdComputeTessLevel(corners[3], corners[2]);\n"
"    }\n"
"}\n"
"\n"
"void\n"
"Osd_GetTessLevelsFromPatchBoundaries3(vec3 corners[3], vec3 midpoints[3],\n"
"                 ivec3 patchParam, out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    tessOuterLo = vec4(0);\n"
"    tessOuterHi = vec4(0);\n"
"\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"\n"
"    if ((transitionMask & 4) != 0) {\n"
"        tessOuterLo[0] = OsdComputeTessLevel(corners[0], midpoints[0]);\n"
"        tessOuterHi[0] = OsdComputeTessLevel(corners[2], midpoints[0]);\n"
"    } else {\n"
"        tessOuterLo[0] = OsdComputeTessLevel(corners[0], corners[2]);\n"
"    }\n"
"    if ((transitionMask & 1) != 0) {\n"
"        tessOuterLo[1] = OsdComputeTessLevel(corners[0], midpoints[1]);\n"
"        tessOuterHi[1] = OsdComputeTessLevel(corners[1], midpoints[1]);\n"
"    } else {\n"
"        tessOuterLo[1] = OsdComputeTessLevel(corners[0], corners[1]);\n"
"    }\n"
"    if ((transitionMask & 2) != 0) {\n"
"        tessOuterLo[2] = OsdComputeTessLevel(corners[2], midpoints[2]);\n"
"        tessOuterHi[2] = OsdComputeTessLevel(corners[1], midpoints[2]);\n"
"    } else {\n"
"        tessOuterLo[2] = OsdComputeTessLevel(corners[1], corners[2]);\n"
"    }\n"
"}\n"
"\n"
"vec3\n"
"Osd_EvalBezierCurveMidPoint(vec3 p0, vec3 p1, vec3 p2, vec3 p3)\n"
"{\n"
"    //  Coefficients for the midpoint are { 1/8, 3/8, 3/8, 1/8 }:\n"
"    return 0.125 * (p0 + p3) + 0.375 * (p1 + p2);\n"
"}\n"
"\n"
"vec3\n"
"Osd_EvalQuarticBezierCurveMidPoint(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 p4)\n"
"{\n"
"    //  Coefficients for the midpoint are { 1/16, 1/4, 3/8, 1/4, 1/16 }:\n"
"    return 0.0625 * (p0 + p4) + 0.25 * (p1 + p3) + 0.375 * p2;\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchBezierTessLevels(OsdPerPatchVertexBezier cpBezier[16],\n"
"                 ivec3 patchParam, out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    // Each edge of a transition patch is adjacent to one or two patches\n"
"    // at the next refined level of subdivision. When the patch control\n"
"    // points have been converted to the Bezier basis, the control points\n"
"    // at the four corners are on the limit surface (since a Bezier patch\n"
"    // interpolates its corner control points). We can compute an adaptive\n"
"    // tessellation level for transition edges on the limit surface by\n"
"    // evaluating a limit position at the mid point of each transition edge.\n"
"\n"
"    tessOuterLo = vec4(0);\n"
"    tessOuterHi = vec4(0);\n"
"\n"
"    vec3 corners[4];\n"
"    vec3 midpoints[4];\n"
"\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"\n"
"#if defined OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    corners[0] = OsdEvalBezier(cpBezier, patchParam, vec2(0.0, 0.0));\n"
"    corners[1] = OsdEvalBezier(cpBezier, patchParam, vec2(1.0, 0.0));\n"
"    corners[2] = OsdEvalBezier(cpBezier, patchParam, vec2(1.0, 1.0));\n"
"    corners[3] = OsdEvalBezier(cpBezier, patchParam, vec2(0.0, 1.0));\n"
"\n"
"    midpoints[0] = ((transitionMask & 8) == 0) ? vec3(0) :  \n"
"        OsdEvalBezier(cpBezier, patchParam, vec2(0.0, 0.5));\n"
"    midpoints[1] = ((transitionMask & 1) == 0) ? vec3(0) :  \n"
"        OsdEvalBezier(cpBezier, patchParam, vec2(0.5, 0.0));\n"
"    midpoints[2] = ((transitionMask & 2) == 0) ? vec3(0) :  \n"
"        OsdEvalBezier(cpBezier, patchParam, vec2(1.0, 0.5));\n"
"    midpoints[3] = ((transitionMask & 4) == 0) ? vec3(0) :\n"
"        OsdEvalBezier(cpBezier, patchParam, vec2(0.5, 1.0));\n"
"#else\n"
"    corners[0] = cpBezier[ 0].P;\n"
"    corners[1] = cpBezier[ 3].P;\n"
"    corners[2] = cpBezier[15].P;\n"
"    corners[3] = cpBezier[12].P;\n"
"\n"
"    midpoints[0] = ((transitionMask & 8) == 0) ? vec3(0) :\n"
"        Osd_EvalBezierCurveMidPoint(\n"
"            cpBezier[0].P, cpBezier[4].P, cpBezier[8].P, cpBezier[12].P);\n"
"    midpoints[1] = ((transitionMask & 1) == 0) ? vec3(0) :\n"
"        Osd_EvalBezierCurveMidPoint(\n"
"            cpBezier[0].P, cpBezier[1].P, cpBezier[2].P, cpBezier[3].P);\n"
"    midpoints[2] = ((transitionMask & 2) == 0) ? vec3(0) :\n"
"        Osd_EvalBezierCurveMidPoint(\n"
"            cpBezier[3].P, cpBezier[7].P, cpBezier[11].P, cpBezier[15].P);\n"
"    midpoints[3] = ((transitionMask & 4) == 0) ? vec3(0) :\n"
"        Osd_EvalBezierCurveMidPoint(\n"
"            cpBezier[12].P, cpBezier[13].P, cpBezier[14].P, cpBezier[15].P);\n"
"#endif\n"
"\n"
"    Osd_GetTessLevelsFromPatchBoundaries4(corners, midpoints,\n"
"                                          patchParam, tessOuterLo, tessOuterHi);\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchBezierTriangleTessLevels(vec3 cv[15],\n"
"                 ivec3 patchParam, out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    // Each edge of a transition patch is adjacent to one or two patches\n"
"    // at the next refined level of subdivision. When the patch control\n"
"    // points have been converted to the Bezier basis, the control points\n"
"    // at the corners are on the limit surface (since a Bezier patch\n"
"    // interpolates its corner control points). We can compute an adaptive\n"
"    // tessellation level for transition edges on the limit surface by\n"
"    // evaluating a limit position at the mid point of each transition edge.\n"
"\n"
"    tessOuterLo = vec4(0);\n"
"    tessOuterHi = vec4(0);\n"
"\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"\n"
"    vec3 corners[3];\n"
"    corners[0] = cv[0];\n"
"    corners[1] = cv[4];\n"
"    corners[2] = cv[14];\n"
"\n"
"    vec3 midpoints[3];\n"
"    midpoints[0] = ((transitionMask & 4) == 0) ? vec3(0) :\n"
"        Osd_EvalQuarticBezierCurveMidPoint(cv[0], cv[5], cv[9], cv[12], cv[14]);\n"
"    midpoints[1] = ((transitionMask & 1) == 0) ? vec3(0) :\n"
"        Osd_EvalQuarticBezierCurveMidPoint(cv[0], cv[1], cv[2], cv[3], cv[4]);\n"
"    midpoints[2] = ((transitionMask & 2) == 0) ? vec3(0) :\n"
"        Osd_EvalQuarticBezierCurveMidPoint(cv[4], cv[8], cv[11], cv[13], cv[14]);\n"
"\n"
"    Osd_GetTessLevelsFromPatchBoundaries3(corners, midpoints,\n"
"                                          patchParam, tessOuterLo, tessOuterHi);\n"
"}\n"
"\n"
"// Round up to the nearest even integer\n"
"float OsdRoundUpEven(float x) {\n"
"    return 2*ceil(x/2);\n"
"}\n"
"\n"
"// Round up to the nearest odd integer\n"
"float OsdRoundUpOdd(float x) {\n"
"    return 2*ceil((x+1)/2)-1;\n"
"}\n"
"\n"
"// Compute outer and inner tessellation levels taking into account the\n"
"// current tessellation spacing mode.\n"
"void\n"
"OsdComputeTessLevels(inout vec4 tessOuterLo, inout vec4 tessOuterHi,\n"
"                     out vec4 tessLevelOuter, out vec2 tessLevelInner)\n"
"{\n"
"    // Outer levels are the sum of the Lo and Hi segments where the Hi\n"
"    // segments will have lengths of zero for non-transition edges.\n"
"\n"
"#if defined OSD_FRACTIONAL_EVEN_SPACING\n"
"    // Combine fractional outer transition edge levels before rounding.\n"
"    vec4 combinedOuter = tessOuterLo + tessOuterHi;\n"
"\n"
"    // Round the segments of transition edges separately. We will recover the\n"
"    // fractional parameterization of transition edges after tessellation.\n"
"\n"
"    tessLevelOuter = combinedOuter;\n"
"    if (tessOuterHi[0] > 0) {\n"
"        tessLevelOuter[0] =\n"
"            OsdRoundUpEven(tessOuterLo[0]) + OsdRoundUpEven(tessOuterHi[0]);\n"
"    }\n"
"    if (tessOuterHi[1] > 0) {\n"
"        tessLevelOuter[1] =\n"
"            OsdRoundUpEven(tessOuterLo[1]) + OsdRoundUpEven(tessOuterHi[1]);\n"
"    }\n"
"    if (tessOuterHi[2] > 0) {\n"
"        tessLevelOuter[2] =\n"
"            OsdRoundUpEven(tessOuterLo[2]) + OsdRoundUpEven(tessOuterHi[2]);\n"
"    }\n"
"    if (tessOuterHi[3] > 0) {\n"
"        tessLevelOuter[3] =\n"
"            OsdRoundUpEven(tessOuterLo[3]) + OsdRoundUpEven(tessOuterHi[3]);\n"
"    }\n"
"#elif defined OSD_FRACTIONAL_ODD_SPACING\n"
"    // Combine fractional outer transition edge levels before rounding.\n"
"    vec4 combinedOuter = tessOuterLo + tessOuterHi;\n"
"\n"
"    // Round the segments of transition edges separately. We will recover the\n"
"    // fractional parameterization of transition edges after tessellation.\n"
"    //\n"
"    // The sum of the two outer odd segment lengths will be an even number\n"
"    // which the tessellator will increase by +1 so that there will be a\n"
"    // total odd number of segments. We clamp the combinedOuter tess levels\n"
"    // (used to compute the inner tess levels) so that the outer transition\n"
"    // edges will be sampled without degenerate triangles.\n"
"\n"
"    tessLevelOuter = combinedOuter;\n"
"    if (tessOuterHi[0] > 0) {\n"
"        tessLevelOuter[0] =\n"
"            OsdRoundUpOdd(tessOuterLo[0]) + OsdRoundUpOdd(tessOuterHi[0]);\n"
"        combinedOuter = max(vec4(3), combinedOuter);\n"
"    }\n"
"    if (tessOuterHi[1] > 0) {\n"
"        tessLevelOuter[1] =\n"
"            OsdRoundUpOdd(tessOuterLo[1]) + OsdRoundUpOdd(tessOuterHi[1]);\n"
"        combinedOuter = max(vec4(3), combinedOuter);\n"
"    }\n"
"    if (tessOuterHi[2] > 0) {\n"
"        tessLevelOuter[2] =\n"
"            OsdRoundUpOdd(tessOuterLo[2]) + OsdRoundUpOdd(tessOuterHi[2]);\n"
"        combinedOuter = max(vec4(3), combinedOuter);\n"
"    }\n"
"    if (tessOuterHi[3] > 0) {\n"
"        tessLevelOuter[3] =\n"
"            OsdRoundUpOdd(tessOuterLo[3]) + OsdRoundUpOdd(tessOuterHi[3]);\n"
"        combinedOuter = max(vec4(3), combinedOuter);\n"
"    }\n"
"#else\n"
"    // Round equally spaced transition edge levels before combining.\n"
"    tessOuterLo = round(tessOuterLo);\n"
"    tessOuterHi = round(tessOuterHi);\n"
"\n"
"    vec4 combinedOuter = tessOuterLo + tessOuterHi;\n"
"    tessLevelOuter = combinedOuter;\n"
"#endif\n"
"\n"
"    // Inner levels are the averages the corresponding outer levels.\n"
"    tessLevelInner[0] = (combinedOuter[1] + combinedOuter[3]) * 0.5;\n"
"    tessLevelInner[1] = (combinedOuter[0] + combinedOuter[2]) * 0.5;\n"
"}\n"
"\n"
"void\n"
"OsdComputeTessLevelsTriangle(inout vec4 tessOuterLo, inout vec4 tessOuterHi,\n"
"                             out vec4 tessLevelOuter, out vec2 tessLevelInner)\n"
"{\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi,\n"
"                         tessLevelOuter, tessLevelInner);\n"
"\n"
"    // Inner level is the max of the three outer levels.\n"
"    tessLevelInner[0] = max(max(tessLevelOuter[0],\n"
"                                tessLevelOuter[1]),\n"
"                                tessLevelOuter[2]);\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsUniform(ivec3 patchParam,\n"
"                 out vec4 tessLevelOuter, out vec2 tessLevelInner,\n"
"                 out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    OsdGetTessLevelsUniform(patchParam, tessOuterLo, tessOuterHi);\n"
"\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi,\n"
"                         tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsUniformTriangle(ivec3 patchParam,\n"
"                 out vec4 tessLevelOuter, out vec2 tessLevelInner,\n"
"                 out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    OsdGetTessLevelsUniformTriangle(patchParam, tessOuterLo, tessOuterHi);\n"
"\n"
"    OsdComputeTessLevelsTriangle(tessOuterLo, tessOuterHi,\n"
"                                 tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchBezierTessLevels(OsdPerPatchVertexBezier cpBezier[16],\n"
"                 ivec3 patchParam,\n"
"                 out vec4 tessLevelOuter, out vec2 tessLevelInner,\n"
"                 out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    OsdEvalPatchBezierTessLevels(cpBezier, patchParam,\n"
"                                 tessOuterLo, tessOuterHi);\n"
"\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi,\n"
"                         tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchBezierTriangleTessLevels(vec3 cv[15],\n"
"                 ivec3 patchParam,\n"
"                 out vec4 tessLevelOuter, out vec2 tessLevelInner,\n"
"                 out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    OsdEvalPatchBezierTriangleTessLevels(cv, patchParam,\n"
"                                         tessOuterLo, tessOuterHi);\n"
"\n"
"    OsdComputeTessLevelsTriangle(tessOuterLo, tessOuterHi,\n"
"                                 tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsAdaptiveRefinedPoints(vec3 cpRefined[16], ivec3 patchParam,\n"
"                        out vec4 tessLevelOuter, out vec2 tessLevelInner,\n"
"                        out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    OsdGetTessLevelsRefinedPoints(cpRefined, patchParam,\n"
"                                  tessOuterLo, tessOuterHi);\n"
"\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi,\n"
"                         tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of newer Bezier patch equivalent:\n"
"void\n"
"OsdGetTessLevelsLimitPoints(OsdPerPatchVertexBezier cpBezier[16],\n"
"                 ivec3 patchParam, out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    OsdEvalPatchBezierTessLevels(cpBezier, patchParam, tessOuterLo, tessOuterHi);\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of newer Bezier patch equivalent:\n"
"void\n"
"OsdGetTessLevelsAdaptiveLimitPoints(OsdPerPatchVertexBezier cpBezier[16],\n"
"                 ivec3 patchParam,\n"
"                 out vec4 tessLevelOuter, out vec2 tessLevelInner,\n"
"                 out vec4 tessOuterLo, out vec4 tessOuterHi)\n"
"{\n"
"    OsdGetTessLevelsLimitPoints(cpBezier, patchParam,\n"
"                                tessOuterLo, tessOuterHi);\n"
"\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi,\n"
"                         tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of newer Bezier patch equivalent:\n"
"void\n"
"OsdGetTessLevels(vec3 cp0, vec3 cp1, vec3 cp2, vec3 cp3,\n"
"                 ivec3 patchParam,\n"
"                 out vec4 tessLevelOuter, out vec2 tessLevelInner)\n"
"{\n"
"    vec4 tessOuterLo = vec4(0);\n"
"    vec4 tessOuterHi = vec4(0);\n"
"\n"
"#if defined OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    tessOuterLo[0] = OsdComputeTessLevel(cp0, cp1);\n"
"    tessOuterLo[1] = OsdComputeTessLevel(cp0, cp3);\n"
"    tessOuterLo[2] = OsdComputeTessLevel(cp2, cp3);\n"
"    tessOuterLo[3] = OsdComputeTessLevel(cp1, cp2);\n"
"    tessOuterHi = vec4(0);\n"
"#else\n"
"    OsdGetTessLevelsUniform(patchParam, tessOuterLo, tessOuterHi);\n"
"#endif\n"
"\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi,\n"
"                         tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"#if defined OSD_FRACTIONAL_EVEN_SPACING || defined OSD_FRACTIONAL_ODD_SPACING\n"
"float\n"
"OsdGetTessFractionalSplit(float t, float level, float levelUp)\n"
"{\n"
"    // Fractional tessellation of an edge will produce n segments where n\n"
"    // is the tessellation level of the edge (level) rounded up to the\n"
"    // nearest even or odd integer (levelUp). There will be n-2 segments of\n"
"    // equal length (dx1) and two additional segments of equal length (dx0)\n"
"    // that are typically shorter than the other segments. The two additional\n"
"    // segments should be placed symmetrically on opposite sides of the\n"
"    // edge (offset).\n"
"\n"
"#if defined OSD_FRACTIONAL_EVEN_SPACING\n"
"    if (level <= 2) return t;\n"
"\n"
"    float base = pow(2.0,floor(log2(levelUp)));\n"
"    float offset = 1.0/(int(2*base-levelUp)/2 & int(base/2-1));\n"
"\n"
"#elif defined OSD_FRACTIONAL_ODD_SPACING\n"
"    if (level <= 1) return t;\n"
"\n"
"    float base = pow(2.0,floor(log2(levelUp)));\n"
"    float offset = 1.0/(((int(2*base-levelUp)/2+1) & int(base/2-1))+1);\n"
"#endif\n"
"\n"
"    float dx0 = (1.0 - (levelUp-level)/2) / levelUp;\n"
"    float dx1 = (1.0 - 2.0*dx0) / (levelUp - 2.0*ceil(dx0));\n"
"\n"
"    if (t < 0.5) {\n"
"        float x = levelUp/2 - round(t*levelUp);\n"
"        return 0.5 - (x*dx1 + int(x*offset > 1) * (dx0 - dx1));\n"
"    } else if (t > 0.5) {\n"
"        float x = round(t*levelUp) - levelUp/2;\n"
"        return 0.5 + (x*dx1 + int(x*offset > 1) * (dx0 - dx1));\n"
"    } else {\n"
"        return t;\n"
"    }\n"
"}\n"
"#endif\n"
"\n"
"float\n"
"OsdGetTessTransitionSplit(float t, float lo, float hi)\n"
"{\n"
"#if defined OSD_FRACTIONAL_EVEN_SPACING\n"
"    float loRoundUp = OsdRoundUpEven(lo);\n"
"    float hiRoundUp = OsdRoundUpEven(hi);\n"
"\n"
"    // Convert the parametric t into a segment index along the combined edge.\n"
"    float ti = round(t * (loRoundUp + hiRoundUp));\n"
"\n"
"    if (ti <= loRoundUp) {\n"
"        float t0 = ti / loRoundUp;\n"
"        return OsdGetTessFractionalSplit(t0, lo, loRoundUp) * 0.5;\n"
"    } else {\n"
"        float t1 = (ti - loRoundUp) / hiRoundUp;\n"
"        return OsdGetTessFractionalSplit(t1, hi, hiRoundUp) * 0.5 + 0.5;\n"
"    }\n"
"#elif defined OSD_FRACTIONAL_ODD_SPACING\n"
"    float loRoundUp = OsdRoundUpOdd(lo);\n"
"    float hiRoundUp = OsdRoundUpOdd(hi);\n"
"\n"
"    // Convert the parametric t into a segment index along the combined edge.\n"
"    // The +1 below is to account for the extra segment produced by the\n"
"    // tessellator since the sum of two odd tess levels will be rounded\n"
"    // up by one to the next odd integer tess level.\n"
"    float ti = round(t * (loRoundUp + hiRoundUp + 1));\n"
"\n"
"    if (ti <= loRoundUp) {\n"
"        float t0 = ti / loRoundUp;\n"
"        return OsdGetTessFractionalSplit(t0, lo, loRoundUp) * 0.5;\n"
"    } else if (ti > (loRoundUp+1)) {\n"
"        float t1 = (ti - (loRoundUp+1)) / hiRoundUp;\n"
"        return OsdGetTessFractionalSplit(t1, hi, hiRoundUp) * 0.5 + 0.5;\n"
"    } else {\n"
"        return 0.5;\n"
"    }\n"
"#else\n"
"    // Convert the parametric t into a segment index along the combined edge.\n"
"    float ti = round(t * (lo + hi));\n"
"\n"
"    if (ti <= lo) {\n"
"        return (ti / lo) * 0.5;\n"
"    } else {\n"
"        return ((ti - lo) / hi) * 0.5 + 0.5;\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"vec2\n"
"OsdGetTessParameterization(vec2 p, vec4 tessOuterLo, vec4 tessOuterHi)\n"
"{\n"
"    vec2 UV = p;\n"
"    if (p.x == 0 && tessOuterHi[0] > 0) {\n"
"        UV.y = OsdGetTessTransitionSplit(UV.y, tessOuterLo[0], tessOuterHi[0]);\n"
"    } else\n"
"    if (p.y == 0 && tessOuterHi[1] > 0) {\n"
"        UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[1], tessOuterHi[1]);\n"
"    } else\n"
"    if (p.x == 1 && tessOuterHi[2] > 0) {\n"
"        UV.y = OsdGetTessTransitionSplit(UV.y, tessOuterLo[2], tessOuterHi[2]);\n"
"    } else\n"
"    if (p.y == 1 && tessOuterHi[3] > 0) {\n"
"        UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[3], tessOuterHi[3]);\n"
"    }\n"
"    return UV;\n"
"}\n"
"\n"
"vec2\n"
"OsdGetTessParameterizationTriangle(vec3 p, vec4 tessOuterLo, vec4 tessOuterHi)\n"
"{\n"
"    vec2 UV = p.xy;\n"
"    if (p.x == 0 && tessOuterHi[0] > 0) {\n"
"        UV.y = OsdGetTessTransitionSplit(UV.y, tessOuterLo[0], tessOuterHi[0]);\n"
"    } else\n"
"    if (p.y == 0 && tessOuterHi[1] > 0) {\n"
"        UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[1], tessOuterHi[1]);\n"
"    } else\n"
"    if (p.z == 0 && tessOuterHi[2] > 0) {\n"
"        UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[2], tessOuterHi[2]);\n"
"        UV.y = 1.0 - UV.x;\n"
"    }\n"
"    return UV;\n"
"}\n"
"\n"
;
static const char *patchLegacyShaderSource =
"//\n"
"//   Copyright 2013-2018 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Common\n"
"//----------------------------------------------------------\n"
"\n"
"// XXXdyu all handling of varying data can be managed by client code\n"
"#ifndef OSD_USER_VARYING_DECLARE\n"
"#define OSD_USER_VARYING_DECLARE\n"
"// type var;\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_ATTRIBUTE_DECLARE\n"
"#define OSD_USER_VARYING_ATTRIBUTE_DECLARE\n"
"// layout(location = loc) in type var;\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_PER_VERTEX\n"
"#define OSD_USER_VARYING_PER_VERTEX()\n"
"// output.var = var;\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_PER_CONTROL_POINT\n"
"#define OSD_USER_VARYING_PER_CONTROL_POINT(ID_OUT, ID_IN)\n"
"// output[ID_OUT].var = input[ID_IN].var\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_PER_EVAL_POINT\n"
"#define OSD_USER_VARYING_PER_EVAL_POINT(UV, a, b, c, d)\n"
"// output.var =\n"
"//     mix(mix(input[a].var, input[b].var, UV.x),\n"
"//         mix(input[c].var, input[d].var, UV.x), UV.y)\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_PER_EVAL_POINT_TRIANGLE\n"
"#define OSD_USER_VARYING_PER_EVAL_POINT_TRIANGLE(UV, a, b, c)\n"
"// output.var =\n"
"//     input[a].var * (1.0f-UV.x-UV.y) +\n"
"//     input[b].var * UV.x +\n"
"//     input[c].var * UV.y;\n"
"#endif\n"
"\n"
"#if __VERSION__ < 420\n"
"    #define centroid\n"
"#endif\n"
"\n"
"struct ControlVertex {\n"
"    vec4 position;\n"
"#ifdef OSD_ENABLE_PATCH_CULL\n"
"    ivec3 clipFlag;\n"
"#endif\n"
"};\n"
"\n"
"// XXXdyu all downstream data can be handled by client code\n"
"struct OutputVertex {\n"
"    vec4 position;\n"
"    vec3 normal;\n"
"    vec3 tangent;\n"
"    vec3 bitangent;\n"
"    vec4 patchCoord; // u, v, faceLevel, faceId\n"
"    vec2 tessCoord; // tesscoord.st\n"
"#if defined OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    vec3 Nu;\n"
"    vec3 Nv;\n"
"#endif\n"
"};\n"
"\n"
"mat4 OsdModelViewProjectionMatrix();\n"
"int OsdGregoryQuadOffsetBase();\n"
"int OsdPrimitiveIdBase();\n"
"int OsdBaseVertex();\n"
"\n"
"#ifndef OSD_DISPLACEMENT_CALLBACK\n"
"#define OSD_DISPLACEMENT_CALLBACK\n"
"#endif\n"
"\n"
"// These are stored in OsdPatchParamBuffer indexed by the value returned\n"
"// from OsdGetPatchIndex() which is a function of the current PrimitiveID\n"
"// along with an optional client provided offset.\n"
"\n"
"uniform isamplerBuffer OsdPatchParamBuffer;\n"
"\n"
"int OsdGetPatchIndex(int primitiveId)\n"
"{\n"
"    return (primitiveId + OsdPrimitiveIdBase());\n"
"}\n"
"\n"
"ivec3 OsdGetPatchParam(int patchIndex)\n"
"{\n"
"    return texelFetch(OsdPatchParamBuffer, patchIndex).xyz;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// patch culling\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"#ifdef OSD_ENABLE_PATCH_CULL\n"
"\n"
"#define OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(P)                     "
"    vec4 clipPos = OsdModelViewProjectionMatrix() * P;          "
"    bvec3 clip0 = lessThan(clipPos.xyz, vec3(clipPos.w));       "
"    bvec3 clip1 = greaterThan(clipPos.xyz, -vec3(clipPos.w));   "
"    outpt.v.clipFlag = ivec3(clip0) + 2*ivec3(clip1);           "
"\n"
"#define OSD_PATCH_CULL(N)                            "
"    ivec3 clipFlag = ivec3(0);                       "
"    for(int i = 0; i < N; ++i) {                     "
"        clipFlag |= inpt[i].v.clipFlag;              "
"    }                                                "
"    if (clipFlag != ivec3(3) ) {                     "
"        gl_TessLevelInner[0] = 0;                    "
"        gl_TessLevelInner[1] = 0;                    "
"        gl_TessLevelOuter[0] = 0;                    "
"        gl_TessLevelOuter[1] = 0;                    "
"        gl_TessLevelOuter[2] = 0;                    "
"        gl_TessLevelOuter[3] = 0;                    "
"        return;                                      "
"    }\n"
"\n"
"#else\n"
"#define OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(P)\n"
"#define OSD_PATCH_CULL(N)\n"
"#endif\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Legacy Gregory\n"
"// ----------------------------------------------------------------------------\n"
"#if defined(OSD_PATCH_GREGORY) || defined(OSD_PATCH_GREGORY_BOUNDARY)\n"
"\n"
"#define M_PI 3.14159265359f\n"
"\n"
"// precomputed catmark coefficient table up to valence 29\n"
"uniform float OsdCatmarkCoefficient[30] = float[](\n"
"    0, 0, 0, 0.812816, 0.500000, 0.363644, 0.287514,\n"
"    0.238688, 0.204544, 0.179229, 0.159657,\n"
"    0.144042, 0.131276, 0.120632, 0.111614,\n"
"    0.103872, 0.09715, 0.0912559, 0.0860444,\n"
"    0.0814022, 0.0772401, 0.0734867, 0.0700842,\n"
"    0.0669851, 0.0641504, 0.0615475, 0.0591488,\n"
"    0.0569311, 0.0548745, 0.0529621\n"
"    );\n"
"\n"
"float\n"
"OsdComputeCatmarkCoefficient(int valence)\n"
"{\n"
"#if OSD_MAX_VALENCE < 30\n"
"    return OsdCatmarkCoefficient[valence];\n"
"#else\n"
"    if (valence < 30) {\n"
"        return OsdCatmarkCoefficient[valence];\n"
"    } else {\n"
"        float t = 2.0f * float(M_PI) / float(valence);\n"
"        return 1.0f / (valence * (cos(t) + 5.0f +\n"
"                                  sqrt((cos(t) + 9) * (cos(t) + 1)))/16.0f);\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"float cosfn(int n, int j) {\n"
"    return cos((2.0f * M_PI * j)/float(n));\n"
"}\n"
"\n"
"float sinfn(int n, int j) {\n"
"    return sin((2.0f * M_PI * j)/float(n));\n"
"}\n"
"\n"
"#if !defined OSD_MAX_VALENCE || OSD_MAX_VALENCE < 1\n"
"#undef OSD_MAX_VALENCE\n"
"#define OSD_MAX_VALENCE 4\n"
"#endif\n"
"\n"
"struct OsdPerVertexGregory {\n"
"    vec3 P;\n"
"    ivec3 clipFlag;\n"
"    int  valence;\n"
"    vec3 e0;\n"
"    vec3 e1;\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    int zerothNeighbor;\n"
"    vec3 org;\n"
"#endif\n"
"    vec3 r[OSD_MAX_VALENCE];\n"
"};\n"
"\n"
"struct OsdPerPatchVertexGregory {\n"
"    ivec3 patchParam;\n"
"    vec3 P;\n"
"    vec3 Ep;\n"
"    vec3 Em;\n"
"    vec3 Fp;\n"
"    vec3 Fm;\n"
"};\n"
"\n"
"#ifndef OSD_NUM_ELEMENTS\n"
"#define OSD_NUM_ELEMENTS 3\n"
"#endif\n"
"\n"
"uniform samplerBuffer OsdVertexBuffer;\n"
"uniform isamplerBuffer OsdValenceBuffer;\n"
"\n"
"vec3 OsdReadVertex(int vertexIndex)\n"
"{\n"
"    int index = int(OSD_NUM_ELEMENTS * (vertexIndex + OsdBaseVertex()));\n"
"    return vec3(texelFetch(OsdVertexBuffer, index).x,\n"
"                texelFetch(OsdVertexBuffer, index+1).x,\n"
"                texelFetch(OsdVertexBuffer, index+2).x);\n"
"}\n"
"\n"
"int OsdReadVertexValence(int vertexID)\n"
"{\n"
"    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1));\n"
"    return texelFetch(OsdValenceBuffer, index).x;\n"
"}\n"
"\n"
"int OsdReadVertexIndex(int vertexID, int valenceVertex)\n"
"{\n"
"    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1) + 1 + valenceVertex);\n"
"    return texelFetch(OsdValenceBuffer, index).x;\n"
"}\n"
"\n"
"uniform isamplerBuffer OsdQuadOffsetBuffer;\n"
"\n"
"int OsdReadQuadOffset(int primitiveID, int offsetVertex)\n"
"{\n"
"    int index = int(4*primitiveID+OsdGregoryQuadOffsetBase() + offsetVertex);\n"
"    return texelFetch(OsdQuadOffsetBuffer, index).x;\n"
"}\n"
"\n"
"void\n"
"OsdComputePerVertexGregory(int vID, vec3 P, out OsdPerVertexGregory v)\n"
"{\n"
"    v.clipFlag = ivec3(0);\n"
"\n"
"    int ivalence = OsdReadVertexValence(vID);\n"
"    v.valence = ivalence;\n"
"    int valence = abs(ivalence);\n"
"\n"
"    vec3 f[OSD_MAX_VALENCE];\n"
"    vec3 pos = P;\n"
"    vec3 opos = vec3(0);\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    v.org = pos;\n"
"    int boundaryEdgeNeighbors[2];\n"
"    int currNeighbor = 0;\n"
"    int ibefore = 0;\n"
"    int zerothNeighbor = 0;\n"
"#endif\n"
"\n"
"    for (int i=0; i<valence; ++i) {\n"
"        int im = (i+valence-1)%valence;\n"
"        int ip = (i+1)%valence;\n"
"\n"
"        int idx_neighbor = OsdReadVertexIndex(vID, 2*i);\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"        bool isBoundaryNeighbor = false;\n"
"        int valenceNeighbor = OsdReadVertexValence(idx_neighbor);\n"
"\n"
"        if (valenceNeighbor < 0) {\n"
"            isBoundaryNeighbor = true;\n"
"            if (currNeighbor<2) {\n"
"                boundaryEdgeNeighbors[currNeighbor] = idx_neighbor;\n"
"            }\n"
"            currNeighbor++;\n"
"            if (currNeighbor == 1) {\n"
"                ibefore = i;\n"
"                zerothNeighbor = i;\n"
"            } else {\n"
"                if (i-ibefore == 1) {\n"
"                    int tmp = boundaryEdgeNeighbors[0];\n"
"                    boundaryEdgeNeighbors[0] = boundaryEdgeNeighbors[1];\n"
"                    boundaryEdgeNeighbors[1] = tmp;\n"
"                    zerothNeighbor = i;\n"
"                }\n"
"            }\n"
"        }\n"
"#endif\n"
"\n"
"        vec3 neighbor = OsdReadVertex(idx_neighbor);\n"
"\n"
"        int idx_diagonal = OsdReadVertexIndex(vID, 2*i + 1);\n"
"        vec3 diagonal = OsdReadVertex(idx_diagonal);\n"
"\n"
"        int idx_neighbor_p = OsdReadVertexIndex(vID, 2*ip);\n"
"        vec3 neighbor_p = OsdReadVertex(idx_neighbor_p);\n"
"\n"
"        int idx_neighbor_m = OsdReadVertexIndex(vID, 2*im);\n"
"        vec3 neighbor_m = OsdReadVertex(idx_neighbor_m);\n"
"\n"
"        int idx_diagonal_m = OsdReadVertexIndex(vID, 2*im + 1);\n"
"        vec3 diagonal_m = OsdReadVertex(idx_diagonal_m);\n"
"\n"
"        f[i] = (pos * float(valence) + (neighbor_p + neighbor)*2.0f + diagonal) / (float(valence)+5.0f);\n"
"\n"
"        opos += f[i];\n"
"        v.r[i] = (neighbor_p-neighbor_m)/3.0f + (diagonal - diagonal_m)/6.0f;\n"
"    }\n"
"\n"
"    opos /= valence;\n"
"    v.P = vec4(opos, 1.0f).xyz;\n"
"\n"
"    vec3 e;\n"
"    v.e0 = vec3(0);\n"
"    v.e1 = vec3(0);\n"
"\n"
"    for(int i=0; i<valence; ++i) {\n"
"        int im = (i + valence -1) % valence;\n"
"        e = 0.5f * (f[i] + f[im]);\n"
"        v.e0 += cosfn(valence, i)*e;\n"
"        v.e1 += sinfn(valence, i)*e;\n"
"    }\n"
"    float ef = OsdComputeCatmarkCoefficient(valence);\n"
"    v.e0 *= ef;\n"
"    v.e1 *= ef;\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    v.zerothNeighbor = zerothNeighbor;\n"
"    if (currNeighbor == 1) {\n"
"        boundaryEdgeNeighbors[1] = boundaryEdgeNeighbors[0];\n"
"    }\n"
"\n"
"    if (ivalence < 0) {\n"
"        if (valence > 2) {\n"
"            v.P = (OsdReadVertex(boundaryEdgeNeighbors[0]) +\n"
"                   OsdReadVertex(boundaryEdgeNeighbors[1]) +\n"
"                   4.0f * pos)/6.0f;\n"
"        } else {\n"
"            v.P = pos;\n"
"        }\n"
"\n"
"        v.e0 = (OsdReadVertex(boundaryEdgeNeighbors[0]) -\n"
"                OsdReadVertex(boundaryEdgeNeighbors[1]))/6.0;\n"
"\n"
"        float k = float(float(valence) - 1.0f);    //k is the number of faces\n"
"        float c = cos(M_PI/k);\n"
"        float s = sin(M_PI/k);\n"
"        float gamma = -(4.0f*s)/(3.0f*k+c);\n"
"        float alpha_0k = -((1.0f+2.0f*c)*sqrt(1.0f+c))/((3.0f*k+c)*sqrt(1.0f-c));\n"
"        float beta_0 = s/(3.0f*k + c);\n"
"\n"
"        int idx_diagonal = OsdReadVertexIndex(vID, 2*zerothNeighbor + 1);\n"
"        vec3 diagonal = OsdReadVertex(idx_diagonal);\n"
"\n"
"        v.e1 = gamma * pos +\n"
"            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[0]) +\n"
"            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[1]) +\n"
"            beta_0 * diagonal;\n"
"\n"
"        for (int x=1; x<valence - 1; ++x) {\n"
"            int curri = ((x + zerothNeighbor)%valence);\n"
"            float alpha = (4.0f*sin((M_PI * float(x))/k))/(3.0f*k+c);\n"
"            float beta = (sin((M_PI * float(x))/k) + sin((M_PI * float(x+1))/k))/(3.0f*k+c);\n"
"\n"
"            int idx_neighbor = OsdReadVertexIndex(vID, 2*curri);\n"
"            vec3 neighbor = OsdReadVertex(idx_neighbor);\n"
"\n"
"            idx_diagonal = OsdReadVertexIndex(vID, 2*curri + 1);\n"
"            diagonal = OsdReadVertex(idx_diagonal);\n"
"\n"
"            v.e1 += alpha * neighbor + beta * diagonal;\n"
"        }\n"
"\n"
"        v.e1 /= 3.0f;\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"void\n"
"OsdComputePerPatchVertexGregory(ivec3 patchParam, int ID, int primitiveID,\n"
"                                in OsdPerVertexGregory v[4],\n"
"                                out OsdPerPatchVertexGregory result)\n"
"{\n"
"    result.patchParam = patchParam;\n"
"    result.P = v[ID].P;\n"
"\n"
"    int i = ID;\n"
"    int ip = (i+1)%4;\n"
"    int im = (i+3)%4;\n"
"    int valence = abs(v[i].valence);\n"
"    int n = valence;\n"
"\n"
"    int start = OsdReadQuadOffset(primitiveID, i) & 0xff;\n"
"    int prev = (OsdReadQuadOffset(primitiveID, i) >> 8) & 0xff;\n"
"\n"
"    int start_m = OsdReadQuadOffset(primitiveID, im) & 0xff;\n"
"    int prev_p = (OsdReadQuadOffset(primitiveID, ip) >> 8) & 0xff;\n"
"\n"
"    int np = abs(v[ip].valence);\n"
"    int nm = abs(v[im].valence);\n"
"\n"
"    // Control Vertices based on :\n"
"    // \"Approximating Subdivision Surfaces with Gregory Patches\n"
"    //  for Hardware Tessellation\"\n"
"    // Loop, Schaefer, Ni, Castano (ACM ToG Siggraph Asia 2009)\n"
"    //\n"
"    //  P3         e3-      e2+         P2\n"
"    //     O--------O--------O--------O\n"
"    //     |        |        |        |\n"
"    //     |        |        |        |\n"
"    //     |        | f3-    | f2+    |\n"
"    //     |        O        O        |\n"
"    // e3+ O------O            O------O e2-\n"
"    //     |     f3+          f2-     |\n"
"    //     |                          |\n"
"    //     |                          |\n"
"    //     |      f0-         f1+     |\n"
"    // e0- O------O            O------O e1+\n"
"    //     |        O        O        |\n"
"    //     |        | f0+    | f1-    |\n"
"    //     |        |        |        |\n"
"    //     |        |        |        |\n"
"    //     O--------O--------O--------O\n"
"    //  P0         e0+      e1-         P1\n"
"    //\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    vec3 Em_ip;\n"
"    if (v[ip].valence < -2) {\n"
"        int j = (np + prev_p - v[ip].zerothNeighbor) % np;\n"
"        Em_ip = v[ip].P + cos((M_PI*j)/float(np-1))*v[ip].e0 + sin((M_PI*j)/float(np-1))*v[ip].e1;\n"
"    } else {\n"
"        Em_ip = v[ip].P + v[ip].e0*cosfn(np, prev_p ) + v[ip].e1*sinfn(np, prev_p);\n"
"    }\n"
"\n"
"    vec3 Ep_im;\n"
"    if (v[im].valence < -2) {\n"
"        int j = (nm + start_m - v[im].zerothNeighbor) % nm;\n"
"        Ep_im = v[im].P + cos((M_PI*j)/float(nm-1))*v[im].e0 + sin((M_PI*j)/float(nm-1))*v[im].e1;\n"
"    } else {\n"
"        Ep_im = v[im].P + v[im].e0*cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);\n"
"    }\n"
"\n"
"    if (v[i].valence < 0) {\n"
"        n = (n-1)*2;\n"
"    }\n"
"    if (v[im].valence < 0) {\n"
"        nm = (nm-1)*2;\n"
"    }\n"
"    if (v[ip].valence < 0) {\n"
"        np = (np-1)*2;\n"
"    }\n"
"\n"
"    if (v[i].valence > 2) {\n"
"        result.Ep = v[i].P + v[i].e0*cosfn(n, start) + v[i].e1*sinfn(n, start);\n"
"        result.Em = v[i].P + v[i].e0*cosfn(n, prev ) + v[i].e1*sinfn(n, prev);\n"
"\n"
"        float s1=3-2*cosfn(n,1)-cosfn(np,1);\n"
"        float s2=2*cosfn(n,1);\n"
"\n"
"        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"        s1 = 3.0f-2.0f*cos(2.0f*M_PI/float(n))-cos(2.0f*M_PI/float(nm));\n"
"        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"\n"
"    } else if (v[i].valence < -2) {\n"
"        int j = (valence + start - v[i].zerothNeighbor) % valence;\n"
"\n"
"        result.Ep = v[i].P + cos((M_PI*j)/float(valence-1))*v[i].e0 + sin((M_PI*j)/float(valence-1))*v[i].e1;\n"
"        j = (valence + prev - v[i].zerothNeighbor) % valence;\n"
"        result.Em = v[i].P + cos((M_PI*j)/float(valence-1))*v[i].e0 + sin((M_PI*j)/float(valence-1))*v[i].e1;\n"
"\n"
"        vec3 Rp = ((-2.0f * v[i].org - 1.0f * v[im].org) + (2.0f * v[ip].org + 1.0f * v[(i+2)%4].org))/3.0f;\n"
"        vec3 Rm = ((-2.0f * v[i].org - 1.0f * v[ip].org) + (2.0f * v[im].org + 1.0f * v[(i+2)%4].org))/3.0f;\n"
"\n"
"        float s1 = 3-2*cosfn(n,1)-cosfn(np,1);\n"
"        float s2 = 2*cosfn(n,1);\n"
"\n"
"        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"        s1 = 3.0f-2.0f*cos(2.0f*M_PI/float(n))-cos(2.0f*M_PI/float(nm));\n"
"        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"\n"
"        if (v[im].valence < 0) {\n"
"            s1 = 3-2*cosfn(n,1)-cosfn(np,1);\n"
"            result.Fp = result.Fm = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"        } else if (v[ip].valence < 0) {\n"
"            s1 = 3.0f-2.0f*cos(2.0f*M_PI/n)-cos(2.0f*M_PI/nm);\n"
"            result.Fm = result.Fp = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"        }\n"
"\n"
"    } else if (v[i].valence == -2) {\n"
"        result.Ep = (2.0f * v[i].org + v[ip].org)/3.0f;\n"
"        result.Em = (2.0f * v[i].org + v[im].org)/3.0f;\n"
"        result.Fp = result.Fm = (4.0f * v[i].org + v[(i+2)%n].org + 2.0f * v[ip].org + 2.0f * v[im].org)/9.0f;\n"
"    }\n"
"\n"
"#else // not OSD_PATCH_GREGORY_BOUNDARY\n"
"\n"
"    result.Ep = v[i].P + v[i].e0 * cosfn(n, start) + v[i].e1*sinfn(n, start);\n"
"    result.Em = v[i].P + v[i].e0 * cosfn(n, prev ) + v[i].e1*sinfn(n, prev);\n"
"\n"
"    vec3 Em_ip = v[ip].P + v[ip].e0 * cosfn(np, prev_p ) + v[ip].e1*sinfn(np, prev_p);\n"
"    vec3 Ep_im = v[im].P + v[im].e0 * cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);\n"
"\n"
"    float s1 = 3-2*cosfn(n,1)-cosfn(np,1);\n"
"    float s2 = 2*cosfn(n,1);\n"
"\n"
"    result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"    s1 = 3.0f-2.0f*cos(2.0f*M_PI/float(n))-cos(2.0f*M_PI/float(nm));\n"
"    result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"#endif\n"
"}\n"
"\n"
"#endif  // OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Legacy Face-varying\n"
"// ----------------------------------------------------------------------------\n"
"uniform samplerBuffer OsdFVarDataBuffer;\n"
"\n"
"#ifndef OSD_FVAR_WIDTH\n"
"#define OSD_FVAR_WIDTH 0\n"
"#endif\n"
"\n"
"// ------ extract from quads (catmark, bilinear) ---------\n"
"// XXX: only linear interpolation is supported\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_1(result, fvarOffset, tessCoord)       "
"    {                                                                   "
"        float v[4];                                                     "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 4;          "
"        for (int i = 0; i < 4; ++i) {                                   "
"            int index = (primOffset+i)*OSD_FVAR_WIDTH + fvarOffset;     "
"            v[i] = texelFetch(OsdFVarDataBuffer, index).s               "
"        }                                                               "
"        result = mix(mix(v[0], v[1], tessCoord.s),                      "
"                     mix(v[3], v[2], tessCoord.s),                      "
"                     tessCoord.t);                                      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_2(result, fvarOffset, tessCoord)       "
"    {                                                                   "
"        vec2 v[4];                                                      "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 4;          "
"        for (int i = 0; i < 4; ++i) {                                   "
"            int index = (primOffset+i)*OSD_FVAR_WIDTH + fvarOffset;     "
"            v[i] = vec2(texelFetch(OsdFVarDataBuffer, index).s,         "
"                        texelFetch(OsdFVarDataBuffer, index + 1).s);    "
"        }                                                               "
"        result = mix(mix(v[0], v[1], tessCoord.s),                      "
"                     mix(v[3], v[2], tessCoord.s),                      "
"                     tessCoord.t);                                      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_3(result, fvarOffset, tessCoord)       "
"    {                                                                   "
"        vec3 v[4];                                                      "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 4;          "
"        for (int i = 0; i < 4; ++i) {                                   "
"            int index = (primOffset+i)*OSD_FVAR_WIDTH + fvarOffset;     "
"            v[i] = vec3(texelFetch(OsdFVarDataBuffer, index).s,         "
"                        texelFetch(OsdFVarDataBuffer, index + 1).s,     "
"                        texelFetch(OsdFVarDataBuffer, index + 2).s);    "
"        }                                                               "
"        result = mix(mix(v[0], v[1], tessCoord.s),                      "
"                     mix(v[3], v[2], tessCoord.s),                      "
"                     tessCoord.t);                                      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_4(result, fvarOffset, tessCoord)       "
"    {                                                                   "
"        vec4 v[4];                                                      "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 4;          "
"        for (int i = 0; i < 4; ++i) {                                   "
"            int index = (primOffset+i)*OSD_FVAR_WIDTH + fvarOffset;     "
"            v[i] = vec4(texelFetch(OsdFVarDataBuffer, index).s,         "
"                        texelFetch(OsdFVarDataBuffer, index + 1).s,     "
"                        texelFetch(OsdFVarDataBuffer, index + 2).s,     "
"                        texelFetch(OsdFVarDataBuffer, index + 3).s);    "
"        }                                                               "
"        result = mix(mix(v[0], v[1], tessCoord.s),                      "
"                     mix(v[3], v[2], tessCoord.s),                      "
"                     tessCoord.t);                                      "
"    }\n"
"\n"
"// ------ extract from triangles barycentric (loop) ---------\n"
"// XXX: no interpolation supported\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_TRI_1(result, fvarOffset, triVert)     "
"    {                                                                   "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 3;          "
"        int index = (primOffset+triVert)*OSD_FVAR_WIDTH + fvarOffset;   "
"        result = texelFetch(OsdFVarDataBuffer, index).s;                "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_TRI_2(result, fvarOffset, triVert)     "
"    {                                                                   "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 3;          "
"        int index = (primOffset+triVert)*OSD_FVAR_WIDTH + fvarOffset;   "
"        result = vec2(texelFetch(OsdFVarDataBuffer, index).s,           "
"                      texelFetch(OsdFVarDataBuffer, index + 1).s);      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_TRI_3(result, fvarOffset, triVert)     "
"    {                                                                   "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 3;          "
"        int index = (primOffset+triVert)*OSD_FVAR_WIDTH + fvarOffset;   "
"        result = vec3(texelFetch(OsdFVarDataBuffer, index).s,           "
"                      texelFetch(OsdFVarDataBuffer, index + 1).s,       "
"                      texelFetch(OsdFVarDataBuffer, index + 2).s);      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_TRI_4(result, fvarOffset, triVert)     "
"    {                                                                   "
"        int primOffset = OsdGetPatchIndex(gl_PrimitiveID) * 3;          "
"        int index = (primOffset+triVert)*OSD_FVAR_WIDTH + fvarOffset;   "
"        result = vec4(texelFetch(OsdFVarDataBuffer, index).s,           "
"                      texelFetch(OsdFVarDataBuffer, index + 1).s,       "
"                      texelFetch(OsdFVarDataBuffer, index + 2).s,       "
"                      texelFetch(OsdFVarDataBuffer, index + 3).s);      "
"    }\n"
"\n"
"\n"
;
static const char *patchBasisTypesShaderSource = 
"//\n"
"//   Copyright 2018 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"#ifndef OPENSUBDIV3_OSD_PATCH_BASIS_TYPES_H\n"
"#define OPENSUBDIV3_OSD_PATCH_BASIS_TYPES_H\n"
"\n"
"/// This is an implementation of the functionality from osd/types.h\n"
"/// which can be used from client shader and kernel code, i.e for\n"
"/// GLSL, HLSL, CUDA, OpenCL, Metal, and C++ shaders and kernels.\n"
"///\n"
"/// This is defined within the OpenSubdiv::Osd namespace for C++, but\n"
"/// the methods and types also have an Osd prefix for consistency with\n"
"/// environments (e.g. GLSL, etc.) where C++ namespaces are not available.\n"
"\n"
"#if !defined(OSD_PATCH_BASIS_GLSL) && "
"    !defined(OSD_PATCH_BASIS_HLSL) && "
"    !defined(OSD_PATCH_BASIS_CUDA) && "
"    !defined(OSD_PATCH_BASIS_OPENCL) && "
"    !defined(OSD_PATCH_BASIS_METAL)\n"
"\n"
"#include \"../version.h\"\n"
"\n"
"namespace OpenSubdiv {\n"
"namespace OPENSUBDIV_VERSION {\n"
"\n"
"namespace Osd {\n"
"\n"
"#endif\n"
"\n"
"#if defined(OSD_PATCH_BASIS_GLSL)\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS\n"
"    #define OSD_DATA_STORAGE_CLASS\n"
"    #define OSD_REAL float\n"
"    #define OSD_REAL_CAST float\n"
"    #define OSD_OPTIONAL(a) true\n"
"    #define OSD_OPTIONAL_INIT(a,b) b\n"
"    #define OSD_ARRAY_ARG_BOUND_OPTIONAL 0\n"
"    #define OSD_IN_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_OUT_ARRAY(elementType, identifier, arraySize) "
"            out elementType identifier[arraySize]\n"
"    #define OSD_INOUT_ARRAY(elementType, identifier, arraySize) "
"            inout elementType identifier[arraySize]\n"
"    #define OSD_ARRAY_2(elementType,a0,a1) "
"            elementType[](a0,a1)\n"
"    #define OSD_ARRAY_3(elementType,a0,a1,a2) "
"            elementType[](a0,a1,a2)\n"
"    #define OSD_ARRAY_4(elementType,a0,a1,a2,a3) "
"            elementType[](a0,a1,a2,a3)\n"
"    #define OSD_ARRAY_6(elementType,a0,a1,a2,a3,a4,a5) "
"            elementType[](a0,a1,a2,a3,a4,a5)\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            elementType[](a0,a1,a2,a3,a4,a5,a6,a7)\n"
"    #define OSD_ARRAY_9(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8) "
"            elementType[](a0,a1,a2,a3,a4,a5,a6,a7,a8)\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            elementType[](a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)\n"
"\n"
"#elif defined(OSD_PATCH_BASIS_HLSL)\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS\n"
"    #define OSD_DATA_STORAGE_CLASS\n"
"    #define OSD_REAL float\n"
"    #define OSD_REAL_CAST float\n"
"    #define OSD_OPTIONAL(a) true\n"
"    #define OSD_OPTIONAL_INIT(a,b) b\n"
"    #define OSD_ARRAY_ARG_BOUND_OPTIONAL 0\n"
"    #define OSD_IN_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_OUT_ARRAY(elementType, identifier, arraySize) "
"            out elementType identifier[arraySize]\n"
"    #define OSD_INOUT_ARRAY(elementType, identifier, arraySize) "
"            inout elementType identifier[arraySize]\n"
"    #define OSD_ARRAY_2(elementType,a0,a1) "
"            {a0,a1}\n"
"    #define OSD_ARRAY_3(elementType,a0,a1,a2) "
"            {a0,a1,a2}\n"
"    #define OSD_ARRAY_4(elementType,a0,a1,a2,a3) "
"            {a0,a1,a2,a3}\n"
"    #define OSD_ARRAY_6(elementType,a0,a1,a2,a3,a4,a5) "
"            {a0,a1,a2,a3,a4,a5}\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            {a0,a1,a2,a3,a4,a5,a6,a7}\n"
"    #define OSD_ARRAY_9(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8}\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}\n"
"\n"
"#elif defined(OSD_PATCH_BASIS_CUDA)\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS __device__\n"
"    #define OSD_DATA_STORAGE_CLASS\n"
"    #define OSD_REAL float\n"
"    #define OSD_REAL_CAST float\n"
"    #define OSD_OPTIONAL(a) true\n"
"    #define OSD_OPTIONAL_INIT(a,b) b\n"
"    #define OSD_ARRAY_ARG_BOUND_OPTIONAL 0\n"
"    #define OSD_IN_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_OUT_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_INOUT_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_ARRAY_2(elementType,a0,a1) "
"            {a0,a1}\n"
"    #define OSD_ARRAY_3(elementType,a0,a1,a2) "
"            {a0,a1,a2}\n"
"    #define OSD_ARRAY_4(elementType,a0,a1,a2,a3) "
"            {a0,a1,a2,a3}\n"
"    #define OSD_ARRAY_6(elementType,a0,a1,a2,a3,a4,a5) "
"            {a0,a1,a2,a3,a4,a5}\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            {a0,a1,a2,a3,a4,a5,a6,a7}\n"
"    #define OSD_ARRAY_9(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8}\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}\n"
"\n"
"#elif defined(OSD_PATCH_BASIS_OPENCL)\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS static\n"
"    #define OSD_DATA_STORAGE_CLASS\n"
"    #define OSD_REAL float\n"
"    #define OSD_REAL_CAST convert_float\n"
"    #define OSD_OPTIONAL(a) true\n"
"    #define OSD_OPTIONAL_INIT(a,b) b\n"
"    #define OSD_ARRAY_ARG_BOUND_OPTIONAL 0\n"
"    #define OSD_IN_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_OUT_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_INOUT_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_ARRAY_2(elementType,a0,a1) "
"            {a0,a1}\n"
"    #define OSD_ARRAY_3(elementType,a0,a1,a2) "
"            {a0,a1,a2}\n"
"    #define OSD_ARRAY_4(elementType,a0,a1,a2,a3) "
"            {a0,a1,a2,a3}\n"
"    #define OSD_ARRAY_6(elementType,a0,a1,a2,a3,a4,a5) "
"            {a0,a1,a2,a3,a4,a5}\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            {a0,a1,a2,a3,a4,a5,a6,a7}\n"
"    #define OSD_ARRAY_9(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8}\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}\n"
"\n"
"#elif defined(OSD_PATCH_BASIS_METAL)\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS\n"
"    #define OSD_DATA_STORAGE_CLASS\n"
"    #define OSD_REAL float\n"
"    #define OSD_REAL_CAST float\n"
"    #define OSD_OPTIONAL(a) true\n"
"    #define OSD_OPTIONAL_INIT(a,b) b\n"
"    #define OSD_ARRAY_ARG_BOUND_OPTIONAL 0\n"
"    #define OSD_IN_ARRAY(elementType, identifier, arraySize) "
"            thread elementType* identifier\n"
"    #define OSD_OUT_ARRAY(elementType, identifier, arraySize) "
"            thread elementType* identifier\n"
"    #define OSD_INOUT_ARRAY(elementType, identifier, arraySize) "
"            thread elementType* identifier\n"
"    #define OSD_ARRAY_2(elementType,a0,a1) "
"            {a0,a1}\n"
"    #define OSD_ARRAY_3(elementType,a0,a1,a2) "
"            {a0,a1,a2}\n"
"    #define OSD_ARRAY_4(elementType,a0,a1,a2,a3) "
"            {a0,a1,a2,a3}\n"
"    #define OSD_ARRAY_6(elementType,a0,a1,a2,a3,a4,a5) "
"            {a0,a1,a2,a3,a4,a5}\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            {a0,a1,a2,a3,a4,a5,a6,a7}\n"
"    #define OSD_ARRAY_9(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8}\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}\n"
"\n"
"#else\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS static inline\n"
"    #define OSD_DATA_STORAGE_CLASS static\n"
"    #define OSD_REAL float\n"
"    #define OSD_REAL_CAST float\n"
"    #define OSD_OPTIONAL(a) (a)\n"
"    #define OSD_OPTIONAL_INIT(a,b) (a ? b : 0)\n"
"    #define OSD_ARRAY_ARG_BOUND_OPTIONAL 1\n"
"    #define OSD_IN_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_OUT_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_INOUT_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_ARRAY_2(elementType,a0,a1) "
"            {a0,a1}\n"
"    #define OSD_ARRAY_3(elementType,a0,a1,a2) "
"            {a0,a1,a2}\n"
"    #define OSD_ARRAY_4(elementType,a0,a1,a2,a3) "
"            {a0,a1,a2,a3}\n"
"    #define OSD_ARRAY_6(elementType,a0,a1,a2,a3,a4,a5) "
"            {a0,a1,a2,a3,a4,a5}\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            {a0,a1,a2,a3,a4,a5,a6,a7}\n"
"    #define OSD_ARRAY_9(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8}\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}\n"
"\n"
"#endif\n"
"\n"
"#if defined(OSD_PATCH_BASIS_OPENCL)\n"
"// OpenCL binding uses typedef to provide the required \"struct\" type specifier.\n"
"typedef struct OsdPatchParam OsdPatchParam;\n"
"typedef struct OsdPatchArray OsdPatchArray;\n"
"typedef struct OsdPatchCoord OsdPatchCoord;\n"
"#endif\n"
"\n"
"// Osd reflection of Far::PatchDescriptor\n"
"#define OSD_PATCH_DESCRIPTOR_QUADS            3\n"
"#define OSD_PATCH_DESCRIPTOR_TRIANGLES        4\n"
"#define OSD_PATCH_DESCRIPTOR_LOOP             5\n"
"#define OSD_PATCH_DESCRIPTOR_REGULAR          6\n"
"#define OSD_PATCH_DESCRIPTOR_GREGORY_BASIS    9\n"
"#define OSD_PATCH_DESCRIPTOR_GREGORY_TRIANGLE 10\n"
"\n"
"// Osd reflection of Osd::PatchCoord\n"
"struct OsdPatchCoord {\n"
"   int arrayIndex;\n"
"   int patchIndex;\n"
"   int vertIndex;\n"
"   float s;\n"
"   float t;\n"
"};\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"OsdPatchCoord\n"
"OsdPatchCoordInit(\n"
"    int arrayIndex, int patchIndex, int vertIndex, float s, float t)\n"
"{\n"
"    OsdPatchCoord coord;\n"
"    coord.arrayIndex = arrayIndex;\n"
"    coord.patchIndex = patchIndex;\n"
"    coord.vertIndex = vertIndex;\n"
"    coord.s = s;\n"
"    coord.t = t;\n"
"    return coord;\n"
"}\n"
"\n"
"// Osd reflection of Osd::PatchArray\n"
"struct OsdPatchArray {\n"
"    int regDesc;\n"
"    int desc;\n"
"    int numPatches;\n"
"    int indexBase;\n"
"    int stride;\n"
"    int primitiveIdBase;\n"
"};\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"OsdPatchArray\n"
"OsdPatchArrayInit(\n"
"    int regDesc, int desc,\n"
"    int numPatches, int indexBase, int stride, int primitiveIdBase)\n"
"{\n"
"    OsdPatchArray array;\n"
"    array.regDesc = regDesc;\n"
"    array.desc = desc;\n"
"    array.numPatches = numPatches;\n"
"    array.indexBase = indexBase;\n"
"    array.stride = stride;\n"
"    array.primitiveIdBase = primitiveIdBase;\n"
"    return array;\n"
"}\n"
"\n"
"// Osd reflection of Osd::PatchParam\n"
"struct OsdPatchParam {\n"
"    int field0;\n"
"    int field1;\n"
"    float sharpness;\n"
"};\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"OsdPatchParam\n"
"OsdPatchParamInit(int field0, int field1, float sharpness)\n"
"{\n"
"    OsdPatchParam param;\n"
"    param.field0 = field0;\n"
"    param.field1 = field1;\n"
"    param.sharpness = sharpness;\n"
"    return param;\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"OsdPatchParamGetFaceId(OsdPatchParam param)\n"
"{\n"
"    return (param.field0 & 0xfffffff);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"OsdPatchParamGetU(OsdPatchParam param)\n"
"{\n"
"    return ((param.field1 >> 22) & 0x3ff);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"OsdPatchParamGetV(OsdPatchParam param)\n"
"{\n"
"    return ((param.field1 >> 12) & 0x3ff);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"OsdPatchParamGetTransition(OsdPatchParam param)\n"
"{\n"
"    return ((param.field0 >> 28) & 0xf);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"OsdPatchParamGetBoundary(OsdPatchParam param)\n"
"{\n"
"    return ((param.field1 >> 7) & 0x1f);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"OsdPatchParamGetNonQuadRoot(OsdPatchParam param)\n"
"{\n"
"    return ((param.field1 >> 4) & 0x1);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"OsdPatchParamGetDepth(OsdPatchParam param)\n"
"{\n"
"    return (param.field1 & 0xf);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"OSD_REAL\n"
"OsdPatchParamGetParamFraction(OsdPatchParam param)\n"
"{\n"
"    return 1.0f / OSD_REAL_CAST(1 <<\n"
"        (OsdPatchParamGetDepth(param) - OsdPatchParamGetNonQuadRoot(param)));\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"bool\n"
"OsdPatchParamIsRegular(OsdPatchParam param)\n"
"{\n"
"    return (((param.field1 >> 5) & 0x1) != 0);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"bool\n"
"OsdPatchParamIsTriangleRotated(OsdPatchParam param)\n"
"{\n"
"    return ((OsdPatchParamGetU(param) + OsdPatchParamGetV(param)) >=\n"
"            (1 << OsdPatchParamGetDepth(param)));\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdPatchParamNormalize(\n"
"        OsdPatchParam param,\n"
"        OSD_INOUT_ARRAY(OSD_REAL, uv, 2))\n"
"{\n"
"    OSD_REAL fracInv = 1.0f / OsdPatchParamGetParamFraction(param);\n"
"\n"
"    uv[0] = uv[0] * fracInv - OSD_REAL_CAST(OsdPatchParamGetU(param));\n"
"    uv[1] = uv[1] * fracInv - OSD_REAL_CAST(OsdPatchParamGetV(param));\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdPatchParamUnnormalize(\n"
"        OsdPatchParam param,\n"
"        OSD_INOUT_ARRAY(OSD_REAL, uv, 2))\n"
"{\n"
"    OSD_REAL frac = OsdPatchParamGetParamFraction(param);\n"
"\n"
"    uv[0] = (uv[0] + OSD_REAL_CAST(OsdPatchParamGetU(param))) * frac;\n"
"    uv[1] = (uv[1] + OSD_REAL_CAST(OsdPatchParamGetV(param))) * frac;\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdPatchParamNormalizeTriangle(\n"
"        OsdPatchParam param,\n"
"        OSD_INOUT_ARRAY(OSD_REAL, uv, 2))\n"
"{\n"
"    if (OsdPatchParamIsTriangleRotated(param)) {\n"
"        OSD_REAL fracInv = 1.0f / OsdPatchParamGetParamFraction(param);\n"
"\n"
"        int depthFactor = 1 << OsdPatchParamGetDepth(param);\n"
"        uv[0] = OSD_REAL_CAST(depthFactor - OsdPatchParamGetU(param)) - (uv[0] * fracInv);\n"
"        uv[1] = OSD_REAL_CAST(depthFactor - OsdPatchParamGetV(param)) - (uv[1] * fracInv);\n"
"    } else {\n"
"        OsdPatchParamNormalize(param, uv);\n"
"    }\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdPatchParamUnnormalizeTriangle(\n"
"        OsdPatchParam param,\n"
"        OSD_INOUT_ARRAY(OSD_REAL, uv, 2))\n"
"{\n"
"    if (OsdPatchParamIsTriangleRotated(param)) {\n"
"        OSD_REAL frac = OsdPatchParamGetParamFraction(param);\n"
"\n"
"        int depthFactor = 1 << OsdPatchParamGetDepth(param);\n"
"        uv[0] = (OSD_REAL_CAST(depthFactor - OsdPatchParamGetU(param)) - uv[0]) * frac;\n"
"        uv[1] = (OSD_REAL_CAST(depthFactor - OsdPatchParamGetV(param)) - uv[1]) * frac;\n"
"    } else {\n"
"        OsdPatchParamUnnormalize(param, uv);\n"
"    }\n"
"}\n"
"\n"
"#if !defined(OSD_PATCH_BASIS_GLSL) && "
"    !defined(OSD_PATCH_BASIS_HLSL) && "
"    !defined(OSD_PATCH_BASIS_CUDA) && "
"    !defined(OSD_PATCH_BASIS_OPENCL) && "
"    !defined(OSD_PATCH_BASIS_METAL)\n"
"\n"
"}  // end namespace Osd\n"
"\n"
"}  // end namespace OPENSUBDIV_VERSION\n"
"using namespace OPENSUBDIV_VERSION;\n"
"\n"
"}  // end namespace OpenSubdiv\n"
"\n"
"#endif\n"
"\n"
"#endif /* OPENSUBDIV3_OSD_PATCH_BASIS_TYPES_H */\n"
"\n"
;
static const char *patchBasisShaderSource = 
"//\n"
"//   Copyright 2016-2018 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"#ifndef OPENSUBDIV3_OSD_PATCH_BASIS_H\n"
"#define OPENSUBDIV3_OSD_PATCH_BASIS_H\n"
"\n"
"/// This is an implementation of the functionality from far/patchBasis.h\n"
"/// which can be used from client shader and kernel code, i.e for\n"
"/// GLSL, HLSL, CUDA, OpenCL, Metal, and C++ shaders and kernels.\n"
"///\n"
"/// This is defined within the OpenSubdiv::Osd namespace for C++, but\n"
"/// the methods and types also have an Osd prefix for consistency with\n"
"/// environments (e.g. GLSL, etc.) where C++ namespaces are not available.\n"
"\n"
"#if !defined(OSD_PATCH_BASIS_GLSL) && "
"    !defined(OSD_PATCH_BASIS_HLSL) && "
"    !defined(OSD_PATCH_BASIS_CUDA) && "
"    !defined(OSD_PATCH_BASIS_OPENCL) && "
"    !defined(OSD_PATCH_BASIS_METAL)\n"
"\n"
"#include \"../version.h\"\n"
"\n"
"#include \"../osd/patchBasisTypes.h\"\n"
"\n"
"namespace OpenSubdiv {\n"
"namespace OPENSUBDIV_VERSION {\n"
"\n"
"namespace Osd {\n"
"\n"
"#endif\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"Osd_EvalBasisLinear(OSD_REAL s, OSD_REAL t,\n"
"        OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDs, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDt, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDss, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDst, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDtt, 4)) {\n"
"\n"
"    OSD_REAL sC = 1.0f - s;\n"
"    OSD_REAL tC = 1.0f - t;\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        wP[0] = sC * tC;\n"
"        wP[1] =  s * tC;\n"
"        wP[2] =  s * t;\n"
"        wP[3] = sC * t;\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        wDs[0] = -tC;\n"
"        wDs[1] =  tC;\n"
"        wDs[2] =   t;\n"
"        wDs[3] =  -t;\n"
"\n"
"        wDt[0] = -sC;\n"
"        wDt[1] =  -s;\n"
"        wDt[2] =   s;\n"
"        wDt[3] =  sC;\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            for(int i = 0; i < 4; ++i) {\n"
"                wDss[i] = 0.0f;\n"
"                wDtt[i] = 0.0f;\n"
"            }\n"
"\n"
"            wDst[0] =  1.0f;\n"
"            wDst[1] = -1.0f;\n"
"            wDst[2] =  1.0f;\n"
"            wDst[3] = -1.0f;\n"
"        }\n"
"    }\n"
"    return 4;\n"
"}\n"
"\n"
"// namespace {\n"
"    //\n"
"    //  Cubic BSpline curve basis evaluation:\n"
"    //\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_evalBSplineCurve(OSD_REAL t,\n"
"        OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDP2, 4)) {\n"
"\n"
"        const OSD_REAL one6th = OSD_REAL_CAST(1.0f / 6.0f);\n"
"\n"
"        OSD_REAL t2 = t * t;\n"
"        OSD_REAL t3 = t * t2;\n"
"\n"
"        wP[0] = one6th * (1.0f - 3.0f*(t -      t2) -      t3);\n"
"        wP[1] = one6th * (4.0f           - 6.0f*t2  + 3.0f*t3);\n"
"        wP[2] = one6th * (1.0f + 3.0f*(t +      t2  -      t3));\n"
"        wP[3] = one6th * (                                 t3);\n"
"\n"
"        if (OSD_OPTIONAL(wDP)) {\n"
"            wDP[0] = -0.5f*t2 +      t - 0.5f;\n"
"            wDP[1] =  1.5f*t2 - 2.0f*t;\n"
"            wDP[2] = -1.5f*t2 +      t + 0.5f;\n"
"            wDP[3] =  0.5f*t2;\n"
"        }\n"
"        if (OSD_OPTIONAL(wDP2)) {\n"
"            wDP2[0] = -       t + 1.0f;\n"
"            wDP2[1] =  3.0f * t - 2.0f;\n"
"            wDP2[2] = -3.0f * t + 1.0f;\n"
"            wDP2[3] =         t;\n"
"        }\n"
"    }\n"
"\n"
"    //\n"
"    //  Weight adjustments to account for phantom end points:\n"
"    //\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_adjustBSplineBoundaryWeights(\n"
"            int boundary,\n"
"            OSD_INOUT_ARRAY(OSD_REAL, w, 16)) {\n"
"\n"
"        if ((boundary & 1) != 0) {\n"
"            for (int i = 0; i < 4; ++i) {\n"
"                w[i + 8] -= w[i + 0];\n"
"                w[i + 4] += w[i + 0] * 2.0f;\n"
"                w[i + 0]  = 0.0f;\n"
"            }\n"
"        }\n"
"        if ((boundary & 2) != 0) {\n"
"            for (int i = 0; i < 16; i += 4) {\n"
"                w[i + 1] -= w[i + 3];\n"
"                w[i + 2] += w[i + 3] * 2.0f;\n"
"                w[i + 3]  = 0.0f;\n"
"            }\n"
"        }\n"
"        if ((boundary & 4) != 0) {\n"
"            for (int i = 0; i < 4; ++i) {\n"
"                w[i +  4] -= w[i + 12];\n"
"                w[i +  8] += w[i + 12] * 2.0f;\n"
"                w[i + 12]  = 0.0f;\n"
"            }\n"
"        }\n"
"        if ((boundary & 8) != 0) {\n"
"            for (int i = 0; i < 16; i += 4) {\n"
"                w[i + 2] -= w[i + 0];\n"
"                w[i + 1] += w[i + 0] * 2.0f;\n"
"                w[i + 0]  = 0.0f;\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_boundBasisBSpline(\n"
"            int boundary,\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wP, 16),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDs, 16),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDt, 16),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDss, 16),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDst, 16),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDtt, 16)) {\n"
"\n"
"        if (OSD_OPTIONAL(wP)) {\n"
"            Osd_adjustBSplineBoundaryWeights(boundary, wP);\n"
"        }\n"
"        if (OSD_OPTIONAL(wDs && wDt)) {\n"
"            Osd_adjustBSplineBoundaryWeights(boundary, wDs);\n"
"            Osd_adjustBSplineBoundaryWeights(boundary, wDt);\n"
"\n"
"            if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"                Osd_adjustBSplineBoundaryWeights(boundary, wDss);\n"
"                Osd_adjustBSplineBoundaryWeights(boundary, wDst);\n"
"                Osd_adjustBSplineBoundaryWeights(boundary, wDtt);\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"// } // end namespace\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"Osd_EvalBasisBSpline(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 16)) {\n"
"\n"
"    OSD_REAL sWeights[4], tWeights[4], dsWeights[4], dtWeights[4], dssWeights[4], dttWeights[4];\n"
"\n"
"    Osd_evalBSplineCurve(s, sWeights, OSD_OPTIONAL_INIT(wDs, dsWeights), OSD_OPTIONAL_INIT(wDss, dssWeights));\n"
"    Osd_evalBSplineCurve(t, tWeights, OSD_OPTIONAL_INIT(wDt, dtWeights), OSD_OPTIONAL_INIT(wDtt, dttWeights));\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wP[4*i+j] = sWeights[j] * tWeights[i];\n"
"            }\n"
"        }\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wDs[4*i+j] = dsWeights[j] * tWeights[i];\n"
"                wDt[4*i+j] = sWeights[j] * dtWeights[i];\n"
"            }\n"
"        }\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            for (int i = 0; i < 4; ++i) {\n"
"                for (int j = 0; j < 4; ++j) {\n"
"                    wDss[4*i+j] = dssWeights[j] * tWeights[i];\n"
"                    wDst[4*i+j] = dsWeights[j] * dtWeights[i];\n"
"                    wDtt[4*i+j] = sWeights[j] * dttWeights[i];\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"    return 16;\n"
"}\n"
"\n"
"// namespace {\n"
"    //\n"
"    //  Cubic Bezier curve basis evaluation:\n"
"    //\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_evalBezierCurve(\n"
"        OSD_REAL t,\n"
"        OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDP2, 4)) {\n"
"\n"
"        // The four uniform cubic Bezier basis functions (in terms of t and its\n"
"        // complement tC) evaluated at t:\n"
"        OSD_REAL t2 = t*t;\n"
"        OSD_REAL tC = 1.0f - t;\n"
"        OSD_REAL tC2 = tC * tC;\n"
"\n"
"        wP[0] = tC2 * tC;\n"
"        wP[1] = tC2 * t * 3.0f;\n"
"        wP[2] = t2 * tC * 3.0f;\n"
"        wP[3] = t2 * t;\n"
"\n"
"        // Derivatives of the above four basis functions at t:\n"
"        if (OSD_OPTIONAL(wDP)) {\n"
"           wDP[0] = -3.0f * tC2;\n"
"           wDP[1] =  9.0f * t2 - 12.0f * t + 3.0f;\n"
"           wDP[2] = -9.0f * t2 +  6.0f * t;\n"
"           wDP[3] =  3.0f * t2;\n"
"        }\n"
"\n"
"        // Second derivatives of the basis functions at t:\n"
"        if (OSD_OPTIONAL(wDP2)) {\n"
"            wDP2[0] =   6.0f * tC;\n"
"            wDP2[1] =  18.0f * t - 12.0f;\n"
"            wDP2[2] = -18.0f * t +  6.0f;\n"
"            wDP2[3] =   6.0f * t;\n"
"        }\n"
"    }\n"
"// } // end namespace\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"Osd_EvalBasisBezier(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 16)) {\n"
"\n"
"    OSD_REAL sWeights[4], tWeights[4], dsWeights[4], dtWeights[4], dssWeights[4], dttWeights[4];\n"
"\n"
"    Osd_evalBezierCurve(s, OSD_OPTIONAL_INIT(wP, sWeights), OSD_OPTIONAL_INIT(wDs, dsWeights), OSD_OPTIONAL_INIT(wDss, dssWeights));\n"
"    Osd_evalBezierCurve(t, OSD_OPTIONAL_INIT(wP, tWeights), OSD_OPTIONAL_INIT(wDt, dtWeights), OSD_OPTIONAL_INIT(wDtt, dttWeights));\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wP[4*i+j] = sWeights[j] * tWeights[i];\n"
"            }\n"
"        }\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wDs[4*i+j] = dsWeights[j] * tWeights[i];\n"
"                wDt[4*i+j] = sWeights[j] * dtWeights[i];\n"
"            }\n"
"        }\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            for (int i = 0; i < 4; ++i) {\n"
"                for (int j = 0; j < 4; ++j) {\n"
"                    wDss[4*i+j] = dssWeights[j] * tWeights[i];\n"
"                    wDst[4*i+j] = dsWeights[j] * dtWeights[i];\n"
"                    wDtt[4*i+j] = sWeights[j] * dttWeights[i];\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"    return 16;\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"Osd_EvalBasisGregory(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 20)) {\n"
"\n"
"    //  Indices of boundary and interior points and their corresponding Bezier points\n"
"    //  (this can be reduced with more direct indexing and unrolling of loops):\n"
"    //\n"
"    OSD_DATA_STORAGE_CLASS const int boundaryGregory[12] = OSD_ARRAY_12(int, 0, 1, 7, 5, 2, 6, 16, 12, 15, 17, 11, 10 );\n"
"    OSD_DATA_STORAGE_CLASS const int boundaryBezSCol[12] = OSD_ARRAY_12(int, 0, 1, 2, 3, 0, 3,  0,  3,  0,  1,  2,  3 );\n"
"    OSD_DATA_STORAGE_CLASS const int boundaryBezTRow[12] = OSD_ARRAY_12(int, 0, 0, 0, 0, 1, 1,  2,  2,  3,  3,  3,  3 );\n"
"\n"
"    OSD_DATA_STORAGE_CLASS const int interiorGregory[8] = OSD_ARRAY_8(int, 3, 4,  8, 9,  13, 14,  18, 19 );\n"
"    OSD_DATA_STORAGE_CLASS const int interiorBezSCol[8] = OSD_ARRAY_8(int, 1, 1,  2, 2,   2,  2,   1,  1 );\n"
"    OSD_DATA_STORAGE_CLASS const int interiorBezTRow[8] = OSD_ARRAY_8(int, 1, 1,  1, 1,   2,  2,   2,  2 );\n"
"\n"
"    //\n"
"    //  Bezier basis functions are denoted with B while the rational multipliers for the\n"
"    //  interior points will be denoted G -- so we have B(s), B(t) and G(s,t):\n"
"    //\n"
"    //  Directional Bezier basis functions B at s and t:\n"
"    OSD_REAL Bs[4], Bds[4], Bdss[4];\n"
"    OSD_REAL Bt[4], Bdt[4], Bdtt[4];\n"
"\n"
"    Osd_evalBezierCurve(s, Bs, OSD_OPTIONAL_INIT(wDs, Bds), OSD_OPTIONAL_INIT(wDss, Bdss));\n"
"    Osd_evalBezierCurve(t, Bt, OSD_OPTIONAL_INIT(wDt, Bdt), OSD_OPTIONAL_INIT(wDtt, Bdtt));\n"
"\n"
"    //  Rational multipliers G at s and t:\n"
"    OSD_REAL sC = 1.0f - s;\n"
"    OSD_REAL tC = 1.0f - t;\n"
"\n"
"    //  Use <= here to avoid compiler warnings -- the sums should always be non-negative:\n"
"    OSD_REAL df0 = s  + t;   df0 = (df0 <= 0.0f) ? 1.0f : (1.0f / df0);\n"
"    OSD_REAL df1 = sC + t;   df1 = (df1 <= 0.0f) ? 1.0f : (1.0f / df1);\n"
"    OSD_REAL df2 = sC + tC;  df2 = (df2 <= 0.0f) ? 1.0f : (1.0f / df2);\n"
"    OSD_REAL df3 = s  + tC;  df3 = (df3 <= 0.0f) ? 1.0f : (1.0f / df3);\n"
"\n"
"    //  Make sure the G[i] for pairs of interior points sum to 1 in all cases:\n"
"    OSD_REAL G[8] = OSD_ARRAY_8(OSD_REAL,  s*df0, (1.0f -  s*df0),\n"
"                                           t*df1, (1.0f -  t*df1),\n"
"                                          sC*df2, (1.0f - sC*df2),\n"
"                                          tC*df3, (1.0f - tC*df3) );\n"
"\n"
"    //  Combined weights for boundary and interior points:\n"
"    for (int i = 0; i < 12; ++i) {\n"
"        wP[boundaryGregory[i]] = Bs[boundaryBezSCol[i]] * Bt[boundaryBezTRow[i]];\n"
"    }\n"
"    for (int j = 0; j < 8; ++j) {\n"
"        wP[interiorGregory[j]] = Bs[interiorBezSCol[j]] * Bt[interiorBezTRow[j]] * G[j];\n"
"    }\n"
"\n"
"    //\n"
"    //  For derivatives, the basis functions for the interior points are rational and ideally\n"
"    //  require appropriate differentiation, i.e. product rule for the combination of B and G\n"
"    //  and the quotient rule for the rational G itself.  As initially proposed by Loop et al\n"
"    //  though, the approximation using the 16 Bezier points arising from the G(s,t) has\n"
"    //  proved adequate (and is what the GPU shaders use) so we continue to use that here.\n"
"    //\n"
"    //  An implementation of the true derivatives is provided and conditionally compiled for\n"
"    //  those that require it, e.g.:\n"
"    //\n"
"    //    dclyde's note: skipping half of the product rule like this does seem to change the\n"
"    //    result a lot in my tests.  This is not a runtime bottleneck for cloth sims anyway\n"
"    //    so I'm just using the accurate version.\n"
"    //\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        bool find_second_partials = OSD_OPTIONAL(wDs && wDst && wDtt);\n"
"\n"
"        //  Combined weights for boundary points -- simple tensor products:\n"
"        for (int i = 0; i < 12; ++i) {\n"
"            int iDst = boundaryGregory[i];\n"
"            int tRow = boundaryBezTRow[i];\n"
"            int sCol = boundaryBezSCol[i];\n"
"\n"
"            wDs[iDst] = Bds[sCol] * Bt[tRow];\n"
"            wDt[iDst] = Bdt[tRow] * Bs[sCol];\n"
"\n"
"            if (find_second_partials) {\n"
"                wDss[iDst] = Bdss[sCol] * Bt[tRow];\n"
"                wDst[iDst] = Bds[sCol] * Bdt[tRow];\n"
"                wDtt[iDst] = Bs[sCol] * Bdtt[tRow];\n"
"            }\n"
"        }\n"
"\n"
"#ifndef OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES\n"
"        //  Approximation to the true Gregory derivatives by differentiating the Bezier patch\n"
"        //  unique to the given (s,t), i.e. having F = (g^+ * f^+) + (g^- * f^-) as its four\n"
"        //  interior points:\n"
"        //\n"
"        //  Combined weights for interior points -- tensor products with G+ or G-:\n"
"        for (int j = 0; j < 8; ++j) {\n"
"            int iDst = interiorGregory[j];\n"
"            int tRow = interiorBezTRow[j];\n"
"            int sCol = interiorBezSCol[j];\n"
"\n"
"            wDs[iDst] = Bds[sCol] * Bt[tRow] * G[j];\n"
"            wDt[iDst] = Bdt[tRow] * Bs[sCol] * G[j];\n"
"\n"
"            if (find_second_partials) {\n"
"                wDss[iDst] = Bdss[sCol] * Bt[tRow] * G[j];\n"
"                wDst[iDst] = Bds[sCol] * Bdt[tRow] * G[j];\n"
"                wDtt[iDst] = Bs[sCol] * Bdtt[tRow] * G[j];\n"
"            }\n"
"        }\n"
"#else\n"
"        //  True Gregory derivatives using appropriate differentiation of composite functions:\n"
"        //\n"
"        //  Note that for G(s,t) = N(s,t) / D(s,t), all N' and D' are trivial constants (which\n"
"        //  simplifies things for higher order derivatives).  And while each pair of functions\n"
"        //  G (i.e. the G+ and G- corresponding to points f+ and f-) must sum to 1 to ensure\n"
"        //  Bezier equivalence (when f+ = f-), the pairs of G' must similarly sum to 0.  So we\n"
"        //  can potentially compute only one of the pair and negate the result for the other\n"
"        //  (and with 4 or 8 computations involving these constants, this is all very SIMD\n"
"        //  friendly...) but for now we treat all 8 independently for simplicity.\n"
"        //\n"
"        //float N[8] = OSD_ARRAY_8(float,    s,     t,      t,     sC,      sC,     tC,      tC,     s );\n"
"        OSD_REAL D[8] = OSD_ARRAY_8(OSD_REAL,  df0,   df0,    df1,    df1,     df2,    df2,     df3,   df3 );\n"
"\n"
"        OSD_DATA_STORAGE_CLASS const OSD_REAL Nds[8] = OSD_ARRAY_8(OSD_REAL, 1.0f, 0.0f,  0.0f, -1.0f, -1.0f,  0.0f,  0.0f,  1.0f );\n"
"        OSD_DATA_STORAGE_CLASS const OSD_REAL Ndt[8] = OSD_ARRAY_8(OSD_REAL, 0.0f, 1.0f,  1.0f,  0.0f,  0.0f, -1.0f, -1.0f,  0.0f );\n"
"\n"
"        OSD_DATA_STORAGE_CLASS const OSD_REAL Dds[8] = OSD_ARRAY_8(OSD_REAL, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f );\n"
"        OSD_DATA_STORAGE_CLASS const OSD_REAL Ddt[8] = OSD_ARRAY_8(OSD_REAL, 1.0f, 1.0f,  1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f );\n"
"        //  Combined weights for interior points -- (scaled) combinations of B, B', G and G':\n"
"        for (int k = 0; k < 8; ++k) {\n"
"            int iDst = interiorGregory[k];\n"
"            int tRow = interiorBezTRow[k];\n"
"            int sCol = interiorBezSCol[k];\n"
"\n"
"            //  Quotient rule for G' (re-expressed in terms of G to simplify (and D = 1/D)):\n"
"            OSD_REAL Gds = (Nds[k] - Dds[k] * G[k]) * D[k];\n"
"            OSD_REAL Gdt = (Ndt[k] - Ddt[k] * G[k]) * D[k];\n"
"\n"
"            //  Product rule combining B and B' with G and G':\n"
"            wDs[iDst] = (Bds[sCol] * G[k] + Bs[sCol] * Gds) * Bt[tRow];\n"
"            wDt[iDst] = (Bdt[tRow] * G[k] + Bt[tRow] * Gdt) * Bs[sCol];\n"
"\n"
"            if (find_second_partials) {\n"
"                OSD_REAL Dsqr_inv = D[k]*D[k];\n"
"\n"
"                OSD_REAL Gdss = 2.0f * Dds[k] * Dsqr_inv * (G[k] * Dds[k] - Nds[k]);\n"
"                OSD_REAL Gdst = Dsqr_inv * (2.0f * G[k] * Dds[k] * Ddt[k] - Nds[k] * Ddt[k] - Ndt[k] * Dds[k]);\n"
"                OSD_REAL Gdtt = 2.0f * Ddt[k] * Dsqr_inv * (G[k] * Ddt[k] - Ndt[k]);\n"
"\n"
"                wDss[iDst] = (Bdss[sCol] * G[k] + 2.0f * Bds[sCol] * Gds + Bs[sCol] * Gdss) * Bt[tRow];\n"
"                wDst[iDst] =  Bt[tRow] * (Bs[sCol] * Gdst + Bds[sCol] * Gdt) +\n"
"                             Bdt[tRow] * (Bds[sCol] * G[k] + Bs[sCol] * Gds);\n"
"                wDtt[iDst] = (Bdtt[tRow] * G[k] + 2.0f * Bdt[tRow] * Gdt + Bt[tRow] * Gdtt) * Bs[sCol];\n"
"            }\n"
"        }\n"
"#endif\n"
"    }\n"
"    return 20;\n"
"}\n"
"\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"Osd_EvalBasisLinearTri(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 3),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 3),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 3),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 3),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 3),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 3)) {\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        wP[0] = 1.0f - s - t;\n"
"        wP[1] = s;\n"
"        wP[2] = t;\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        wDs[0] = -1.0f;\n"
"        wDs[1] =  1.0f;\n"
"        wDs[2] =  0.0f;\n"
"\n"
"        wDt[0] = -1.0f;\n"
"        wDt[1] =  0.0f;\n"
"        wDt[2] =  1.0f;\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            wDss[0] = wDss[1] = wDss[2] = 0.0f;\n"
"            wDst[0] = wDst[1] = wDst[2] = 0.0f;\n"
"            wDtt[0] = wDtt[1] = wDtt[2] = 0.0f;\n"
"        }\n"
"    }\n"
"    return 3;\n"
"}\n"
"\n"
"\n"
"// namespace {\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_evalBivariateMonomialsQuartic(\n"
"        OSD_REAL s, OSD_REAL t,\n"
"        OSD_OUT_ARRAY(OSD_REAL, M, 15)) {\n"
"\n"
"        M[0] = 1.0;\n"
"\n"
"        M[1] = s;\n"
"        M[2] = t;\n"
"\n"
"        M[3] = s * s;\n"
"        M[4] = s * t;\n"
"        M[5] = t * t;\n"
"\n"
"        M[6] = M[3] * s;\n"
"        M[7] = M[4] * s;\n"
"        M[8] = M[4] * t;\n"
"        M[9] = M[5] * t;\n"
"\n"
"        M[10] = M[6] * s;\n"
"        M[11] = M[7] * s;\n"
"        M[12] = M[3] * M[5];\n"
"        M[13] = M[8] * t;\n"
"        M[14] = M[9] * t;\n"
"    }\n"
"\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_evalBoxSplineTriDerivWeights(\n"
"        OSD_INOUT_ARRAY(OSD_REAL, /*stMonomials*/M, 15),\n"
"        int ds, int dt,\n"
"        OSD_OUT_ARRAY(OSD_REAL, w, 12)) {\n"
"\n"
"        // const OSD_REAL M[15] = stMonomials;\n"
"\n"
"        OSD_REAL S = 1.0f;\n"
"\n"
"        int totalOrder = ds + dt;\n"
"        if (totalOrder == 0) {\n"
"            S *= OSD_REAL_CAST(1.0f / 12.0f);\n"
"\n"
"            w[0]  = S * (1 - 2*M[1] - 4*M[2]          + 6*M[4] + 6*M[5] + 2*M[6]          - 6*M[8] - 4*M[9] -   M[10] - 2*M[11] + 2*M[13] +   M[14]);\n"
"            w[1]  = S * (1 + 2*M[1] - 2*M[2]          - 6*M[4]          - 4*M[6]          + 6*M[8] + 2*M[9] + 2*M[10] + 4*M[11] - 2*M[13] -   M[14]);\n"
"            w[2]  = S * (                                                 2*M[6]                            -   M[10] - 2*M[11]                    );\n"
"            w[3]  = S * (1 - 4*M[1] - 2*M[2] + 6*M[3] + 6*M[4]          - 4*M[6] - 6*M[7]          + 2*M[9] +   M[10] + 2*M[11] - 2*M[13] -   M[14]);\n"
"            w[4]  = S * (6                   -12*M[3] -12*M[4] -12*M[5] + 8*M[6] +12*M[7] +12*M[8] + 8*M[9] -   M[10] - 2*M[11] - 2*M[13] -   M[14]);\n"
"            w[5]  = S * (1 + 4*M[1] + 2*M[2] + 6*M[3] + 6*M[4]          - 4*M[6] - 6*M[7] -12*M[8] - 4*M[9] -   M[10] - 2*M[11] + 4*M[13] + 2*M[14]);\n"
"            w[6]  = S * (                                                                                       M[10] + 2*M[11]                    );\n"
"            w[7]  = S * (1 - 2*M[1] + 2*M[2]          - 6*M[4]          + 2*M[6] + 6*M[7]          - 4*M[9] -   M[10] - 2*M[11] + 4*M[13] + 2*M[14]);\n"
"            w[8]  = S * (1 + 2*M[1] + 4*M[2]          + 6*M[4] + 6*M[5] - 4*M[6] -12*M[7] - 6*M[8] - 4*M[9] + 2*M[10] + 4*M[11] - 2*M[13] -   M[14]);\n"
"            w[9]  = S * (                                                 2*M[6] + 6*M[7] + 6*M[8] + 2*M[9] -   M[10] - 2*M[11] - 2*M[13] -   M[14]);\n"
"            w[10] = S * (                                                                            2*M[9]                     - 2*M[13] -   M[14]);\n"
"            w[11] = S * (                                                                                                         2*M[13] +   M[14]);\n"
"        } else if (totalOrder == 1) {\n"
"            S *= OSD_REAL_CAST(1.0f / 6.0f);\n"
"\n"
"            if (ds != 0) {\n"
"                w[0]  = S * (-1          + 3*M[2] + 3*M[3]          - 3*M[5] - 2*M[6] - 3*M[7] +   M[9]);\n"
"                w[1]  = S * ( 1          - 3*M[2] - 6*M[3]          + 3*M[5] + 4*M[6] + 6*M[7] -   M[9]);\n"
"                w[2]  = S * (                       3*M[3]                   - 2*M[6] - 3*M[7]         );\n"
"                w[3]  = S * (-2 + 6*M[1] + 3*M[2] - 6*M[3] - 6*M[4]          + 2*M[6] + 3*M[7] -   M[9]);\n"
"                w[4]  = S * (   -12*M[1] - 6*M[2] +12*M[3] +12*M[4] + 6*M[5] - 2*M[6] - 3*M[7] -   M[9]);\n"
"                w[5]  = S * ( 2 + 6*M[1] + 3*M[2] - 6*M[3] - 6*M[4] - 6*M[5] - 2*M[6] - 3*M[7] + 2*M[9]);\n"
"                w[6]  = S * (                                                  2*M[6] + 3*M[7]         );\n"
"                w[7]  = S * (-1          - 3*M[2] + 3*M[3] + 6*M[4]          - 2*M[6] - 3*M[7] + 2*M[9]);\n"
"                w[8]  = S * ( 1          + 3*M[2] - 6*M[3] -12*M[4] - 3*M[5] + 4*M[6] + 6*M[7] -   M[9]);\n"
"                w[9]  = S * (                       3*M[3] + 6*M[4] + 3*M[5] - 2*M[6] - 3*M[7] -   M[9]);\n"
"                w[10] = S * (                                                                  -   M[9]);\n"
"                w[11] = S * (                                                                      M[9]);\n"
"            } else {\n"
"                w[0]  = S * (-2 + 3*M[1] + 6*M[2]          - 6*M[4] - 6*M[5]  -   M[6] + 3*M[8] + 2*M[9]);\n"
"                w[1]  = S * (-1 - 3*M[1]                   + 6*M[4] + 3*M[5]  + 2*M[6] - 3*M[8] - 2*M[9]);\n"
"                w[2]  = S * (                                                 -   M[6]                  );\n"
"                w[3]  = S * (-1 + 3*M[1]          - 3*M[3]          + 3*M[5]  +   M[6] - 3*M[8] - 2*M[9]);\n"
"                w[4]  = S * (   - 6*M[1] -12*M[2] + 6*M[3] +12*M[4] +12*M[5]  -   M[6] - 3*M[8] - 2*M[9]);\n"
"                w[5]  = S * ( 1 + 3*M[1]          - 3*M[3] -12*M[4] - 6*M[5]  -   M[6] + 6*M[8] + 4*M[9]);\n"
"                w[6]  = S * (                                                 +   M[6]                  );\n"
"                w[7]  = S * ( 1 - 3*M[1]          + 3*M[3]          - 6*M[5]  -   M[6] + 6*M[8] + 4*M[9]);\n"
"                w[8]  = S * ( 2 + 3*M[1] + 6*M[2] - 6*M[3] - 6*M[4] - 6*M[5]  + 2*M[6] - 3*M[8] - 2*M[9]);\n"
"                w[9]  = S * (                     + 3*M[3] + 6*M[4] + 3*M[5]  -   M[6] - 3*M[8] - 2*M[9]);\n"
"                w[10] = S * (                                         3*M[5]           - 3*M[8] - 2*M[9]);\n"
"                w[11] = S * (                                                            3*M[8] + 2*M[9]);\n"
"            }\n"
"        } else if (totalOrder == 2) {\n"
"            if (ds == 2) {\n"
"                w[0]  = S * (   +   M[1]          -   M[3] -   M[4]);\n"
"                w[1]  = S * (   - 2*M[1]          + 2*M[3] + 2*M[4]);\n"
"                w[2]  = S * (       M[1]          -   M[3] -   M[4]);\n"
"                w[3]  = S * ( 1 - 2*M[1] -   M[2] +   M[3] +   M[4]);\n"
"                w[4]  = S * (-2 + 4*M[1] + 2*M[2] -   M[3] -   M[4]);\n"
"                w[5]  = S * ( 1 - 2*M[1] -   M[2] -   M[3] -   M[4]);\n"
"                w[6]  = S * (                         M[3] +   M[4]);\n"
"                w[7]  = S * (   +   M[1] +   M[2] -   M[3] -   M[4]);\n"
"                w[8]  = S * (   - 2*M[1] - 2*M[2] + 2*M[3] + 2*M[4]);\n"
"                w[9]  = S * (       M[1] +   M[2] -   M[3] -   M[4]);\n"
"                w[10] =     0;\n"
"                w[11] =     0;\n"
"            } else if (dt == 2) {\n"
"                w[0]  = S * ( 1 -   M[1] - 2*M[2] +   M[4] +   M[5]);\n"
"                w[1]  = S * (   +   M[1] +   M[2] -   M[4] -   M[5]);\n"
"                w[2]  =     0;\n"
"                w[3]  = S * (            +   M[2] -   M[4] -   M[5]);\n"
"                w[4]  = S * (-2 + 2*M[1] + 4*M[2] -   M[4] -   M[5]);\n"
"                w[5]  = S * (   - 2*M[1] - 2*M[2] + 2*M[4] + 2*M[5]);\n"
"                w[6]  =     0;\n"
"                w[7]  = S * (            - 2*M[2] + 2*M[4] + 2*M[5]);\n"
"                w[8]  = S * ( 1 -   M[1] - 2*M[2] -   M[4] -   M[5]);\n"
"                w[9]  = S * (   +   M[1] +   M[2] -   M[4] -   M[5]);\n"
"                w[10] = S * (                M[2] -   M[4] -   M[5]);\n"
"                w[11] = S * (                         M[4] +   M[5]);\n"
"            } else {\n"
"                S *= OSD_REAL_CAST(1.0f / 2.0f);\n"
"\n"
"                w[0]  = S * ( 1          - 2*M[2] -   M[3] +   M[5]);\n"
"                w[1]  = S * (-1          + 2*M[2] + 2*M[3] -   M[5]);\n"
"                w[2]  = S * (                     -   M[3]         );\n"
"                w[3]  = S * ( 1 - 2*M[1]          +   M[3] -   M[5]);\n"
"                w[4]  = S * (-2 + 4*M[1] + 4*M[2] -   M[3] -   M[5]);\n"
"                w[5]  = S * ( 1 - 2*M[1] - 4*M[2] -   M[3] + 2*M[5]);\n"
"                w[6]  = S * (                     +   M[3]         );\n"
"                w[7]  = S * (-1 + 2*M[1]          -   M[3] + 2*M[5]);\n"
"                w[8]  = S * ( 1 - 4*M[1] - 2*M[2] + 2*M[3] -   M[5]);\n"
"                w[9]  = S * (   + 2*M[1] + 2*M[2] -   M[3] -   M[5]);\n"
"                w[10] = S * (                              -   M[5]);\n"
"                w[11] = S * (                                  M[5]);\n"
"            }\n"
"        } else {\n"
"            // assert(totalOrder <= 2);\n"
"        }\n"
"    }\n"
"\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_adjustBoxSplineTriBoundaryWeights(\n"
"        int boundaryMask,\n"
"        OSD_INOUT_ARRAY(OSD_REAL, weights, 12)) {\n"
"\n"
"        if (boundaryMask == 0) return;\n"
"\n"
"        //\n"
"        //  Determine boundary edges and vertices from the lower 3 and upper\n"
"        //  2 bits of the 5-bit mask:\n"
"        //\n"
"        int upperBits = (boundaryMask >> 3) & 0x3;\n"
"        int lowerBits = boundaryMask & 7;\n"
"\n"
"        int eBits = lowerBits;\n"
"        int vBits = 0;\n"
"\n"
"        if (upperBits == 1) {\n"
"            //  Boundary vertices only:\n"
"            vBits = eBits;\n"
"            eBits = 0;\n"
"        } else if (upperBits == 2) {\n"
"            //  Opposite vertex bit is edge bit rotated one to the right:\n"
"            vBits = ((eBits & 1) << 2) | (eBits >> 1);\n"
"        }\n"
"\n"
"        bool edge0IsBoundary = (eBits & 1) != 0;\n"
"        bool edge1IsBoundary = (eBits & 2) != 0;\n"
"        bool edge2IsBoundary = (eBits & 4) != 0;\n"
"\n"
"        //\n"
"        //  Adjust weights for the 4 boundary points and 3 interior points\n"
"        //  to account for the 3 phantom points adjacent to each\n"
"        //  boundary edge:\n"
"        //\n"
"        if (edge0IsBoundary) {\n"
"            OSD_REAL w0 = weights[0];\n"
"            if (edge2IsBoundary) {\n"
"                //  P0 = B1 + (B1 - I1)\n"
"                weights[4] += w0;\n"
"                weights[4] += w0;\n"
"                weights[8] -= w0;\n"
"            } else {\n"
"                //  P0 = B1 + (B0 - I0)\n"
"                weights[4] += w0;\n"
"                weights[3] += w0;\n"
"                weights[7] -= w0;\n"
"            }\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[1];\n"
"            weights[4] += w1;\n"
"            weights[5] += w1;\n"
"            weights[8] -= w1;\n"
"\n"
"            OSD_REAL w2 = weights[2];\n"
"            if (edge1IsBoundary) {\n"
"                //  P2 = B2 + (B2 - I1)\n"
"                weights[5] += w2;\n"
"                weights[5] += w2;\n"
"                weights[8] -= w2;\n"
"            } else {\n"
"                //  P2 = B2 + (B3 - I2)\n"
"                weights[5] += w2;\n"
"                weights[6] += w2;\n"
"                weights[9] -= w2;\n"
"            }\n"
"            //  Clear weights for the phantom points:\n"
"            weights[0] = weights[1] = weights[2] = 0.0f;\n"
"        }\n"
"        if (edge1IsBoundary) {\n"
"            OSD_REAL w0 = weights[6];\n"
"            if (edge0IsBoundary) {\n"
"                //  P0 = B1 + (B1 - I1)\n"
"                weights[5] += w0;\n"
"                weights[5] += w0;\n"
"                weights[4] -= w0;\n"
"            } else {\n"
"                //  P0 = B1 + (B0 - I0)\n"
"                weights[5] += w0;\n"
"                weights[2] += w0;\n"
"                weights[1] -= w0;\n"
"            }\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[9];\n"
"            weights[5] += w1;\n"
"            weights[8] += w1;\n"
"            weights[4] -= w1;\n"
"\n"
"            OSD_REAL w2 = weights[11];\n"
"            if (edge2IsBoundary) {\n"
"                //  P2 = B2 + (B2 - I1)\n"
"                weights[8] += w2;\n"
"                weights[8] += w2;\n"
"                weights[4] -= w2;\n"
"            } else {\n"
"                //  P2 = B2 + (B3 - I2)\n"
"                weights[8]  += w2;\n"
"                weights[10] += w2;\n"
"                weights[7]  -= w2;\n"
"            }\n"
"            //  Clear weights for the phantom points:\n"
"            weights[6] = weights[9] = weights[11] = 0.0f;\n"
"        }\n"
"        if (edge2IsBoundary) {\n"
"            OSD_REAL w0 = weights[10];\n"
"            if (edge1IsBoundary) {\n"
"                //  P0 = B1 + (B1 - I1)\n"
"                weights[8] += w0;\n"
"                weights[8] += w0;\n"
"                weights[5] -= w0;\n"
"            } else {\n"
"                //  P0 = B1 + (B0 - I0)\n"
"                weights[8]  += w0;\n"
"                weights[11] += w0;\n"
"                weights[9]  -= w0;\n"
"            }\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[7];\n"
"            weights[8] += w1;\n"
"            weights[4] += w1;\n"
"            weights[5] -= w1;\n"
"\n"
"            OSD_REAL w2 = weights[3];\n"
"            if (edge0IsBoundary) {\n"
"                //  P2 = B2 + (B2 - I1)\n"
"                weights[4] += w2;\n"
"                weights[4] += w2;\n"
"                weights[5] -= w2;\n"
"            } else {\n"
"                //  P2 = B2 + (B3 - I2)\n"
"                weights[4] += w2;\n"
"                weights[0] += w2;\n"
"                weights[1] -= w2;\n"
"            }\n"
"            //  Clear weights for the phantom points:\n"
"            weights[10] = weights[7] = weights[3] = 0.0f;\n"
"        }\n"
"\n"
"        //\n"
"        //  Adjust weights for the 3 boundary points and the 2 interior\n"
"        //  points to account for the 2 phantom points adjacent to\n"
"        //  each boundary vertex:\n"
"        //\n"
"        if ((vBits & 1) != 0) {\n"
"            //  P0 = B1 + (B0 - I0)\n"
"            OSD_REAL w0 = weights[3];\n"
"            weights[4] += w0;\n"
"            weights[7] += w0;\n"
"            weights[8] -= w0;\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[0];\n"
"            weights[4] += w1;\n"
"            weights[1] += w1;\n"
"            weights[5] -= w1;\n"
"\n"
"            //  Clear weights for the phantom points:\n"
"            weights[3] = weights[0] = 0.0f;\n"
"        }\n"
"        if ((vBits & 2) != 0) {\n"
"            //  P0 = B1 + (B0 - I0)\n"
"            OSD_REAL w0 = weights[2];\n"
"            weights[5] += w0;\n"
"            weights[1] += w0;\n"
"            weights[4] -= w0;\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[6];\n"
"            weights[5] += w1;\n"
"            weights[9] += w1;\n"
"            weights[8] -= w1;\n"
"\n"
"            //  Clear weights for the phantom points:\n"
"            weights[2] = weights[6] = 0.0f;\n"
"        }\n"
"        if ((vBits & 4) != 0) {\n"
"            //  P0 = B1 + (B0 - I0)\n"
"            OSD_REAL w0 = weights[11];\n"
"            weights[8] += w0;\n"
"            weights[9] += w0;\n"
"            weights[5] -= w0;\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[10];\n"
"            weights[8] += w1;\n"
"            weights[7] += w1;\n"
"            weights[4] -= w1;\n"
"\n"
"            //  Clear weights for the phantom points:\n"
"            weights[11] = weights[10] = 0.0f;\n"
"        }\n"
"    }\n"
"\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_boundBasisBoxSplineTri(\n"
"            int boundary,\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wP, 12),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDs, 12),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDt, 12),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDss, 12),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDst, 12),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDtt, 12)) {\n"
"\n"
"        if (OSD_OPTIONAL(wP)) {\n"
"            Osd_adjustBoxSplineTriBoundaryWeights(boundary, wP);\n"
"        }\n"
"        if (OSD_OPTIONAL(wDs && wDt)) {\n"
"            Osd_adjustBoxSplineTriBoundaryWeights(boundary, wDs);\n"
"            Osd_adjustBoxSplineTriBoundaryWeights(boundary, wDt);\n"
"\n"
"            if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"                Osd_adjustBoxSplineTriBoundaryWeights(boundary, wDss);\n"
"                Osd_adjustBoxSplineTriBoundaryWeights(boundary, wDst);\n"
"                Osd_adjustBoxSplineTriBoundaryWeights(boundary, wDtt);\n"
"            }\n"
"        }\n"
"    }\n"
"// }  // namespace\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"Osd_EvalBasisBoxSplineTri(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 12),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 12),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 12),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 12),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 12),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 12)) {\n"
"\n"
"    OSD_REAL stMonomials[15];\n"
"    Osd_evalBivariateMonomialsQuartic(s, t, stMonomials);\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        Osd_evalBoxSplineTriDerivWeights(stMonomials, 0, 0, wP);\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        Osd_evalBoxSplineTriDerivWeights(stMonomials, 1, 0, wDs);\n"
"        Osd_evalBoxSplineTriDerivWeights(stMonomials, 0, 1, wDt);\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            Osd_evalBoxSplineTriDerivWeights(stMonomials, 2, 0, wDss);\n"
"            Osd_evalBoxSplineTriDerivWeights(stMonomials, 1, 1, wDst);\n"
"            Osd_evalBoxSplineTriDerivWeights(stMonomials, 0, 2, wDtt);\n"
"        }\n"
"    }\n"
"    return 12;\n"
"}\n"
"\n"
"\n"
"// namespace {\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_evalBezierTriDerivWeights(\n"
"        OSD_REAL s, OSD_REAL t, int ds, int dt,\n"
"        OSD_OUT_ARRAY(OSD_REAL, wB, 15)) {\n"
"\n"
"        OSD_REAL u  = s;\n"
"        OSD_REAL v  = t;\n"
"        OSD_REAL w  = 1 - u - v;\n"
"\n"
"        OSD_REAL uu = u * u;\n"
"        OSD_REAL vv = v * v;\n"
"        OSD_REAL ww = w * w;\n"
"\n"
"        OSD_REAL uv = u * v;\n"
"        OSD_REAL vw = v * w;\n"
"        OSD_REAL uw = u * w;\n"
"\n"
"        int totalOrder = ds + dt;\n"
"        if (totalOrder == 0) {\n"
"            wB[0]  =      ww * ww;\n"
"            wB[1]  =  4 * uw * ww;\n"
"            wB[2]  =  6 * uw * uw;\n"
"            wB[3]  =  4 * uw * uu;\n"
"            wB[4]  =      uu * uu;\n"
"            wB[5]  =  4 * vw * ww;\n"
"            wB[6]  = 12 * ww * uv;\n"
"            wB[7]  = 12 * uu * vw;\n"
"            wB[8]  =  4 * uv * uu;\n"
"            wB[9]  =  6 * vw * vw;\n"
"            wB[10] = 12 * vv * uw;\n"
"            wB[11] =  6 * uv * uv;\n"
"            wB[12] =  4 * vw * vv;\n"
"            wB[13] =  4 * uv * vv;\n"
"            wB[14] =      vv * vv;\n"
"        } else if (totalOrder == 1) {\n"
"            if (ds == 1) {\n"
"                wB[0]  =  -4 * ww * w;\n"
"                wB[1]  =   4 * ww * (w - 3 * u);\n"
"                wB[2]  =  12 * uw * (w - u);\n"
"                wB[3]  =   4 * uu * (3 * w - u);\n"
"                wB[4]  =   4 * uu * u;\n"
"                wB[5]  = -12 * vw * w;\n"
"                wB[6]  =  12 * vw * (w - 2 * u);\n"
"                wB[7]  =  12 * uv * (2 * w - u);\n"
"                wB[8]  =  12 * uv * u;\n"
"                wB[9]  = -12 * vv * w;\n"
"                wB[10] =  12 * vv * (w - u);\n"
"                wB[11] =  12 * vv * u;\n"
"                wB[12] =  -4 * vv * v;\n"
"                wB[13] =   4 * vv * v;\n"
"                wB[14] =   0;\n"
"            } else {\n"
"                wB[0]  =  -4 * ww * w;\n"
"                wB[1]  = -12 * ww * u;\n"
"                wB[2]  = -12 * uu * w;\n"
"                wB[3]  =  -4 * uu * u;\n"
"                wB[4]  =   0;\n"
"                wB[5]  =   4 * ww * (w - 3 * v);\n"
"                wB[6]  =  12 * uw * (w - 2 * v);\n"
"                wB[7]  =  12 * uu * (w - v);\n"
"                wB[8]  =   4 * uu * u;\n"
"                wB[9]  =  12 * vw * (w - v);\n"
"                wB[10] =  12 * uv * (2 * w - v);\n"
"                wB[11] =  12 * uv * u;;\n"
"                wB[12] =   4 * vv * (3 * w - v);\n"
"                wB[13] =  12 * vv * u;\n"
"                wB[14] =   4 * vv * v;\n"
"            }\n"
"        } else if (totalOrder == 2) {\n"
"            if (ds == 2) {\n"
"                wB[0]  =  12 * ww;\n"
"                wB[1]  =  24 * (uw - ww);\n"
"                wB[2]  =  12 * (uu - 4 * uw + ww);\n"
"                wB[3]  =  24 * (uw - uu);\n"
"                wB[4]  =  12 * uu;\n"
"                wB[5]  =  24 * vw;\n"
"                wB[6]  =  24 * (uv - 2 * vw);\n"
"                wB[7]  =  24 * (vw - 2 * uv);\n"
"                wB[8]  =  24 * uv;\n"
"                wB[9]  =  12 * vv;\n"
"                wB[10] = -24 * vv;\n"
"                wB[11] =  12 * vv;\n"
"                wB[12] =   0;\n"
"                wB[13] =   0;\n"
"                wB[14] =   0;\n"
"            } else if (dt == 2) {\n"
"                wB[0]  =  12 * ww;\n"
"                wB[1]  =  24 * uw;\n"
"                wB[2]  =  12 * uu;\n"
"                wB[3]  =   0;\n"
"                wB[4]  =   0;\n"
"                wB[5]  =  24 * (vw - ww);\n"
"                wB[6]  =  24 * (uv - 2 * uw);\n"
"                wB[7]  = -24 * uu;\n"
"                wB[8]  =   0;\n"
"                wB[9]  =  12 * (vv - 4 * vw + ww);\n"
"                wB[10] =  24 * (uw - 2 * uv);\n"
"                wB[11] =  12 * uu;\n"
"                wB[12] =  24 * (vw - vv);\n"
"                wB[13] =  24 * uv;\n"
"                wB[14] =  12 * vv;\n"
"            } else {\n"
"                wB[0]  =  12 * ww;\n"
"                wB[3]  = -12 * uu;\n"
"                wB[13] =  12 * vv;\n"
"                wB[11] =  24 * uv;\n"
"                wB[1]  =  24 * uw - wB[0];\n"
"                wB[2]  = -24 * uw - wB[3];\n"
"                wB[5]  =  24 * vw - wB[0];\n"
"                wB[6]  = -24 * vw + wB[11] - wB[1];\n"
"                wB[8]  = - wB[3];\n"
"                wB[7]  = -(wB[11] + wB[2]);\n"
"                wB[9]  =   wB[13] - wB[5] - wB[0];\n"
"                wB[10] = -(wB[9] + wB[11]);\n"
"                wB[12] = - wB[13];\n"
"                wB[4]  =   0;\n"
"                wB[14] =   0;\n"
"            }\n"
"        } else {\n"
"            // assert(totalOrder <= 2);\n"
"        }\n"
"    }\n"
"// } // end namespace\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"Osd_EvalBasisBezierTri(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 15),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 15),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 15),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 15),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 15),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 15)) {\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        Osd_evalBezierTriDerivWeights(s, t, 0, 0, wP);\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        Osd_evalBezierTriDerivWeights(s, t, 1, 0, wDs);\n"
"        Osd_evalBezierTriDerivWeights(s, t, 0, 1, wDt);\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            Osd_evalBezierTriDerivWeights(s, t, 2, 0, wDss);\n"
"            Osd_evalBezierTriDerivWeights(s, t, 1, 1, wDst);\n"
"            Osd_evalBezierTriDerivWeights(s, t, 0, 2, wDtt);\n"
"        }\n"
"    }\n"
"    return 15;\n"
"}\n"
"\n"
"\n"
"// namespace {\n"
"    //\n"
"    //  Expanding a set of 15 Bezier basis functions for the 6 (3 pairs) of\n"
"    //  rational weights for the 18 Gregory basis functions:\n"
"    //\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_convertBezierWeightsToGregory(\n"
"        OSD_INOUT_ARRAY(OSD_REAL, wB, 15),\n"
"        OSD_INOUT_ARRAY(OSD_REAL, rG,  6),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wG, 18)) {\n"
"\n"
"        wG[0]  = wB[0];\n"
"        wG[1]  = wB[1];\n"
"        wG[2]  = wB[5];\n"
"        wG[3]  = wB[6] * rG[0];\n"
"        wG[4]  = wB[6] * rG[1];\n"
"\n"
"        wG[5]  = wB[4];\n"
"        wG[6]  = wB[8];\n"
"        wG[7]  = wB[3];\n"
"        wG[8]  = wB[7] * rG[2];\n"
"        wG[9]  = wB[7] * rG[3];\n"
"\n"
"        wG[10] = wB[14];\n"
"        wG[11] = wB[12];\n"
"        wG[12] = wB[13];\n"
"        wG[13] = wB[10] * rG[4];\n"
"        wG[14] = wB[10] * rG[5];\n"
"\n"
"        wG[15] = wB[2];\n"
"        wG[16] = wB[11];\n"
"        wG[17] = wB[9];\n"
"    }\n"
"// } // end namespace\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"Osd_EvalBasisGregoryTri(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 18),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 18),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 18),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 18),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 18),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 18)) {\n"
"\n"
"    //\n"
"    //  Bezier basis functions are denoted with B while the rational multipliers for the\n"
"    //  interior points will be denoted G -- so we have B(s,t) and G(s,t) (though we\n"
"    //  switch to barycentric (u,v,w) briefly to compute G)\n"
"    //\n"
"    OSD_REAL BP[15], BDs[15], BDt[15], BDss[15], BDst[15], BDtt[15];\n"
"\n"
"    OSD_REAL G[6] = OSD_ARRAY_6(OSD_REAL, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f );\n"
"    OSD_REAL u = s;\n"
"    OSD_REAL v = t;\n"
"    OSD_REAL w = 1 - u - v;\n"
"\n"
"    if ((u + v) > 0) {\n"
"        G[0]  = u / (u + v);\n"
"        G[1]  = v / (u + v);\n"
"    }\n"
"    if ((v + w) > 0) {\n"
"        G[2] = v / (v + w);\n"
"        G[3] = w / (v + w);\n"
"    }\n"
"    if ((w + u) > 0) {\n"
"        G[4] = w / (w + u);\n"
"        G[5] = u / (w + u);\n"
"    }\n"
"\n"
"    //\n"
"    //  Compute Bezier basis functions and convert, adjusting interior points:\n"
"    //\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        Osd_evalBezierTriDerivWeights(s, t, 0, 0, BP);\n"
"        Osd_convertBezierWeightsToGregory(BP, G, wP);\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        //  TBD -- ifdef OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES\n"
"\n"
"        Osd_evalBezierTriDerivWeights(s, t, 1, 0, BDs);\n"
"        Osd_evalBezierTriDerivWeights(s, t, 0, 1, BDt);\n"
"\n"
"        Osd_convertBezierWeightsToGregory(BDs, G, wDs);\n"
"        Osd_convertBezierWeightsToGregory(BDt, G, wDt);\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            Osd_evalBezierTriDerivWeights(s, t, 2, 0, BDss);\n"
"            Osd_evalBezierTriDerivWeights(s, t, 1, 1, BDst);\n"
"            Osd_evalBezierTriDerivWeights(s, t, 0, 2, BDtt);\n"
"\n"
"            Osd_convertBezierWeightsToGregory(BDss, G, wDss);\n"
"            Osd_convertBezierWeightsToGregory(BDst, G, wDst);\n"
"            Osd_convertBezierWeightsToGregory(BDtt, G, wDtt);\n"
"        }\n"
"    }\n"
"    return 18;\n"
"}\n"
"\n"
"// The following functions are low-level internal methods which\n"
"// were exposed in earlier releases, but were never intended to\n"
"// be part of the supported public API.\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBezierWeights(\n"
"    OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDP, 4),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDP2, 4)) {\n"
"\n"
"    Osd_evalBezierCurve(t, wP, wDP, wDP2);\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBSplineWeights(\n"
"    OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDP, 4),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDP2, 4)) {\n"
"\n"
"    Osd_evalBSplineCurve(t, wP, wDP, wDP2);\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBoxSplineWeights(\n"
"    float s, float t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 12)) {\n"
"\n"
"    OSD_REAL stMonomials[15];\n"
"    Osd_evalBivariateMonomialsQuartic(s, t, stMonomials);\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        Osd_evalBoxSplineTriDerivWeights(stMonomials, 0, 0, wP);\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdAdjustBoundaryWeights(\n"
"        int boundary,\n"
"        OSD_INOUT_ARRAY(OSD_REAL, sWeights, 4),\n"
"        OSD_INOUT_ARRAY(OSD_REAL, tWeights, 4)) {\n"
"\n"
"    if ((boundary & 1) != 0) {\n"
"        tWeights[2] -= tWeights[0];\n"
"        tWeights[1] += tWeights[0] * 2.0f;\n"
"        tWeights[0]  = 0.0f;\n"
"    }\n"
"    if ((boundary & 2) != 0) {\n"
"        sWeights[1] -= sWeights[3];\n"
"        sWeights[2] += sWeights[3] * 2.0f;\n"
"        sWeights[3]  = 0.0f;\n"
"    }\n"
"    if ((boundary & 4) != 0) {\n"
"        tWeights[1] -= tWeights[3];\n"
"        tWeights[2] += tWeights[3] * 2.0f;\n"
"        tWeights[3]  = 0.0f;\n"
"    }\n"
"    if ((boundary & 8) != 0) {\n"
"        sWeights[2] -= sWeights[0];\n"
"        sWeights[1] += sWeights[0] * 2.0f;\n"
"        sWeights[0]  = 0.0f;\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdComputeTensorProductPatchWeights(\n"
"    float dScale, int boundary,\n"
"    OSD_IN_ARRAY(float, sWeights, 4),\n"
"    OSD_IN_ARRAY(float, tWeights, 4),\n"
"    OSD_IN_ARRAY(float, dsWeights, 4),\n"
"    OSD_IN_ARRAY(float, dtWeights, 4),\n"
"    OSD_IN_ARRAY(float, dssWeights, 4),\n"
"    OSD_IN_ARRAY(float, dttWeights, 4),\n"
"    OSD_OUT_ARRAY(float, wP, 16),\n"
"    OSD_OUT_ARRAY(float, wDs, 16),\n"
"    OSD_OUT_ARRAY(float, wDt, 16),\n"
"    OSD_OUT_ARRAY(float, wDss, 16),\n"
"    OSD_OUT_ARRAY(float, wDst, 16),\n"
"    OSD_OUT_ARRAY(float, wDtt, 16)) {\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        // Compute the tensor product weight of the (s,t) basis function\n"
"        // corresponding to each control vertex:\n"
"\n"
"        OsdAdjustBoundaryWeights(boundary, sWeights, tWeights);\n"
"\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wP[4*i+j] = sWeights[j] * tWeights[i];\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        // Compute the tensor product weight of the differentiated (s,t) basis\n"
"        // function corresponding to each control vertex (scaled accordingly):\n"
"\n"
"        OsdAdjustBoundaryWeights(boundary, dsWeights, dtWeights);\n"
"\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wDs[4*i+j] = dsWeights[j] * tWeights[i] * dScale;\n"
"                wDt[4*i+j] = sWeights[j] * dtWeights[i] * dScale;\n"
"            }\n"
"        }\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            // Compute the tensor product weight of appropriate differentiated\n"
"            // (s,t) basis functions for each control vertex (scaled accordingly):\n"
"            float d2Scale = dScale * dScale;\n"
"\n"
"            OsdAdjustBoundaryWeights(boundary, dssWeights, dttWeights);\n"
"\n"
"            for (int i = 0; i < 4; ++i) {\n"
"                for (int j = 0; j < 4; ++j) {\n"
"                    wDss[4*i+j] = dssWeights[j] * tWeights[i] * d2Scale;\n"
"                    wDst[4*i+j] = dsWeights[j] * dtWeights[i] * d2Scale;\n"
"                    wDtt[4*i+j] = sWeights[j] * dttWeights[i] * d2Scale;\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBilinearPatchWeights(\n"
"        OSD_REAL s, OSD_REAL t, OSD_REAL d1Scale,\n"
"        OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDs, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDt, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDss, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDst, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDtt, 4)) {\n"
"\n"
"    int nPoints = Osd_EvalBasisLinear(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < nPoints; ++i) {\n"
"            wDs[i] *= d1Scale;\n"
"            wDt[i] *= d1Scale;\n"
"        }\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            OSD_REAL d2Scale = d1Scale * d1Scale;\n"
"\n"
"            for (int i = 0; i < nPoints; ++i) {\n"
"                wDss[i] *= d2Scale;\n"
"                wDst[i] *= d2Scale;\n"
"                wDtt[i] *= d2Scale;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBSplinePatchWeights(\n"
"    OSD_REAL s, OSD_REAL t, OSD_REAL d1Scale, int boundary,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 16)) {\n"
"\n"
"    int nPoints = Osd_EvalBasisBSpline(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    Osd_boundBasisBSpline(boundary, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < nPoints; ++i) {\n"
"            wDs[i] *= d1Scale;\n"
"            wDt[i] *= d1Scale;\n"
"        }\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            OSD_REAL d2Scale = d1Scale * d1Scale;\n"
"\n"
"            for (int i = 0; i < nPoints; ++i) {\n"
"                wDss[i] *= d2Scale;\n"
"                wDst[i] *= d2Scale;\n"
"                wDtt[i] *= d2Scale;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBezierPatchWeights(\n"
"    OSD_REAL s, OSD_REAL t, OSD_REAL d1Scale,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 16)) {\n"
"    int nPoints = Osd_EvalBasisBezier(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < nPoints; ++i) {\n"
"            wDs[i] *= d1Scale;\n"
"            wDt[i] *= d1Scale;\n"
"        }\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            OSD_REAL d2Scale = d1Scale * d1Scale;\n"
"\n"
"            for (int i = 0; i < nPoints; ++i) {\n"
"                wDss[i] *= d2Scale;\n"
"                wDst[i] *= d2Scale;\n"
"                wDtt[i] *= d2Scale;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetGregoryPatchWeights(\n"
"    OSD_REAL s, OSD_REAL t, OSD_REAL d1Scale,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 20)) {\n"
"    int nPoints = Osd_EvalBasisGregory(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < nPoints; ++i) {\n"
"            wDs[i] *= d1Scale;\n"
"            wDt[i] *= d1Scale;\n"
"        }\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            OSD_REAL d2Scale = d1Scale * d1Scale;\n"
"\n"
"            for (int i = 0; i < nPoints; ++i) {\n"
"                wDss[i] *= d2Scale;\n"
"                wDst[i] *= d2Scale;\n"
"                wDtt[i] *= d2Scale;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"//\n"
"//  Higher level basis evaluation functions that deal with parameterization and\n"
"//  boundary issues (reflected in PatchParam) for all patch types:\n"
"//\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"OsdEvaluatePatchBasisNormalized(\n"
"    int patchType, OsdPatchParam param,\n"
"    OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 20)) {\n"
"\n"
"    int boundaryMask = OsdPatchParamGetBoundary(param);\n"
"\n"
"    int nPoints = 0;\n"
"    if (patchType == OSD_PATCH_DESCRIPTOR_REGULAR) {\n"
"#if OSD_ARRAY_ARG_BOUND_OPTIONAL\n"
"        nPoints = Osd_EvalBasisBSpline(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"        if (boundaryMask != 0) {\n"
"            Osd_boundBasisBSpline(\n"
"                boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"        }\n"
"#else\n"
"        OSD_REAL wP16[16], wDs16[16], wDt16[16],\n"
"                 wDss16[16], wDst16[16], wDtt16[16];\n"
"        nPoints = Osd_EvalBasisBSpline(\n"
"                s, t, wP16, wDs16, wDt16, wDss16, wDst16, wDtt16);\n"
"        if (boundaryMask != 0) {\n"
"            Osd_boundBasisBSpline(\n"
"                boundaryMask, wP16, wDs16, wDt16, wDss16, wDst16, wDtt16);\n"
"        }\n"
"        for (int i=0; i<nPoints; ++i) {\n"
"            wP[i] = wP16[i];\n"
"            wDs[i] = wDs16[i]; wDt[i] = wDt16[i];\n"
"            wDss[i] = wDss16[i]; wDst[i] = wDst16[i]; wDtt[i] = wDtt16[i];\n"
"        }\n"
"#endif\n"
"    } else if (patchType == OSD_PATCH_DESCRIPTOR_LOOP) {\n"
"#if OSD_ARRAY_ARG_BOUND_OPTIONAL\n"
"        nPoints = Osd_EvalBasisBoxSplineTri(\n"
"                s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"        if (boundaryMask != 0) {\n"
"            Osd_boundBasisBoxSplineTri(\n"
"                boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"        }\n"
"#else\n"
"        OSD_REAL wP12[12], wDs12[12], wDt12[12],\n"
"                 wDss12[12], wDst12[12], wDtt12[12];\n"
"        nPoints = Osd_EvalBasisBoxSplineTri(\n"
"                s, t, wP12, wDs12, wDt12, wDss12, wDst12, wDtt12);\n"
"        if (boundaryMask != 0) {\n"
"            Osd_boundBasisBoxSplineTri(\n"
"                boundaryMask, wP12, wDs12, wDt12, wDss12, wDst12, wDtt12);\n"
"        }\n"
"        for (int i=0; i<nPoints; ++i) {\n"
"            wP[i] = wP12[i];\n"
"            wDs[i] = wDs12[i]; wDt[i] = wDt12[i];\n"
"            wDss[i] = wDss12[i]; wDst[i] = wDst12[i]; wDtt[i] = wDtt12[i];\n"
"        }\n"
"#endif\n"
"    } else if (patchType == OSD_PATCH_DESCRIPTOR_GREGORY_BASIS) {\n"
"        nPoints = Osd_EvalBasisGregory(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    } else if (patchType == OSD_PATCH_DESCRIPTOR_GREGORY_TRIANGLE) {\n"
"#if OSD_ARRAY_ARG_BOUND_OPTIONAL\n"
"        nPoints = Osd_EvalBasisGregoryTri(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"#else\n"
"        OSD_REAL wP18[18], wDs18[18], wDt18[18],\n"
"                 wDss18[18], wDst18[18], wDtt18[18];\n"
"        nPoints = Osd_EvalBasisGregoryTri(\n"
"                s, t, wP18, wDs18, wDt18, wDss18, wDst18, wDtt18);\n"
"        for (int i=0; i<nPoints; ++i) {\n"
"            wP[i] = wP18[i];\n"
"            wDs[i] = wDs18[i]; wDt[i] = wDt18[i];\n"
"            wDss[i] = wDss18[i]; wDst[i] = wDst18[i]; wDtt[i] = wDtt18[i];\n"
"        }\n"
"#endif\n"
"    } else if (patchType == OSD_PATCH_DESCRIPTOR_QUADS) {\n"
"#if OSD_ARRAY_ARG_BOUND_OPTIONAL\n"
"        nPoints = Osd_EvalBasisLinear(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"#else\n"
"        OSD_REAL wP4[4], wDs4[4], wDt4[4],\n"
"                 wDss4[4], wDst4[4], wDtt4[4];\n"
"        nPoints = Osd_EvalBasisLinear(\n"
"                s, t, wP4, wDs4, wDt4, wDss4, wDst4, wDtt4);\n"
"        for (int i=0; i<nPoints; ++i) {\n"
"            wP[i] = wP4[i];\n"
"            wDs[i] = wDs4[i]; wDt[i] = wDt4[i];\n"
"            wDss[i] = wDss4[i]; wDst[i] = wDst4[i]; wDtt[i] = wDtt4[i];\n"
"        }\n"
"#endif\n"
"    } else if (patchType == OSD_PATCH_DESCRIPTOR_TRIANGLES) {\n"
"#if OSD_ARRAY_ARG_BOUND_OPTIONAL\n"
"        nPoints = Osd_EvalBasisLinearTri(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"#else\n"
"        OSD_REAL wP3[3], wDs3[3], wDt3[3],\n"
"                 wDss3[3], wDst3[3], wDtt3[3];\n"
"        nPoints = Osd_EvalBasisLinearTri(\n"
"                s, t, wP3, wDs3, wDt3, wDss3, wDst3, wDtt3);\n"
"        for (int i=0; i<nPoints; ++i) {\n"
"            wP[i] = wP3[i];\n"
"            wDs[i] = wDs3[i]; wDt[i] = wDt3[i];\n"
"            wDss[i] = wDss3[i]; wDst[i] = wDst3[i]; wDtt[i] = wDtt3[i];\n"
"        }\n"
"#endif\n"
"    } else {\n"
"        // assert(0);\n"
"    }\n"
"    return nPoints;\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"OsdEvaluatePatchBasis(\n"
"    int patchType, OsdPatchParam param,\n"
"    OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 20)) {\n"
"\n"
"    OSD_REAL derivSign = 1.0f;\n"
"\n"
"    if ((patchType == OSD_PATCH_DESCRIPTOR_LOOP) ||\n"
"        (patchType == OSD_PATCH_DESCRIPTOR_GREGORY_TRIANGLE) ||\n"
"        (patchType == OSD_PATCH_DESCRIPTOR_TRIANGLES)) {\n"
"        OSD_REAL uv[2] = OSD_ARRAY_2(OSD_REAL, s, t);\n"
"        OsdPatchParamNormalizeTriangle(param, uv);\n"
"        s = uv[0];\n"
"        t = uv[1];\n"
"        if (OsdPatchParamIsTriangleRotated(param)) {\n"
"            derivSign = -1.0f;\n"
"        }\n"
"    } else {\n"
"        OSD_REAL uv[2] = OSD_ARRAY_2(OSD_REAL, s, t);\n"
"        OsdPatchParamNormalize(param, uv);\n"
"        s = uv[0];\n"
"        t = uv[1];\n"
"    }\n"
"\n"
"    int nPoints = OsdEvaluatePatchBasisNormalized(\n"
"        patchType, param, s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        OSD_REAL d1Scale =\n"
"                derivSign * OSD_REAL_CAST(1 << OsdPatchParamGetDepth(param));\n"
"\n"
"        for (int i = 0; i < nPoints; ++i) {\n"
"            wDs[i] *= d1Scale;\n"
"            wDt[i] *= d1Scale;\n"
"        }\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            OSD_REAL d2Scale = derivSign * d1Scale * d1Scale;\n"
"\n"
"            for (int i = 0; i < nPoints; ++i) {\n"
"                wDss[i] *= d2Scale;\n"
"                wDst[i] *= d2Scale;\n"
"                wDtt[i] *= d2Scale;\n"
"            }\n"
"        }\n"
"    }\n"
"    return nPoints;\n"
"}\n"
"\n"
"#if !defined(OSD_PATCH_BASIS_GLSL) && "
"    !defined(OSD_PATCH_BASIS_HLSL) && "
"    !defined(OSD_PATCH_BASIS_CUDA) && "
"    !defined(OSD_PATCH_BASIS_OPENCL) && "
"    !defined(OSD_PATCH_BASIS_METAL)\n"
"\n"
"}  // end namespace Osd\n"
"\n"
"}  // end namespace OPENSUBDIV_VERSION\n"
"using namespace OPENSUBDIV_VERSION;\n"
"\n"
"}  // end namespace OpenSubdiv\n"
"\n"
"#endif\n"
"\n"
"#endif /* OPENSUBDIV3_OSD_PATCH_BASIS_H */\n"
"\n"
;
static const char *boxSplineTriangleShaderSource =
"//\n"
"//   Copyright 2018 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.VertexBoxSplineTriangle\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_VERTEX_BOX_SPLINE_TRIANGLE_SHADER\n"
"\n"
"layout(location = 0) in vec4 position;\n"
"OSD_USER_VARYING_ATTRIBUTE_DECLARE\n"
"\n"
"out block {\n"
"    ControlVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt;\n"
"\n"
"void main()\n"
"{\n"
"    outpt.v.position = position;\n"
"    OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(position);\n"
"    OSD_USER_VARYING_PER_VERTEX();\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessControlBoxSplineTriangle\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_TESS_CONTROL_BOX_SPLINE_TRIANGLE_SHADER\n"
"\n"
"patch out vec4 tessOuterLo, tessOuterHi;\n"
"\n"
"in block {\n"
"    ControlVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} inpt[];\n"
"\n"
"out block {\n"
"    OsdPerPatchVertexBezier v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt[15];\n"
"\n"
"layout(vertices = 15) out;\n"
"\n"
"void main()\n"
"{\n"
"    vec3 cv[12];\n"
"    for (int i=0; i<12; ++i) {\n"
"        cv[i] = inpt[i].v.position.xyz;\n"
"    }\n"
"\n"
"    ivec3 patchParam = OsdGetPatchParam(OsdGetPatchIndex(gl_PrimitiveID));\n"
"    OsdComputePerPatchVertexBoxSplineTriangle(\n"
"        patchParam, gl_InvocationID, cv, outpt[gl_InvocationID].v);\n"
"\n"
"    OSD_USER_VARYING_PER_CONTROL_POINT(gl_InvocationID, gl_InvocationID);\n"
"\n"
"#if defined OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    // Wait for all basis conversion to be finished\n"
"    barrier();\n"
"#endif\n"
"    if (gl_InvocationID == 0) {\n"
"        vec4 tessLevelOuter = vec4(0);\n"
"        vec2 tessLevelInner = vec2(0);\n"
"\n"
"        OSD_PATCH_CULL(12);\n"
"\n"
"#if defined OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"        // Gather bezier control points to compute limit surface tess levels\n"
"        vec3 bezcv[15];\n"
"        for (int i=0; i<15; ++i) {\n"
"            bezcv[i] = outpt[i].v.P;\n"
"        }\n"
"        OsdEvalPatchBezierTriangleTessLevels(\n"
"                         bezcv, patchParam,\n"
"                         tessLevelOuter, tessLevelInner,\n"
"                         tessOuterLo, tessOuterHi);\n"
"#else\n"
"        OsdGetTessLevelsUniformTriangle(patchParam,\n"
"                        tessLevelOuter, tessLevelInner,\n"
"                        tessOuterLo, tessOuterHi);\n"
"\n"
"#endif\n"
"\n"
"        gl_TessLevelOuter[0] = tessLevelOuter[0];\n"
"        gl_TessLevelOuter[1] = tessLevelOuter[1];\n"
"        gl_TessLevelOuter[2] = tessLevelOuter[2];\n"
"\n"
"        gl_TessLevelInner[0] = tessLevelInner[0];\n"
"    }\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessEvalBoxSplineTriangle\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_TESS_EVAL_BOX_SPLINE_TRIANGLE_SHADER\n"
"\n"
"layout(triangles) in;\n"
"layout(OSD_SPACING) in;\n"
"\n"
"patch in vec4 tessOuterLo, tessOuterHi;\n"
"\n"
"in block {\n"
"    OsdPerPatchVertexBezier v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} inpt[];\n"
"\n"
"out block {\n"
"    OutputVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt;\n"
"\n"
"void main()\n"
"{\n"
"    vec3 P = vec3(0), dPu = vec3(0), dPv = vec3(0);\n"
"    vec3 N = vec3(0), dNu = vec3(0), dNv = vec3(0);\n"
"\n"
"    OsdPerPatchVertexBezier cv[15];\n"
"    for (int i = 0; i < 15; ++i) {\n"
"        cv[i] = inpt[i].v;\n"
"    }\n"
"\n"
"    vec2 UV = OsdGetTessParameterizationTriangle(gl_TessCoord.xyz,\n"
"                                                 tessOuterLo,\n"
"                                                 tessOuterHi);\n"
"\n"
"    ivec3 patchParam = inpt[0].v.patchParam;\n"
"    OsdEvalPatchBezierTriangle(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);\n"
"\n"
"    // all code below here is client code\n"
"    outpt.v.position = OsdModelViewMatrix() * vec4(P, 1.0f);\n"
"    outpt.v.normal = (OsdModelViewMatrix() * vec4(N, 0.0f)).xyz;\n"
"    outpt.v.tangent = (OsdModelViewMatrix() * vec4(dPu, 0.0f)).xyz;\n"
"    outpt.v.bitangent = (OsdModelViewMatrix() * vec4(dPv, 0.0f)).xyz;\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    outpt.v.Nu = dNu;\n"
"    outpt.v.Nv = dNv;\n"
"#endif\n"
"\n"
"    outpt.v.tessCoord = UV;\n"
"    outpt.v.patchCoord = OsdInterpolatePatchCoordTriangle(UV, patchParam);\n"
"\n"
"    OSD_USER_VARYING_PER_EVAL_POINT_TRIANGLE(UV, 4, 5, 8);\n"
"\n"
"    OSD_DISPLACEMENT_CALLBACK;\n"
"\n"
"    gl_Position = OsdProjectionMatrix() * outpt.v.position;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;
static const char *bsplineShaderSource =
"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.VertexBSpline\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_VERTEX_BSPLINE_SHADER\n"
"\n"
"layout(location = 0) in vec4 position;\n"
"OSD_USER_VARYING_ATTRIBUTE_DECLARE\n"
"\n"
"out block {\n"
"    ControlVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt;\n"
"\n"
"void main()\n"
"{\n"
"    outpt.v.position = position;\n"
"    OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(position);\n"
"    OSD_USER_VARYING_PER_VERTEX();\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessControlBSpline\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_TESS_CONTROL_BSPLINE_SHADER\n"
"\n"
"patch out vec4 tessOuterLo, tessOuterHi;\n"
"\n"
"in block {\n"
"    ControlVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} inpt[];\n"
"\n"
"out block {\n"
"    OsdPerPatchVertexBezier v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt[16];\n"
"\n"
"layout(vertices = 16) out;\n"
"\n"
"void main()\n"
"{\n"
"    vec3 cv[16];\n"
"    for (int i=0; i<16; ++i) {\n"
"        cv[i] = inpt[i].v.position.xyz;\n"
"    }\n"
"\n"
"    ivec3 patchParam = OsdGetPatchParam(OsdGetPatchIndex(gl_PrimitiveID));\n"
"    OsdComputePerPatchVertexBSpline(patchParam, gl_InvocationID, cv, outpt[gl_InvocationID].v);\n"
"\n"
"    OSD_USER_VARYING_PER_CONTROL_POINT(gl_InvocationID, gl_InvocationID);\n"
"\n"
"#if defined OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    // Wait for all basis conversion to be finished\n"
"    barrier();\n"
"#endif\n"
"    if (gl_InvocationID == 0) {\n"
"        vec4 tessLevelOuter = vec4(0);\n"
"        vec2 tessLevelInner = vec2(0);\n"
"\n"
"        OSD_PATCH_CULL(16);\n"
"\n"
"#if defined OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"        // Gather bezier control points to compute limit surface tess levels\n"
"        OsdPerPatchVertexBezier cpBezier[16];\n"
"        cpBezier[0] = outpt[0].v;\n"
"        cpBezier[1] = outpt[1].v;\n"
"        cpBezier[2] = outpt[2].v;\n"
"        cpBezier[3] = outpt[3].v;\n"
"        cpBezier[4] = outpt[4].v;\n"
"        cpBezier[5] = outpt[5].v;\n"
"        cpBezier[6] = outpt[6].v;\n"
"        cpBezier[7] = outpt[7].v;\n"
"        cpBezier[8] = outpt[8].v;\n"
"        cpBezier[9] = outpt[9].v;\n"
"        cpBezier[10] = outpt[10].v;\n"
"        cpBezier[11] = outpt[11].v;\n"
"        cpBezier[12] = outpt[12].v;\n"
"        cpBezier[13] = outpt[13].v;\n"
"        cpBezier[14] = outpt[14].v;\n"
"        cpBezier[15] = outpt[15].v;\n"
"\n"
"        OsdEvalPatchBezierTessLevels(cpBezier, patchParam,\n"
"                         tessLevelOuter, tessLevelInner,\n"
"                         tessOuterLo, tessOuterHi);\n"
"#else\n"
"        OsdGetTessLevelsUniform(patchParam, tessLevelOuter, tessLevelInner,\n"
"                         tessOuterLo, tessOuterHi);\n"
"#endif\n"
"\n"
"        gl_TessLevelOuter[0] = tessLevelOuter[0];\n"
"        gl_TessLevelOuter[1] = tessLevelOuter[1];\n"
"        gl_TessLevelOuter[2] = tessLevelOuter[2];\n"
"        gl_TessLevelOuter[3] = tessLevelOuter[3];\n"
"\n"
"        gl_TessLevelInner[0] = tessLevelInner[0];\n"
"        gl_TessLevelInner[1] = tessLevelInner[1];\n"
"    }\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessEvalBSpline\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_TESS_EVAL_BSPLINE_SHADER\n"
"\n"
"layout(quads) in;\n"
"layout(OSD_SPACING) in;\n"
"\n"
"patch in vec4 tessOuterLo, tessOuterHi;\n"
"\n"
"in block {\n"
"    OsdPerPatchVertexBezier v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} inpt[];\n"
"\n"
"out block {\n"
"    OutputVertex v;\n"
"#if defined OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    vec2 vSegments;\n"
"#endif\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt;\n"
"\n"
"void main()\n"
"{\n"
"    vec3 P = vec3(0), dPu = vec3(0), dPv = vec3(0);\n"
"    vec3 N = vec3(0), dNu = vec3(0), dNv = vec3(0);\n"
"\n"
"    OsdPerPatchVertexBezier cv[16];\n"
"    for (int i = 0; i < 16; ++i) {\n"
"        cv[i] = inpt[i].v;\n"
"    }\n"
"\n"
"    vec2 UV = OsdGetTessParameterization(gl_TessCoord.xy,\n"
"                                         tessOuterLo,\n"
"                                         tessOuterHi);\n"
"\n"
"    ivec3 patchParam = inpt[0].v.patchParam;\n"
"    OsdEvalPatchBezier(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);\n"
"\n"
"    // all code below here is client code\n"
"    outpt.v.position = OsdModelViewMatrix() * vec4(P, 1.0f);\n"
"    outpt.v.normal = (OsdModelViewMatrix() * vec4(N, 0.0f)).xyz;\n"
"    outpt.v.tangent = (OsdModelViewMatrix() * vec4(dPu, 0.0f)).xyz;\n"
"    outpt.v.bitangent = (OsdModelViewMatrix() * vec4(dPv, 0.0f)).xyz;\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    outpt.v.Nu = dNu;\n"
"    outpt.v.Nv = dNv;\n"
"#endif\n"
"#if defined OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    outpt.vSegments = cv[0].vSegments;\n"
"#endif\n"
"\n"
"    outpt.v.tessCoord = UV;\n"
"    outpt.v.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);\n"
"\n"
"    OSD_USER_VARYING_PER_EVAL_POINT(UV, 5, 6, 9, 10);\n"
"\n"
"    OSD_DISPLACEMENT_CALLBACK;\n"
"\n"
"    gl_Position = OsdProjectionMatrix() * outpt.v.position;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;
static const char *gregoryShaderSource =
"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.VertexGregory\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_VERTEX_GREGORY_SHADER\n"
"\n"
"layout (location=0) in vec4 position;\n"
"OSD_USER_VARYING_ATTRIBUTE_DECLARE\n"
"\n"
"out block {\n"
"    OsdPerVertexGregory v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt;\n"
"\n"
"void main()\n"
"{\n"
"    OsdComputePerVertexGregory(gl_VertexID, position.xyz, outpt.v);\n"
"    OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(position);\n"
"    OSD_USER_VARYING_PER_VERTEX();\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessControlGregory\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_TESS_CONTROL_GREGORY_SHADER\n"
"\n"
"patch out vec4 tessOuterLo, tessOuterHi;\n"
"\n"
"in block {\n"
"    OsdPerVertexGregory v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} inpt[];\n"
"\n"
"out block {\n"
"    OsdPerPatchVertexGregory v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt[4];\n"
"\n"
"layout(vertices = 4) out;\n"
"\n"
"void main()\n"
"{\n"
"    OsdPerVertexGregory cv[4];\n"
"    for (int i=0; i<4; ++i) {\n"
"        cv[i] = inpt[i].v;\n"
"    }\n"
"\n"
"    ivec3 patchParam = OsdGetPatchParam(OsdGetPatchIndex(gl_PrimitiveID));\n"
"    OsdComputePerPatchVertexGregory(patchParam, gl_InvocationID, gl_PrimitiveID, cv, outpt[gl_InvocationID].v);\n"
"\n"
"    OSD_USER_VARYING_PER_CONTROL_POINT(gl_InvocationID, gl_InvocationID);\n"
"\n"
"#if defined OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    // Wait for all basis conversion to be finished\n"
"    barrier();\n"
"#endif\n"
"    if (gl_InvocationID == 0) {\n"
"        vec4 tessLevelOuter = vec4(0);\n"
"        vec2 tessLevelInner = vec2(0);\n"
"\n"
"        OSD_PATCH_CULL(4);\n"
"\n"
"#if defined OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"        // Gather bezier control points to compute limit surface tess levels\n"
"        OsdPerPatchVertexBezier bezcv[16];\n"
"        bezcv[ 0].P = outpt[0].v.P;\n"
"        bezcv[ 1].P = outpt[0].v.Ep;\n"
"        bezcv[ 2].P = outpt[1].v.Em;\n"
"        bezcv[ 3].P = outpt[1].v.P;\n"
"        bezcv[ 4].P = outpt[0].v.Em;\n"
"        bezcv[ 5].P = outpt[0].v.Fp;\n"
"        bezcv[ 6].P = outpt[1].v.Fm;\n"
"        bezcv[ 7].P = outpt[1].v.Ep;\n"
"        bezcv[ 8].P = outpt[3].v.Ep;\n"
"        bezcv[ 9].P = outpt[3].v.Fm;\n"
"        bezcv[10].P = outpt[2].v.Fp;\n"
"        bezcv[11].P = outpt[2].v.Em;\n"
"        bezcv[12].P = outpt[3].v.P;\n"
"        bezcv[13].P = outpt[3].v.Em;\n"
"        bezcv[14].P = outpt[2].v.Ep;\n"
"        bezcv[15].P = outpt[2].v.P;\n"
"\n"
"        OsdEvalPatchBezierTessLevels(bezcv, patchParam,\n"
"                                     tessLevelOuter, tessLevelInner,\n"
"                                     tessOuterLo, tessOuterHi);\n"
"#else\n"
"        OsdGetTessLevelsUniform(patchParam, tessLevelOuter, tessLevelInner,\n"
"                         tessOuterLo, tessOuterHi);\n"
"#endif\n"
"\n"
"        gl_TessLevelOuter[0] = tessLevelOuter[0];\n"
"        gl_TessLevelOuter[1] = tessLevelOuter[1];\n"
"        gl_TessLevelOuter[2] = tessLevelOuter[2];\n"
"        gl_TessLevelOuter[3] = tessLevelOuter[3];\n"
"\n"
"        gl_TessLevelInner[0] = tessLevelInner[0];\n"
"        gl_TessLevelInner[1] = tessLevelInner[1];\n"
"    }\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessEvalGregory\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_TESS_EVAL_GREGORY_SHADER\n"
"\n"
"layout(quads) in;\n"
"layout(OSD_SPACING) in;\n"
"\n"
"patch in vec4 tessOuterLo, tessOuterHi;\n"
"\n"
"in block {\n"
"    OsdPerPatchVertexGregory v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} inpt[];\n"
"\n"
"out block {\n"
"    OutputVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt;\n"
"\n"
"void main()\n"
"{\n"
"    vec3 P = vec3(0), dPu = vec3(0), dPv = vec3(0);\n"
"    vec3 N = vec3(0), dNu = vec3(0), dNv = vec3(0);\n"
"\n"
"    vec3 cv[20];\n"
"    cv[0] = inpt[0].v.P;\n"
"    cv[1] = inpt[0].v.Ep;\n"
"    cv[2] = inpt[0].v.Em;\n"
"    cv[3] = inpt[0].v.Fp;\n"
"    cv[4] = inpt[0].v.Fm;\n"
"\n"
"    cv[5] = inpt[1].v.P;\n"
"    cv[6] = inpt[1].v.Ep;\n"
"    cv[7] = inpt[1].v.Em;\n"
"    cv[8] = inpt[1].v.Fp;\n"
"    cv[9] = inpt[1].v.Fm;\n"
"\n"
"    cv[10] = inpt[2].v.P;\n"
"    cv[11] = inpt[2].v.Ep;\n"
"    cv[12] = inpt[2].v.Em;\n"
"    cv[13] = inpt[2].v.Fp;\n"
"    cv[14] = inpt[2].v.Fm;\n"
"\n"
"    cv[15] = inpt[3].v.P;\n"
"    cv[16] = inpt[3].v.Ep;\n"
"    cv[17] = inpt[3].v.Em;\n"
"    cv[18] = inpt[3].v.Fp;\n"
"    cv[19] = inpt[3].v.Fm;\n"
"\n"
"    vec2 UV = OsdGetTessParameterization(gl_TessCoord.xy,\n"
"                                         tessOuterLo,\n"
"                                         tessOuterHi);\n"
"\n"
"    ivec3 patchParam = inpt[0].v.patchParam;\n"
"    OsdEvalPatchGregory(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);\n"
"\n"
"    // all code below here is client code\n"
"    outpt.v.position = OsdModelViewMatrix() * vec4(P, 1.0f);\n"
"    outpt.v.normal = (OsdModelViewMatrix() * vec4(N, 0.0f)).xyz;\n"
"    outpt.v.tangent = (OsdModelViewMatrix() * vec4(dPu, 0.0f)).xyz;\n"
"    outpt.v.bitangent = (OsdModelViewMatrix() * vec4(dPv, 0.0f)).xyz;\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    outpt.v.Nu = dNu;\n"
"    outpt.v.Nv = dNv;\n"
"#endif\n"
"\n"
"    outpt.v.tessCoord = UV;\n"
"    outpt.v.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);\n"
"\n"
"    OSD_USER_VARYING_PER_EVAL_POINT(UV, 0, 1, 3, 2);\n"
"\n"
"    OSD_DISPLACEMENT_CALLBACK;\n"
"\n"
"    gl_Position = OsdProjectionMatrix() * outpt.v.position;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;
static const char *gregoryBasisShaderSource =
"//\n"
"//   Copyright 2015 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.VertexGregoryBasis\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_VERTEX_GREGORY_BASIS_SHADER\n"
"\n"
"layout(location = 0) in vec4 position;\n"
"OSD_USER_VARYING_ATTRIBUTE_DECLARE\n"
"\n"
"out block {\n"
"    ControlVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt;\n"
"\n"
"void main()\n"
"{\n"
"    outpt.v.position = position;\n"
"    OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(position);\n"
"    OSD_USER_VARYING_PER_VERTEX();\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessControlGregoryBasis\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_TESS_CONTROL_GREGORY_BASIS_SHADER\n"
"\n"
"patch out vec4 tessOuterLo, tessOuterHi;\n"
"\n"
"in block {\n"
"    ControlVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} inpt[];\n"
"\n"
"out block {\n"
"    OsdPerPatchVertexGregoryBasis v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt[20];\n"
"\n"
"layout(vertices = 20) out;\n"
"\n"
"void main()\n"
"{\n"
"    vec3 cv = inpt[gl_InvocationID].v.position.xyz;\n"
"\n"
"    ivec3 patchParam = OsdGetPatchParam(OsdGetPatchIndex(gl_PrimitiveID));\n"
"    OsdComputePerPatchVertexGregoryBasis(\n"
"        patchParam, gl_InvocationID, cv, outpt[gl_InvocationID].v);\n"
"\n"
"    OSD_USER_VARYING_PER_CONTROL_POINT(gl_InvocationID, gl_InvocationID);\n"
"\n"
"    if (gl_InvocationID == 0) {\n"
"        vec4 tessLevelOuter = vec4(0);\n"
"        vec2 tessLevelInner = vec2(0);\n"
"\n"
"        OSD_PATCH_CULL(20);\n"
"\n"
"#if defined OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"        // Gather bezier control points to compute limit surface tess levels\n"
"        OsdPerPatchVertexBezier bezcv[16];\n"
"        bezcv[ 0].P = inpt[ 0].v.position.xyz;\n"
"        bezcv[ 1].P = inpt[ 1].v.position.xyz;\n"
"        bezcv[ 2].P = inpt[ 7].v.position.xyz;\n"
"        bezcv[ 3].P = inpt[ 5].v.position.xyz;\n"
"        bezcv[ 4].P = inpt[ 2].v.position.xyz;\n"
"        bezcv[ 5].P = inpt[ 3].v.position.xyz;\n"
"        bezcv[ 6].P = inpt[ 8].v.position.xyz;\n"
"        bezcv[ 7].P = inpt[ 6].v.position.xyz;\n"
"        bezcv[ 8].P = inpt[16].v.position.xyz;\n"
"        bezcv[ 9].P = inpt[18].v.position.xyz;\n"
"        bezcv[10].P = inpt[13].v.position.xyz;\n"
"        bezcv[11].P = inpt[12].v.position.xyz;\n"
"        bezcv[12].P = inpt[15].v.position.xyz;\n"
"        bezcv[13].P = inpt[17].v.position.xyz;\n"
"        bezcv[14].P = inpt[11].v.position.xyz;\n"
"        bezcv[15].P = inpt[10].v.position.xyz;\n"
"\n"
"        OsdEvalPatchBezierTessLevels(\n"
"                bezcv, patchParam,\n"
"                tessLevelOuter, tessLevelInner,\n"
"                tessOuterLo, tessOuterHi);\n"
"#else\n"
"        OsdGetTessLevelsUniform(\n"
"                patchParam,\n"
"                tessLevelOuter, tessLevelInner,\n"
"                tessOuterLo, tessOuterHi);\n"
"#endif\n"
"\n"
"        gl_TessLevelOuter[0] = tessLevelOuter[0];\n"
"        gl_TessLevelOuter[1] = tessLevelOuter[1];\n"
"        gl_TessLevelOuter[2] = tessLevelOuter[2];\n"
"        gl_TessLevelOuter[3] = tessLevelOuter[3];\n"
"\n"
"        gl_TessLevelInner[0] = tessLevelInner[0];\n"
"        gl_TessLevelInner[1] = tessLevelInner[1];\n"
"    }\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessEvalGregoryBasis\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_TESS_EVAL_GREGORY_BASIS_SHADER\n"
"\n"
"layout(quads) in;\n"
"layout(OSD_SPACING) in;\n"
"\n"
"patch in vec4 tessOuterLo, tessOuterHi;\n"
"\n"
"in block {\n"
"    OsdPerPatchVertexGregoryBasis v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} inpt[];\n"
"\n"
"out block {\n"
"    OutputVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt;\n"
"\n"
"void main()\n"
"{\n"
"    vec3 P = vec3(0), dPu = vec3(0), dPv = vec3(0);\n"
"    vec3 N = vec3(0), dNu = vec3(0), dNv = vec3(0);\n"
"\n"
"    vec3 cv[20];\n"
"    for (int i = 0; i < 20; ++i) {\n"
"        cv[i] = inpt[i].v.P;\n"
"    }\n"
"\n"
"    vec2 UV = OsdGetTessParameterization(gl_TessCoord.xy,\n"
"                                         tessOuterLo,\n"
"                                         tessOuterHi);\n"
"\n"
"    ivec3 patchParam = inpt[0].v.patchParam;\n"
"    OsdEvalPatchGregory(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);\n"
"\n"
"    // all code below here is client code\n"
"    outpt.v.position = OsdModelViewMatrix() * vec4(P, 1.0f);\n"
"    outpt.v.normal = (OsdModelViewMatrix() * vec4(N, 0.0f)).xyz;\n"
"    outpt.v.tangent = (OsdModelViewMatrix() * vec4(dPu, 0.0f)).xyz;\n"
"    outpt.v.bitangent = (OsdModelViewMatrix() * vec4(dPv, 0.0f)).xyz;\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    outpt.v.Nu = dNu;\n"
"    outpt.v.Nv = dNv;\n"
"#endif\n"
"\n"
"    outpt.v.tessCoord = UV;\n"
"    outpt.v.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);\n"
"\n"
"    OSD_USER_VARYING_PER_EVAL_POINT(UV, 0, 5, 15, 10);\n"
"\n"
"    OSD_DISPLACEMENT_CALLBACK;\n"
"\n"
"    gl_Position = OsdProjectionMatrix() * outpt.v.position;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;
static const char *gregoryTriangleShaderSource =
"//\n"
"//   Copyright 2018 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.VertexGregoryTriangle\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_VERTEX_GREGORY_TRIANGLE_SHADER\n"
"\n"
"layout(location = 0) in vec4 position;\n"
"OSD_USER_VARYING_ATTRIBUTE_DECLARE\n"
"\n"
"out block {\n"
"    ControlVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt;\n"
"\n"
"void main()\n"
"{\n"
"    outpt.v.position = position;\n"
"    OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(position);\n"
"    OSD_USER_VARYING_PER_VERTEX();\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessControlGregoryTriangle\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_TESS_CONTROL_GREGORY_TRIANGLE_SHADER\n"
"\n"
"patch out vec4 tessOuterLo, tessOuterHi;\n"
"\n"
"in block {\n"
"    ControlVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} inpt[];\n"
"\n"
"out block {\n"
"    OsdPerPatchVertexGregoryBasis v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt[18];\n"
"\n"
"layout(vertices = 18) out;\n"
"\n"
"void main()\n"
"{\n"
"    vec3 cv = inpt[gl_InvocationID].v.position.xyz;\n"
"\n"
"    ivec3 patchParam = OsdGetPatchParam(OsdGetPatchIndex(gl_PrimitiveID));\n"
"    OsdComputePerPatchVertexGregoryBasis(\n"
"        patchParam, gl_InvocationID, cv, outpt[gl_InvocationID].v);\n"
"\n"
"    OSD_USER_VARYING_PER_CONTROL_POINT(gl_InvocationID, gl_InvocationID);\n"
"\n"
"    if (gl_InvocationID == 0) {\n"
"        vec4 tessLevelOuter = vec4(0);\n"
"        vec2 tessLevelInner = vec2(0);\n"
"\n"
"        OSD_PATCH_CULL(18);\n"
"\n"
"#if defined OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"        // Gather bezier control points to compute limit surface tess levels\n"
"        vec3 cv[15];\n"
"        cv[ 0] = inpt[ 0].v.position.xyz;\n"
"        cv[ 1] = inpt[ 1].v.position.xyz;\n"
"        cv[ 2] = inpt[15].v.position.xyz;\n"
"        cv[ 3] = inpt[ 7].v.position.xyz;\n"
"        cv[ 4] = inpt[ 5].v.position.xyz;\n"
"        cv[ 5] = inpt[ 2].v.position.xyz;\n"
"        cv[ 6] = inpt[ 3].v.position.xyz;\n"
"        cv[ 7] = inpt[ 8].v.position.xyz;\n"
"        cv[ 8] = inpt[ 6].v.position.xyz;\n"
"        cv[ 9] = inpt[17].v.position.xyz;\n"
"        cv[10] = inpt[13].v.position.xyz;\n"
"        cv[11] = inpt[16].v.position.xyz;\n"
"        cv[12] = inpt[11].v.position.xyz;\n"
"        cv[13] = inpt[12].v.position.xyz;\n"
"        cv[14] = inpt[10].v.position.xyz;\n"
"\n"
"        OsdEvalPatchBezierTriangleTessLevels(\n"
"                cv, patchParam,\n"
"                tessLevelOuter, tessLevelInner,\n"
"                tessOuterLo, tessOuterHi);\n"
"#else\n"
"        OsdGetTessLevelsUniformTriangle(\n"
"                patchParam,\n"
"                tessLevelOuter, tessLevelInner,\n"
"                tessOuterLo, tessOuterHi);\n"
"#endif\n"
"\n"
"        gl_TessLevelOuter[0] = tessLevelOuter[0];\n"
"        gl_TessLevelOuter[1] = tessLevelOuter[1];\n"
"        gl_TessLevelOuter[2] = tessLevelOuter[2];\n"
"\n"
"        gl_TessLevelInner[0] = tessLevelInner[0];\n"
"    }\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessEvalGregoryTriangle\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_TESS_EVAL_GREGORY_TRIANGLE_SHADER\n"
"\n"
"layout(triangles) in;\n"
"layout(OSD_SPACING) in;\n"
"\n"
"patch in vec4 tessOuterLo, tessOuterHi;\n"
"\n"
"in block {\n"
"    OsdPerPatchVertexGregoryBasis v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} inpt[];\n"
"\n"
"out block {\n"
"    OutputVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt;\n"
"\n"
"void main()\n"
"{\n"
"    vec3 P = vec3(0), dPu = vec3(0), dPv = vec3(0);\n"
"    vec3 N = vec3(0), dNu = vec3(0), dNv = vec3(0);\n"
"\n"
"    vec3 cv[18];\n"
"    for (int i = 0; i < 18; ++i) {\n"
"        cv[i] = inpt[i].v.P;\n"
"    }\n"
"\n"
"    vec2 UV = OsdGetTessParameterizationTriangle(gl_TessCoord.xyz,\n"
"                                                 tessOuterLo,\n"
"                                                 tessOuterHi);\n"
"\n"
"    ivec3 patchParam = inpt[0].v.patchParam;\n"
"    OsdEvalPatchGregoryTriangle(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);\n"
"\n"
"    // all code below here is client code\n"
"    outpt.v.position = OsdModelViewMatrix() * vec4(P, 1.0f);\n"
"    outpt.v.normal = (OsdModelViewMatrix() * vec4(N, 0.0f)).xyz;\n"
"    outpt.v.tangent = (OsdModelViewMatrix() * vec4(dPu, 0.0f)).xyz;\n"
"    outpt.v.bitangent = (OsdModelViewMatrix() * vec4(dPv, 0.0f)).xyz;\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    outpt.v.Nu = dNu;\n"
"    outpt.v.Nv = dNv;\n"
"#endif\n"
"\n"
"    outpt.v.tessCoord = UV;\n"
"    outpt.v.patchCoord = OsdInterpolatePatchCoordTriangle(UV, patchParam);\n"
"\n"
"    OSD_USER_VARYING_PER_EVAL_POINT_TRIANGLE(UV, 0, 5, 10);\n"
"\n"
"    OSD_DISPLACEMENT_CALLBACK;\n"
"\n"
"    gl_Position = OsdProjectionMatrix() * outpt.v.position;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;

/*static*/
std::string GLSLPatchShaderSource::GetPatchDrawingShaderSource() {
  std::stringstream ss;
  ss << std::string(commonShaderSource);
  ss << std::string(commonTessShaderSource);
  return ss.str();
}

/*static*/
std::string GLSLPatchShaderSource::GetCommonShaderSource() {
  std::stringstream ss;
  ss << GetPatchDrawingShaderSource();
  ss << std::string(patchLegacyShaderSource);
  return ss.str();
}

/*static*/
std::string GLSLPatchShaderSource::GetPatchBasisShaderSource() {
  std::stringstream ss;
#if defined(OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES)
  ss << "#define OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES\n";
#endif
  ss << std::string(patchBasisTypesShaderSource);
  ss << std::string(patchBasisShaderSource);
  return ss.str();
}

/*static*/
std::string
GLSLPatchShaderSource::GetVertexShaderSource(Far::PatchDescriptor::Type type) {
  std::stringstream ss;
  switch (type) {
  case Far::PatchDescriptor::REGULAR:
    ss << "#define OSD_PATCH_BSPLINE\n"
       << "#define OSD_PATCH_VERTEX_BSPLINE_SHADER\n"
       << bsplineShaderSource;
    break;
  case Far::PatchDescriptor::LOOP:
    ss << "#define OSD_PATCH_BOX_SPLINE_TRIANGLE\n"
       << "#define OSD_PATCH_VERTEX_BOX_SPLINE_TRIANGLE_SHADER\n"
       << boxSplineTriangleShaderSource;
    break;
  case Far::PatchDescriptor::GREGORY:
    ss << "#define OSD_PATCH_GREGORY\n"
       << "#define OSD_PATCH_VERTEX_GREGORY_SHADER\n"
       << gregoryShaderSource;
    break;
  case Far::PatchDescriptor::GREGORY_BOUNDARY:
    ss << "#define OSD_PATCH_GREGORY_BOUNDARY\n"
       << "#define OSD_PATCH_VERTEX_GREGORY_SHADER\n"
       << gregoryShaderSource;
    break;
  case Far::PatchDescriptor::GREGORY_BASIS:
    ss << "#define OSD_PATCH_GREGORY_BASIS\n"
       << "#define OSD_PATCH_VERTEX_GREGORY_BASIS_SHADER\n"
       << gregoryBasisShaderSource;
    break;
  case Far::PatchDescriptor::GREGORY_TRIANGLE:
    ss << "#define OSD_PATCH_GREGORY_TRIANGLE\n"
       << "#define OSD_PATCH_VERTEX_GREGORY_TRIANGLE_SHADER\n"
       << gregoryTriangleShaderSource;
    break;
  default:
    break; // returns empty (points, lines, quads, ...)
  }
  return ss.str();
}

/*static*/
std::string GLSLPatchShaderSource::GetTessControlShaderSource(
    Far::PatchDescriptor::Type type) {
  std::stringstream ss;
  switch (type) {
  case Far::PatchDescriptor::REGULAR:
    ss << "#define OSD_PATCH_BSPLINE\n"
       << "#define OSD_PATCH_TESS_CONTROL_BSPLINE_SHADER\n"
       << bsplineShaderSource;
    break;
  case Far::PatchDescriptor::LOOP:
    ss << "#define OSD_PATCH_BOX_SPLINE_TRIANGLE\n"
       << "#define OSD_PATCH_TESS_CONTROL_BOX_SPLINE_TRIANGLE_SHADER\n"
       << boxSplineTriangleShaderSource;
    break;
  case Far::PatchDescriptor::GREGORY:
    ss << "#define OSD_PATCH_GREGORY\n"
       << "#define OSD_PATCH_TESS_CONTROL_GREGORY_SHADER\n"
       << gregoryShaderSource;
    break;
  case Far::PatchDescriptor::GREGORY_BOUNDARY:
    ss << "#define OSD_PATCH_GREGORY_BOUNDARY\n"
       << "#define OSD_PATCH_TESS_CONTROL_GREGORY_SHADER\n"
       << gregoryShaderSource;
    break;
  case Far::PatchDescriptor::GREGORY_BASIS:
    ss << "#define OSD_PATCH_GREGORY_BASIS\n"
       << "#define OSD_PATCH_TESS_CONTROL_GREGORY_BASIS_SHADER\n"
       << gregoryBasisShaderSource;
    break;
  case Far::PatchDescriptor::GREGORY_TRIANGLE:
    ss << "#define OSD_PATCH_GREGORY_TRIANGLE\n"
       << "#define OSD_PATCH_TESS_CONTROL_GREGORY_TRIANGLE_SHADER\n"
       << gregoryTriangleShaderSource;
    break;
  default:
    break; // returns empty (points, lines, quads, ...)
  }
  return ss.str();
}

/*static*/
std::string GLSLPatchShaderSource::GetTessEvalShaderSource(
    Far::PatchDescriptor::Type type) {
  std::stringstream ss;
  switch (type) {
  case Far::PatchDescriptor::REGULAR:
    ss << "#define OSD_PATCH_BSPLINE\n"
       << "#define OSD_PATCH_TESS_EVAL_BSPLINE_SHADER\n"
       << bsplineShaderSource;
    break;
  case Far::PatchDescriptor::LOOP:
    ss << "#define OSD_PATCH_BOX_SPLINE_TRIANGLE\n"
       << "#define OSD_PATCH_TESS_EVAL_BOX_SPLINE_TRIANGLE_SHADER\n"
       << boxSplineTriangleShaderSource;
    break;
  case Far::PatchDescriptor::GREGORY:
    ss << "#define OSD_PATCH_GREGORY\n"
       << "#define OSD_PATCH_TESS_EVAL_GREGORY_SHADER\n"
       << gregoryShaderSource;
    break;
  case Far::PatchDescriptor::GREGORY_BOUNDARY:
    ss << "#define OSD_PATCH_GREGORY_BOUNDARY\n"
       << "#define OSD_PATCH_TESS_EVAL_GREGORY_SHADER\n"
       << gregoryShaderSource;
    break;
  case Far::PatchDescriptor::GREGORY_BASIS:
    ss << "#define OSD_PATCH_GREGORY_BASIS\n"
       << "#define OSD_PATCH_TESS_EVAL_GREGORY_BASIS_SHADER\n"
       << gregoryBasisShaderSource;
    break;
  case Far::PatchDescriptor::GREGORY_TRIANGLE:
    ss << "#define OSD_PATCH_GREGORY_TRIANGLE\n"
       << "#define OSD_PATCH_TESS_EVAL_GREGORY_TRIANGLE_SHADER\n"
       << gregoryTriangleShaderSource;
    break;
  default:
    break; // returns empty (points, lines, quads, ...)
  }
  return ss.str();
}

} // end namespace Osd

} // end namespace OPENSUBDIV_VERSION
} // end namespace OpenSubdiv
