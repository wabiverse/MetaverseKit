//
//   Copyright 2013 Pixar
//
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//
//   You may obtain a copy of the Apache License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//

#include "OpenSubdiv/OSDAdaptiveError.h"
#include "OpenSubdiv/OSDSurfaceMTLPatchShaderSource.h"

#include <TargetConditionals.h>
#include <sstream>
#include <string>

namespace OpenSubdiv {
namespace OPENSUBDIV_VERSION {

namespace Osd {

static std::string commonShaderSource(
"#line 0 \"osd/mtlPatchCommon.metal\"\n"
"\n"
"//\n"
"//   Copyright 2015 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"#include <metal_stdlib>\n"
"\n"
"using namespace metal;\n"
"\n"
"// The following callback functions are used when evaluating tessellation\n"
"// rates and when using legacy patch drawing.\n"
"float4x4 OsdModelViewMatrix();\n"
"float4x4 OsdProjectionMatrix();\n"
"float OsdTessLevel();\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Patch Parameters\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"//\n"
"// Each patch has a corresponding patchParam. This is a set of three values\n"
"// specifying additional information about the patch:\n"
"//\n"
"//    faceId    -- topological face identifier (e.g. Ptex FaceId)\n"
"//    bitfield  -- refinement-level, non-quad, boundary, transition, uv-offset\n"
"//    sharpness -- crease sharpness for single-crease patches\n"
"//\n"
"\n"
"int OsdGetPatchFaceId(int3 patchParam)\n"
"{\n"
"    return (patchParam.x & 0xfffffff);\n"
"}\n"
"\n"
"int OsdGetPatchFaceLevel(int3 patchParam)\n"
"{\n"
"    return (1 << ((patchParam.y & 0xf) - ((patchParam.y >> 4) & 1)));\n"
"}\n"
"\n"
"int OsdGetPatchRefinementLevel(int3 patchParam)\n"
"{\n"
"    return (patchParam.y & 0xf);\n"
"}\n"
"\n"
"int OsdGetPatchBoundaryMask(int3 patchParam)\n"
"{\n"
"    return ((patchParam.y >> 7) & 0x1f);\n"
"}\n"
"\n"
"int OsdGetPatchTransitionMask(int3 patchParam)\n"
"{\n"
"    return ((patchParam.x >> 28) & 0xf);\n"
"}\n"
"\n"
"int2 OsdGetPatchFaceUV(int3 patchParam)\n"
"{\n"
"    int u = (patchParam.y >> 22) & 0x3ff;\n"
"    int v = (patchParam.y >> 12) & 0x3ff;\n"
"    return int2(u,v);\n"
"}\n"
"\n"
"bool OsdGetPatchIsRegular(int3 patchParam)\n"
"{\n"
"    return ((patchParam.y >> 5) & 0x1) != 0;\n"
"}\n"
"\n"
"bool OsdGetPatchIsTriangleRotated(int3 patchParam)\n"
"{\n"
"    int2 uv = OsdGetPatchFaceUV(patchParam);\n"
"    return (uv.x + uv.y) >= OsdGetPatchFaceLevel(patchParam);\n"
"}\n"
"\n"
"float OsdGetPatchSharpness(int3 patchParam)\n"
"{\n"
"    return as_type<float>(patchParam.z);\n"
"}\n"
"\n"
"float OsdGetPatchSingleCreaseSegmentParameter(int3 patchParam, float2 uv)\n"
"{\n"
"    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);\n"
"    float s = 0;\n"
"    if ((boundaryMask & 1) != 0) {\n"
"        s = 1 - uv.y;\n"
"    } else if ((boundaryMask & 2) != 0) {\n"
"        s = uv.x;\n"
"    } else if ((boundaryMask & 4) != 0) {\n"
"        s = uv.y;\n"
"    } else if ((boundaryMask & 8) != 0) {\n"
"        s = 1 - uv.x;\n"
"    }\n"
"    return s;\n"
"}\n"
"\n"
"int4 OsdGetPatchCoord(int3 patchParam)\n"
"{\n"
"    int faceId = OsdGetPatchFaceId(patchParam);\n"
"    int faceLevel = OsdGetPatchFaceLevel(patchParam);\n"
"    int2 faceUV = OsdGetPatchFaceUV(patchParam);\n"
"    return int4(faceUV.x, faceUV.y, faceLevel, faceId);\n"
"}\n"
"\n"
"float4 OsdInterpolatePatchCoord(float2 localUV, int3 patchParam)\n"
"{\n"
"    int4 perPrimPatchCoord = OsdGetPatchCoord(patchParam);\n"
"    int faceId = perPrimPatchCoord.w;\n"
"    int faceLevel = perPrimPatchCoord.z;\n"
"    float2 faceUV = float2(perPrimPatchCoord.x, perPrimPatchCoord.y);\n"
"    float2 uv = localUV/faceLevel + faceUV/faceLevel;\n"
"    // add 0.5 to integer values for more robust interpolation\n"
"    return float4(uv.x, uv.y, faceLevel+0.5, faceId+0.5);\n"
"}\n"
"\n"
"float4 OsdInterpolatePatchCoordTriangle(float2 localUV, int3 patchParam)\n"
"{\n"
"    float4 result = OsdInterpolatePatchCoord(localUV, patchParam);\n"
"    if (OsdGetPatchIsTriangleRotated(patchParam)) {\n"
"        result.xy = float2(1.0f, 1.0f) - result.xy;\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"void\n"
"OsdUnivar4x4(float u, thread float* B)\n"
"{\n"
"    float t = u;\n"
"    float s = 1.0f - u;\n"
"\n"
"    float A0 = s * s;\n"
"    float A1 = 2 * s * t;\n"
"    float A2 = t * t;\n"
"\n"
"    B[0] = s * A0;\n"
"    B[1] = t * A0 + s * A1;\n"
"    B[2] = t * A1 + s * A2;\n"
"    B[3] = t * A2;\n"
"}\n"
"\n"
"void\n"
"OsdUnivar4x4(float u, thread float* B, thread float* D)\n"
"{\n"
"    float t = u;\n"
"    float s = 1.0f - u;\n"
"\n"
"    float A0 = s * s;\n"
"    float A1 = 2 * s * t;\n"
"    float A2 = t * t;\n"
"\n"
"    B[0] = s * A0;\n"
"    B[1] = t * A0 + s * A1;\n"
"    B[2] = t * A1 + s * A2;\n"
"    B[3] = t * A2;\n"
"\n"
"    D[0] =    - A0;\n"
"    D[1] = A0 - A1;\n"
"    D[2] = A1 - A2;\n"
"    D[3] = A2;\n"
"}\n"
"\n"
"void\n"
"OsdUnivar4x4(float u, thread float* B, thread float* D, thread float* C)\n"
"{\n"
"    float t = u;\n"
"    float s = 1.0f - u;\n"
"\n"
"    float A0 = s * s;\n"
"    float A1 = 2 * s * t;\n"
"    float A2 = t * t;\n"
"\n"
"    B[0] = s * A0;\n"
"    B[1] = t * A0 + s * A1;\n"
"    B[2] = t * A1 + s * A2;\n"
"    B[3] = t * A2;\n"
"\n"
"    D[0] =    - A0;\n"
"    D[1] = A0 - A1;\n"
"    D[2] = A1 - A2;\n"
"    D[3] = A2;\n"
"\n"
"    A0 =   - s;\n"
"    A1 = s - t;\n"
"    A2 = t;\n"
"\n"
"    C[0] =    - A0;\n"
"    C[1] = A0 - A1;\n"
"    C[2] = A1 - A2;\n"
"    C[3] = A2;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"struct OsdPerPatchVertexBezier {\n"
"    packed_float3 P;\n"
"#if OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    packed_float3 P1;\n"
"    packed_float3 P2;\n"
"#if !USE_PTVS_SHARPNESS\n"
"    float2 vSegments;\n"
"#endif\n"
"#endif\n"
"};\n"
"\n"
"float3\n"
"OsdEvalBezier(float3 cp[16], float2 uv)\n"
"{\n"
"    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};\n"
"\n"
"    float B[4], D[4];\n"
"\n"
"    OsdUnivar4x4(uv.x, B, D);\n"
"    for (int i=0; i<4; ++i) {\n"
"        for (int j=0; j<4; ++j) {\n"
"            float3 A = cp[4*i + j];\n"
"            BUCP[i] += A * B[j];\n"
"        }\n"
"    }\n"
"\n"
"    float3 P = float3(0,0,0);\n"
"\n"
"    OsdUnivar4x4(uv.y, B, D);\n"
"    for (int k=0; k<4; ++k) {\n"
"        P += B[k] * BUCP[k];\n"
"    }\n"
"\n"
"    return P;\n"
"}\n"
"\n"
"// When OSD_PATCH_ENABLE_SINGLE_CREASE is defined,\n"
"// this function evaluates single-crease patch, which is segmented into\n"
"// 3 parts in the v-direction.\n"
"//\n"
"//  v=0             vSegment.x        vSegment.y              v=1\n"
"//   +------------------+-------------------+------------------+\n"
"//   |       cp 0       |     cp 1          |      cp 2        |\n"
"//   | (infinite sharp) | (floor sharpness) | (ceil sharpness) |\n"
"//   +------------------+-------------------+------------------+\n"
"//\n"
"float3\n"
"OsdEvalBezier(device OsdPerPatchVertexBezier* cp, int3 patchParam, float2 uv)\n"
"{\n"
"    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};\n"
"\n"
"    float B[4], D[4];\n"
"    float s = OsdGetPatchSingleCreaseSegmentParameter(patchParam, uv);\n"
"\n"
"    OsdUnivar4x4(uv.x, B, D);\n"
"#if OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"#if USE_PTVS_SHARPNESS\n"
"    float sharpness = OsdGetPatchSharpness(patchParam);\n"
"    float Sf = floor(sharpness);\n"
"    float Sc = ceil(sharpness);\n"
"    float s0 = 1 - exp2(-Sf);\n"
"    float s1 = 1 - exp2(-Sc);\n"
"\n"
"    float2 vSegments(s0, s1);\n"
"#else\n"
"    float2 vSegments = cp[0].vSegments;\n"
"#endif // USE_PTVS_SHARPNESS\n"
"\n"
"    //By doing the offset calculation ahead of time it can be kept out of the actual indexing lookup.\n"
"\n"
"    if(s <= vSegments.x)\n"
"        cp = (device OsdPerPatchVertexBezier*)(((device float*)cp) + 0);\n"
"    else if( s <= vSegments.y)\n"
"        cp = (device OsdPerPatchVertexBezier*)(((device float*)cp) + 3);\n"
"    else\n"
"        cp = (device OsdPerPatchVertexBezier*)(((device float*)cp) + 6);\n"
"\n"
"    BUCP[0] += cp[0].P * B[0];\n"
"    BUCP[0] += cp[1].P * B[1];\n"
"    BUCP[0] += cp[2].P * B[2];\n"
"    BUCP[0] += cp[3].P * B[3];\n"
"\n"
"    BUCP[1] += cp[4].P * B[0];\n"
"    BUCP[1] += cp[5].P * B[1];\n"
"    BUCP[1] += cp[6].P * B[2];\n"
"    BUCP[1] += cp[7].P * B[3];\n"
"\n"
"    BUCP[2] += cp[8].P * B[0];\n"
"    BUCP[2] += cp[9].P * B[1];\n"
"    BUCP[2] += cp[10].P * B[2];\n"
"    BUCP[2] += cp[11].P * B[3];\n"
"\n"
"    BUCP[3] += cp[12].P * B[0];\n"
"    BUCP[3] += cp[13].P * B[1];\n"
"    BUCP[3] += cp[14].P * B[2];\n"
"    BUCP[3] += cp[15].P * B[3];\n"
"\n"
"#else // single crease\n"
"    for (int i=0; i<4; ++i) {\n"
"        for (int j=0; j<4; ++j) {\n"
"            float3 A = cp[4*i + j].P;\n"
"            BUCP[i] += A * B[j];\n"
"        }\n"
"    }\n"
"#endif  // single crease\n"
"\n"
"    OsdUnivar4x4(uv.y, B);\n"
"    float3 P = B[0] * BUCP[0];\n"
"    for (int k=1; k<4; ++k) {\n"
"        P += B[k] * BUCP[k];\n"
"    }\n"
"\n"
"    return P;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Boundary Interpolation\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"template<typename VertexType>\n"
"void\n"
"OsdComputeBSplineBoundaryPoints(threadgroup VertexType* cpt, int3 patchParam)\n"
"{\n"
"    //APPL TODO - multithread this\n"
"    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);\n"
"\n"
"    //  Don't extrapolate corner points until all boundary points in place\n"
"    if ((boundaryMask & 1) != 0) {\n"
"        cpt[1].SetPosition(2*cpt[5].GetPosition() - cpt[9].GetPosition());\n"
"        cpt[2].SetPosition(2*cpt[6].GetPosition() - cpt[10].GetPosition());\n"
"    }\n"
"    if ((boundaryMask & 2) != 0) {\n"
"        cpt[7].SetPosition(2*cpt[6].GetPosition() - cpt[5].GetPosition());\n"
"        cpt[11].SetPosition(2*cpt[10].GetPosition() - cpt[9].GetPosition());\n"
"    }\n"
"    if ((boundaryMask & 4) != 0) {\n"
"        cpt[13].SetPosition(2*cpt[9].GetPosition() - cpt[5].GetPosition());\n"
"        cpt[14].SetPosition(2*cpt[10].GetPosition() - cpt[6].GetPosition());\n"
"    }\n"
"    if ((boundaryMask & 8) != 0) {\n"
"        cpt[4].SetPosition(2*cpt[5].GetPosition() - cpt[6].GetPosition());\n"
"        cpt[8].SetPosition(2*cpt[9].GetPosition() - cpt[10].GetPosition());\n"
"    }\n"
"\n"
"    //  Now safe to extrapolate corner points:\n"
"    if ((boundaryMask & 1) != 0) {\n"
"        cpt[0].SetPosition(2*cpt[4].GetPosition() - cpt[8].GetPosition());\n"
"        cpt[3].SetPosition(2*cpt[7].GetPosition() - cpt[11].GetPosition());\n"
"    }\n"
"    if ((boundaryMask & 2) != 0) {\n"
"        cpt[3].SetPosition(2*cpt[2].GetPosition() - cpt[1].GetPosition());\n"
"        cpt[15].SetPosition(2*cpt[14].GetPosition() - cpt[13].GetPosition());\n"
"    }\n"
"    if ((boundaryMask & 4) != 0) {\n"
"        cpt[12].SetPosition(2*cpt[8].GetPosition() - cpt[4].GetPosition());\n"
"        cpt[15].SetPosition(2*cpt[11].GetPosition() - cpt[7].GetPosition());\n"
"    }\n"
"    if ((boundaryMask & 8) != 0) {\n"
"        cpt[0].SetPosition(2*cpt[1].GetPosition() - cpt[2].GetPosition());\n"
"        cpt[12].SetPosition(2*cpt[13].GetPosition() - cpt[14].GetPosition());\n"
"    }\n"
"}\n"
"\n"
"template<typename VertexType>\n"
"void\n"
"OsdComputeBoxSplineTriangleBoundaryPoints(thread VertexType* cpt, int3 patchParam)\n"
"{\n"
"    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);\n"
"    if (boundaryMask == 0) return;\n"
"\n"
"    int upperBits = (boundaryMask >> 3) & 0x3;\n"
"    int lowerBits = boundaryMask & 7;\n"
"\n"
"    int eBits = lowerBits;\n"
"    int vBits = 0;\n"
"\n"
"    if (upperBits == 1) {\n"
"        vBits = eBits;\n"
"        eBits = 0;\n"
"    } else if (upperBits == 2) {\n"
"        //  Opposite vertex bit is edge bit rotated one to the right:\n"
"        vBits = ((eBits & 1) << 2) | (eBits >> 1);\n"
"    }\n"
"\n"
"    bool edge0IsBoundary = (eBits & 1) != 0;\n"
"    bool edge1IsBoundary = (eBits & 2) != 0;\n"
"    bool edge2IsBoundary = (eBits & 4) != 0;\n"
"\n"
"    if (edge0IsBoundary) {\n"
"        if (edge2IsBoundary) {\n"
"            cpt[0].SetPosition(cpt[4].GetPosition() + (cpt[4].GetPosition() - cpt[8].GetPosition()));\n"
"        } else {\n"
"            cpt[0].SetPosition(cpt[4].GetPosition() + (cpt[3].GetPosition() - cpt[7].GetPosition()));\n"
"        }\n"
"        cpt[1].SetPosition(cpt[4].GetPosition() + cpt[5].GetPosition() - cpt[8].GetPosition());\n"
"        if (edge1IsBoundary) {\n"
"            cpt[2].SetPosition(cpt[5].GetPosition() + (cpt[5].GetPosition() - cpt[8].GetPosition()));\n"
"        } else {\n"
"            cpt[2].SetPosition(cpt[5].GetPosition() + (cpt[6].GetPosition() - cpt[9].GetPosition()));\n"
"        }\n"
"    }\n"
"    if (edge1IsBoundary) {\n"
"        if (edge0IsBoundary) {\n"
"            cpt[6].SetPosition(cpt[5].GetPosition() + (cpt[5].GetPosition() - cpt[4].GetPosition()));\n"
"        } else {\n"
"            cpt[6].SetPosition(cpt[5].GetPosition() + (cpt[2].GetPosition() - cpt[1].GetPosition()));\n"
"        }\n"
"        cpt[9].SetPosition(cpt[5].GetPosition() + cpt[8].GetPosition() - cpt[4].GetPosition());\n"
"        if (edge2IsBoundary) {\n"
"            cpt[11].SetPosition(cpt[8].GetPosition() + (cpt[8].GetPosition() - cpt[4].GetPosition()));\n"
"        } else {\n"
"            cpt[11].SetPosition(cpt[8].GetPosition() + (cpt[10].GetPosition() - cpt[7].GetPosition()));\n"
"        }\n"
"    }\n"
"    if (edge2IsBoundary) {\n"
"        if (edge1IsBoundary) {\n"
"            cpt[10].SetPosition(cpt[8].GetPosition() + (cpt[8].GetPosition() - cpt[5].GetPosition()));\n"
"        } else {\n"
"            cpt[10].SetPosition(cpt[8].GetPosition() + (cpt[11].GetPosition() - cpt[9].GetPosition()));\n"
"        }\n"
"        cpt[7].SetPosition(cpt[8].GetPosition() + cpt[4].GetPosition() - cpt[5].GetPosition());\n"
"        if (edge0IsBoundary) {\n"
"            cpt[3].SetPosition(cpt[4].GetPosition() + (cpt[4].GetPosition() - cpt[5].GetPosition()));\n"
"        } else {\n"
"            cpt[3].SetPosition(cpt[4].GetPosition() + (cpt[0].GetPosition() - cpt[1].GetPosition()));\n"
"        }\n"
"    }\n"
"\n"
"    if ((vBits & 1) != 0) {\n"
"        cpt[3].SetPosition(cpt[4].GetPosition() + cpt[7].GetPosition() - cpt[8].GetPosition());\n"
"        cpt[0].SetPosition(cpt[4].GetPosition() + cpt[1].GetPosition() - cpt[5].GetPosition());\n"
"    }\n"
"    if ((vBits & 2) != 0) {\n"
"        cpt[2].SetPosition(cpt[5].GetPosition() + cpt[1].GetPosition() - cpt[4].GetPosition());\n"
"        cpt[6].SetPosition(cpt[5].GetPosition() + cpt[9].GetPosition() - cpt[8].GetPosition());\n"
"    }\n"
"    if ((vBits & 4) != 0) {\n"
"        cpt[11].SetPosition(cpt[8].GetPosition() + cpt[9].GetPosition() - cpt[5].GetPosition());\n"
"        cpt[10].SetPosition(cpt[8].GetPosition() + cpt[7].GetPosition() - cpt[4].GetPosition());\n"
"    }\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// BSpline\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"// compute single-crease patch matrix\n"
"float4x4\n"
"OsdComputeMs(float sharpness)\n"
"{\n"
"    float s = exp2(sharpness);\n"
"    float s2 = s*s;\n"
"    float s3 = s2*s;\n"
"\n"
"    float4x4 m(\n"
"        float4(0, s + 1 + 3*s2 - s3, 7*s - 2 - 6*s2 + 2*s3, (1-s)*(s-1)*(s-1)),\n"
"        float4(0,       (1+s)*(1+s),        6*s - 2 - 2*s2,       (s-1)*(s-1)),\n"
"        float4(0,               1+s,               6*s - 2,               1-s),\n"
"        float4(0,                 1,               6*s - 2,                 1));\n"
"\n"
"    m[0] /= (s*6.0);\n"
"    m[1] /= (s*6.0);\n"
"    m[2] /= (s*6.0);\n"
"    m[3] /= (s*6.0);\n"
"\n"
"    m[0][0] = 1.0/6.0;\n"
"\n"
"    return m;\n"
"}\n"
"\n"
"float4x4\n"
"OsdComputeMs2(float sharpness, float factor)\n"
"{\n"
"    float s = exp2(sharpness);\n"
"    float s2 = s*s;\n"
"    float s3 = s2*s;\n"
"    float sx6 = s*6.0;\n"
"    float sx6m2 = sx6 - 2;\n"
"    float sfrac1 = 1-s;\n"
"    float ssub1 = s-1;\n"
"    float ssub1_2 = ssub1 * ssub1;\n"
"    float div6 = 1.0/6.0;\n"
"\n"
"    float4x4 m(\n"
"               float4(0, s + 1 + 3*s2 - s3, 7*s - 2 - 6*s2 + 2*s3,    sfrac1 * ssub1_2),\n"
"               float4(0,      1 + 2*s + s2,         sx6m2 - 2*s2,             ssub1_2),\n"
"               float4(0,               1+s,                sx6m2,              sfrac1),\n"
"               float4(0,                 1,                sx6m2,                 1));\n"
"\n"
"    m *= factor * (1/sx6);\n"
"\n"
"    m[0][0] = div6 * factor;\n"
"\n"
"    return m;\n"
"}\n"
"\n"
"// flip matrix orientation\n"
"void OsdFlipMatrix(threadgroup float * src, threadgroup float * dst)\n"
"{\n"
"    for (int i = 0; i < 16; i++) dst[i] = src[15-i];\n"
"}\n"
"\n"
"float4x4 OsdFlipMatrix(float4x4 m)\n"
"{\n"
"    return float4x4(float4(m[3][3], m[3][2], m[3][1], m[3][0]),\n"
"                    float4(m[2][3], m[2][2], m[2][1], m[2][0]),\n"
"                    float4(m[1][3], m[1][2], m[1][1], m[1][0]),\n"
"                    float4(m[0][3], m[0][2], m[0][1], m[0][0]));\n"
"}\n"
"\n"
"// Regular BSpline to Bezier\n"
"constant float4x4 Q(\n"
"                    float4(1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f),\n"
"                    float4(0.f,     4.f/6.f, 2.f/6.f, 0.f),\n"
"                    float4(0.f,     2.f/6.f, 4.f/6.f, 0.f),\n"
"                    float4(0.f,     1.f/6.f, 4.f/6.f, 1.f/6.f)\n"
"                    );\n"
"\n"
"// Infinitely Sharp (boundary)\n"
"constant float4x4 Mi(\n"
"                     float4(1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f),\n"
"                     float4(0.f,     4.f/6.f, 2.f/6.f, 0.f),\n"
"                     float4(0.f,     2.f/6.f, 4.f/6.f, 0.f),\n"
"                     float4(0.f,     0.f,     1.f,     0.f)\n"
"                     );\n"
"\n"
"// convert BSpline cv to Bezier cv\n"
"template<typename VertexType> //VertexType should be some type that implements float3 VertexType::GetPosition()\n"
"void\n"
"OsdComputePerPatchVertexBSpline(\n"
"        int3 patchParam, unsigned ID,\n"
"        threadgroup VertexType* cv,\n"
"        device OsdPerPatchVertexBezier& result)\n"
"{\n"
"    int i = ID%4;\n"
"    int j = ID/4;\n"
"\n"
"#if OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"\n"
"    float3 P  = float3(0,0,0); // 0 to 1-2^(-Sf)\n"
"    float3 P1 = float3(0,0,0); // 1-2^(-Sf) to 1-2^(-Sc)\n"
"    float3 P2 = float3(0,0,0); // 1-2^(-Sc) to 1\n"
"    float sharpness = OsdGetPatchSharpness(patchParam);\n"
"\n"
"    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);\n"
"\n"
"    if (sharpness > 0 && (boundaryMask & 15))\n"
"    {\n"
"        float Sf = floor(sharpness);\n"
"        float Sc = ceil(sharpness);\n"
"        float Sr = fract(sharpness);\n"
"\n"
"        float4x4 Mj = OsdComputeMs2(Sf, 1-Sr);\n"
"        float4x4 Ms = Mj;\n"
"        Mj += (Sr * Mi);\n"
"        Ms += OsdComputeMs2(Sc, Sr);\n"
"\n"
"#if USE_PTVS_SHARPNESS\n"
"#else\n"
"        float s0 = 1 - exp2(-Sf);\n"
"        float s1 = 1 - exp2(-Sc);\n"
"        result.vSegments = float2(s0, s1);\n"
"#endif\n"
"\n"
"        bool isBoundary[2];\n"
"        isBoundary[0] = (((boundaryMask & 8) != 0) || ((boundaryMask & 2) != 0)) ? true : false;\n"
"        isBoundary[1] = (((boundaryMask & 4) != 0) || ((boundaryMask & 1) != 0)) ? true : false;\n"
"        bool needsFlip[2];\n"
"        needsFlip[0] = (boundaryMask & 8) ? true : false;\n"
"        needsFlip[1] = (boundaryMask & 1) ? true : false;\n"
"        float3 Hi[4], Hj[4], Hs[4];\n"
"\n"
"        if (isBoundary[0])\n"
"        {\n"
"            int t[4] = {0,1,2,3};\n"
"            int ti = i, step = 1, start = 0;\n"
"            if (needsFlip[0]) {\n"
"                t[0] = 3; t[1] = 2; t[2] = 1; t[3] = 0;\n"
"                ti = 3-i;\n"
"                start = 3; step = -1;\n"
"            }\n"
"            for (int l=0; l<4; ++l) {\n"
"                Hi[l] = Hj[l] = Hs[l] = float3(0,0,0);\n"
"                for (int k=0, tk = start; k<4; ++k, tk+=step) {\n"
"                    float3 p = cv[l*4 + k].GetPosition();\n"
"                    Hi[l] += Mi[ti][tk] * p;\n"
"                    Hj[l] += Mj[ti][tk] * p;\n"
"                    Hs[l] += Ms[ti][tk] * p;\n"
"                }\n"
"            }\n"
"        }\n"
"        else\n"
"        {\n"
"            for (int l=0; l<4; ++l) {\n"
"                Hi[l] = Hj[l] = Hs[l] = float3(0,0,0);\n"
"                for (int k=0; k<4; ++k) {\n"
"                    float3 p = cv[l*4 + k].GetPosition();\n"
"                    float3 val = Q[i][k] * p;\n"
"                    Hi[l] += val;\n"
"                    Hj[l] += val;\n"
"                    Hs[l] += val;\n"
"                }\n"
"            }\n"
"        }\n"
"        {\n"
"            int t[4] = {0,1,2,3};\n"
"            int tj = j, step = 1, start = 0;\n"
"            if (needsFlip[1]) {\n"
"                t[0] = 3; t[1] = 2; t[2] = 1; t[3] = 0;\n"
"                tj = 3-j;\n"
"                start = 3; step = -1;\n"
"            }\n"
"            for (int k=0, tk = start; k<4; ++k, tk+=step) {\n"
"                if (isBoundary[1])\n"
"                {\n"
"                    P  += Mi[tj][tk]*Hi[k];\n"
"                    P1 += Mj[tj][tk]*Hj[k];\n"
"                    P2 += Ms[tj][tk]*Hs[k];\n"
"                }\n"
"                else\n"
"                {\n"
"                    P  += Q[j][k]*Hi[k];\n"
"                    P1 += Q[j][k]*Hj[k];\n"
"                    P2 += Q[j][k]*Hs[k];\n"
"                }\n"
"            }\n"
"        }\n"
"\n"
"    result.P  = P;\n"
"    result.P1 = P1;\n"
"    result.P2 = P2;\n"
"    } else {\n"
"#if USE_PTVS_SHARPNESS\n"
"#else\n"
"        result.vSegments = float2(0, 0);\n"
"#endif\n"
"\n"
"        OsdComputeBSplineBoundaryPoints(cv, patchParam);\n"
"\n"
"    float3 Hi[4];\n"
"    for (int l=0; l<4; ++l) {\n"
"        Hi[l] = float3(0,0,0);\n"
"        for (int k=0; k<4; ++k) {\n"
"            Hi[l] += Q[i][k] * cv[l*4 + k].GetPosition();\n"
"        }\n"
"    }\n"
"    for (int k=0; k<4; ++k) {\n"
"        P += Q[j][k]*Hi[k];\n"
"    }\n"
"\n"
"    result.P  = P;\n"
"    result.P1 = P;\n"
"    result.P2 = P;\n"
"}\n"
"#else\n"
"    OsdComputeBSplineBoundaryPoints(cv, patchParam);\n"
"\n"
"    float3 H[4];\n"
"    for (int l=0; l<4; ++l) {\n"
"        H[l] = float3(0,0,0);\n"
"        for(int k=0; k<4; ++k) {\n"
"            H[l] += Q[i][k] * (cv + l*4 + k)->GetPosition();\n"
"        }\n"
"    }\n"
"    {\n"
"        result.P = float3(0,0,0);\n"
"        for (int k=0; k<4; ++k){\n"
"            result.P += Q[j][k]*H[k];\n"
"        }\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"template<typename PerPatchVertexBezier>\n"
"void\n"
"OsdEvalPatchBezier(int3 patchParam, float2 UV,\n"
"                   PerPatchVertexBezier cv,\n"
"                   thread float3& P, thread float3& dPu, thread float3& dPv,\n"
"                   thread float3& N, thread float3& dNu, thread float3& dNv,\n"
"                   thread float2& vSegments)\n"
"{\n"
"    //\n"
"    //  Use the recursive nature of the basis functions to compute a 2x2 set\n"
"    //  of intermediate points (via repeated linear interpolation).  These\n"
"    //  points define a bilinear surface tangent to the desired surface at P\n"
"    //  and so containing dPu and dPv.  The cost of computing P, dPu and dPv\n"
"    //  this way is comparable to that of typical tensor product evaluation\n"
"    //  (if not faster).\n"
"    //\n"
"    //  If N = dPu X dPv degenerates, it often results from an edge of the\n"
"    //  2x2 bilinear hull collapsing or two adjacent edges colinear. In both\n"
"    //  cases, the expected non-planar quad degenerates into a triangle, and\n"
"    //  the tangent plane of that triangle provides the desired normal N.\n"
"    //\n"
"\n"
"    //  Reduce 4x4 points to 2x4 -- two levels of linear interpolation in U\n"
"    //  and so 3 original rows contributing to each of the 2 resulting rows:\n"
"    float u    = UV.x;\n"
"    float uinv = 1.0f - u;\n"
"\n"
"    float u0 = uinv * uinv;\n"
"    float u1 = u * uinv * 2.0f;\n"
"    float u2 = u * u;\n"
"\n"
"    float3 LROW[4], RROW[4];\n"
"#if OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"#if USE_PTVS_SHARPNESS\n"
"    float sharpness = OsdGetPatchSharpness(patchParam);\n"
"    float Sf = floor(sharpness);\n"
"    float Sc = ceil(sharpness);\n"
"    float s0 = 1 - exp2(-Sf);\n"
"    float s1 = 1 - exp2(-Sc);\n"
"    vSegments = float2(s0, s1);\n"
"#else // USE_PTVS_SHARPNESS\n"
"    vSegments = cv[0].vSegments;\n"
"#endif // USE_PTVS_SHARPNESS\n"
"    float s = OsdGetPatchSingleCreaseSegmentParameter(patchParam, UV);\n"
"\n"
"    for (int i = 0; i < 4; ++i) {\n"
"        int j = i*4;\n"
"        if (s <= vSegments.x) {\n"
"            LROW[i] = u0 * cv[ j ].P + u1 * cv[j+1].P + u2 * cv[j+2].P;\n"
"            RROW[i] = u0 * cv[j+1].P + u1 * cv[j+2].P + u2 * cv[j+3].P;\n"
"        } else if (s <= vSegments.y) {\n"
"            LROW[i] = u0 * cv[ j ].P1 + u1 * cv[j+1].P1 + u2 * cv[j+2].P1;\n"
"            RROW[i] = u0 * cv[j+1].P1 + u1 * cv[j+2].P1 + u2 * cv[j+3].P1;\n"
"        } else {\n"
"            LROW[i] = u0 * cv[ j ].P2 + u1 * cv[j+1].P2 + u2 * cv[j+2].P2;\n"
"            RROW[i] = u0 * cv[j+1].P2 + u1 * cv[j+2].P2 + u2 * cv[j+3].P2;\n"
"        }\n"
"    }\n"
"#else\n"
"    LROW[0] = u0 * cv[ 0].P + u1 * cv[ 1].P + u2 * cv[ 2].P;\n"
"    LROW[1] = u0 * cv[ 4].P + u1 * cv[ 5].P + u2 * cv[ 6].P;\n"
"    LROW[2] = u0 * cv[ 8].P + u1 * cv[ 9].P + u2 * cv[10].P;\n"
"    LROW[3] = u0 * cv[12].P + u1 * cv[13].P + u2 * cv[14].P;\n"
"\n"
"    RROW[0] = u0 * cv[ 1].P + u1 * cv[ 2].P + u2 * cv[ 3].P;\n"
"    RROW[1] = u0 * cv[ 5].P + u1 * cv[ 6].P + u2 * cv[ 7].P;\n"
"    RROW[2] = u0 * cv[ 9].P + u1 * cv[10].P + u2 * cv[11].P;\n"
"    RROW[3] = u0 * cv[13].P + u1 * cv[14].P + u2 * cv[15].P;\n"
"#endif\n"
"\n"
"    //  Reduce 2x4 points to 2x2 -- two levels of linear interpolation in V\n"
"    //  and so 3 original pairs contributing to each of the 2 resulting:\n"
"    float v    = UV.y;\n"
"    float vinv = 1.0f - v;\n"
"\n"
"    float v0 = vinv * vinv;\n"
"    float v1 = v * vinv * 2.0f;\n"
"    float v2 = v * v;\n"
"\n"
"    float3 LPAIR[2], RPAIR[2];\n"
"    LPAIR[0] = v0 * LROW[0] + v1 * LROW[1] + v2 * LROW[2];\n"
"    RPAIR[0] = v0 * RROW[0] + v1 * RROW[1] + v2 * RROW[2];\n"
"\n"
"    LPAIR[1] = v0 * LROW[1] + v1 * LROW[2] + v2 * LROW[3];\n"
"    RPAIR[1] = v0 * RROW[1] + v1 * RROW[2] + v2 * RROW[3];\n"
"\n"
"    //  Interpolate points on the edges of the 2x2 bilinear hull from which\n"
"    //  both position and partials are trivially determined:\n"
"    float3 DU0 = vinv * LPAIR[0] + v * LPAIR[1];\n"
"    float3 DU1 = vinv * RPAIR[0] + v * RPAIR[1];\n"
"    float3 DV0 = uinv * LPAIR[0] + u * RPAIR[0];\n"
"    float3 DV1 = uinv * LPAIR[1] + u * RPAIR[1];\n"
"\n"
"    int level = OsdGetPatchFaceLevel(patchParam);\n"
"    dPu = (DU1 - DU0) * 3 * level;\n"
"    dPv = (DV1 - DV0) * 3 * level;\n"
"\n"
"    P = u * DU1 + uinv * DU0;\n"
"\n"
"    //  Compute the normal and test for degeneracy:\n"
"    //\n"
"    //  We need a geometric measure of the size of the patch for a suitable\n"
"    //  tolerance.  Magnitudes of the partials are generally proportional to\n"
"    //  that size -- the sum of the partials is readily available, cheap to\n"
"    //  compute, and has proved effective in most cases (though not perfect).\n"
"    //  The size of the bounding box of the patch, or some approximation to\n"
"    //  it, would be better but more costly to compute.\n"
"    //\n"
"    float proportionalNormalTolerance = 0.00001f;\n"
"\n"
"    float nEpsilon = (length(dPu) + length(dPv)) * proportionalNormalTolerance;\n"
"\n"
"    N = cross(dPu, dPv);\n"
"\n"
"    float nLength = length(N);\n"
"    if (nLength > nEpsilon) {\n"
"        N = N / nLength;\n"
"    } else {\n"
"        float3 diagCross = cross(RPAIR[1] - LPAIR[0], LPAIR[1] - RPAIR[0]);\n"
"        float diagCrossLength = length(diagCross);\n"
"        if (diagCrossLength > nEpsilon) {\n"
"            N = diagCross / diagCrossLength;\n"
"        }\n"
"    }\n"
"\n"
"#ifndef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    dNu = float3(0,0,0);\n"
"    dNv = float3(0,0,0);\n"
"#else\n"
"    //\n"
"    //  Compute 2nd order partials of P(u,v) in order to compute 1st order partials\n"
"    //  for the un-normalized n(u,v) = dPu X dPv, then project into the tangent\n"
"    //  plane of normalized N.  With resulting dNu and dNv we can make another\n"
"    //  attempt to resolve a still-degenerate normal.\n"
"    //\n"
"    //  We don't use the Weingarten equations here as they require N != 0 and also\n"
"    //  are a little less numerically stable/accurate in single precision.\n"
"    //\n"
"    float B0u[4], B1u[4], B2u[4];\n"
"    float B0v[4], B1v[4], B2v[4];\n"
"\n"
"    OsdUnivar4x4(UV.x, B0u, B1u, B2u);\n"
"    OsdUnivar4x4(UV.y, B0v, B1v, B2v);\n"
"\n"
"    float3 dUU = float3(0,0,0);\n"
"    float3 dVV = float3(0,0,0);\n"
"    float3 dUV = float3(0,0,0);\n"
"\n"
"    for (int i=0; i<4; ++i) {\n"
"        for (int j=0; j<4; ++j) {\n"
"#if OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"            int k = 4*i + j;\n"
"            float3 CV = (s <= vSegments.x) ? cv[k].P\n"
"                   :   ((s <= vSegments.y) ? cv[k].P1\n"
"                                           : cv[k].P2);\n"
"#else\n"
"            float3 CV = cv[4*i + j].P;\n"
"#endif\n"
"            dUU += (B0v[i] * B2u[j]) * CV;\n"
"            dVV += (B2v[i] * B0u[j]) * CV;\n"
"            dUV += (B1v[i] * B1u[j]) * CV;\n"
"        }\n"
"    }\n"
"\n"
"    dUU *= 6 * level;\n"
"    dVV *= 6 * level;\n"
"    dUV *= 9 * level;\n"
"\n"
"    dNu = cross(dUU, dPv) + cross(dPu, dUV);\n"
"    dNv = cross(dUV, dPv) + cross(dPu, dVV);\n"
"\n"
"    float nLengthInv = 1.0;\n"
"    if (nLength > nEpsilon) {\n"
"        nLengthInv = 1.0 / nLength;\n"
"    } else {\n"
"        //  N may have been resolved above if degenerate, but if N was resolved\n"
"        //  we don't have an accurate length for its un-normalized value, and that\n"
"        //  length is needed to project the un-normalized dNu and dNv into the\n"
"        //  tangent plane of N.\n"
"        //\n"
"        //  So compute N more accurately with available second derivatives, i.e.\n"
"        //  with a 1st order Taylor approximation to un-normalized N(u,v).\n"
"\n"
"        float DU = (UV.x == 1.0f) ? -1.0f : 1.0f;\n"
"        float DV = (UV.y == 1.0f) ? -1.0f : 1.0f;\n"
"\n"
"        N = DU * dNu + DV * dNv;\n"
"\n"
"        nLength = length(N);\n"
"        if (nLength > nEpsilon) {\n"
"            nLengthInv = 1.0f / nLength;\n"
"            N = N * nLengthInv;\n"
"        }\n"
"    }\n"
"\n"
"    //  Project derivatives of non-unit normals into tangent plane of N:\n"
"    dNu = (dNu - dot(dNu,N) * N) * nLengthInv;\n"
"    dNv = (dNv - dot(dNv,N) * N) * nLengthInv;\n"
"#endif\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Gregory Basis\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"struct OsdPerPatchVertexGregoryBasis {\n"
"    packed_float3 P;\n"
"};\n"
"\n"
"void\n"
"OsdComputePerPatchVertexGregoryBasis(int3 patchParam, int ID, float3 cv,\n"
"                                     device OsdPerPatchVertexGregoryBasis& result)\n"
"{\n"
"    result.P = cv;\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchGregory(int3 patchParam, float2 UV, thread float3* cv,\n"
"                    thread float3& P, thread float3& dPu, thread float3& dPv,\n"
"                    thread float3& N, thread float3& dNu, thread float3& dNv)\n"
"{\n"
"    float u = UV.x, v = UV.y;\n"
"    float U = 1-u, V = 1-v;\n"
"\n"
"    //(0,1)                              (1,1)\n"
"    //   P3         e3-      e2+         P2\n"
"    //      15------17-------11-------10\n"
"    //      |        |        |        |\n"
"    //      |        |        |        |\n"
"    //      |        | f3-    | f2+    |\n"
"    //      |       19       13        |\n"
"    //  e3+ 16-----18          14-----12 e2-\n"
"    //      |     f3+          f2-     |\n"
"    //      |                          |\n"
"    //      |                          |\n"
"    //      |     f0-         f1+      |\n"
"    //  e0- 2------4            8------6 e1+\n"
"    //      |        3 f0+    9        |\n"
"    //      |        |        | f1-    |\n"
"    //      |        |        |        |\n"
"    //      |        |        |        |\n"
"    //      0--------1--------7--------5\n"
"    //    P0        e0+      e1-         P1\n"
"    //(0,0)                               (1,0)\n"
"\n"
"    float d11 = u+v;\n"
"    float d12 = U+v;\n"
"    float d21 = u+V;\n"
"    float d22 = U+V;\n"
"\n"
"    OsdPerPatchVertexBezier bezcv[16];\n"
"    float2 vSegments;\n"
"\n"
"    bezcv[ 5].P = (d11 == 0.0) ? cv[3]  : (u*cv[3] + v*cv[4])/d11;\n"
"    bezcv[ 6].P = (d12 == 0.0) ? cv[8]  : (U*cv[9] + v*cv[8])/d12;\n"
"    bezcv[ 9].P = (d21 == 0.0) ? cv[18] : (u*cv[19] + V*cv[18])/d21;\n"
"    bezcv[10].P = (d22 == 0.0) ? cv[13] : (U*cv[13] + V*cv[14])/d22;\n"
"\n"
"    bezcv[ 0].P = cv[0];\n"
"    bezcv[ 1].P = cv[1];\n"
"    bezcv[ 2].P = cv[7];\n"
"    bezcv[ 3].P = cv[5];\n"
"    bezcv[ 4].P = cv[2];\n"
"    bezcv[ 7].P = cv[6];\n"
"    bezcv[ 8].P = cv[16];\n"
"    bezcv[11].P = cv[12];\n"
"    bezcv[12].P = cv[15];\n"
"    bezcv[13].P = cv[17];\n"
"    bezcv[14].P = cv[11];\n"
"    bezcv[15].P = cv[10];\n"
"\n"
"    OsdEvalPatchBezier(patchParam, UV, bezcv, P, dPu, dPv, N, dNu, dNv, vSegments);\n"
"}\n"
"\n"
"//\n"
"//  Convert the 12 points of a regular patch resulting from Loop subdivision\n"
"//  into a more accessible Bezier patch for both tessellation assessment and\n"
"//  evaluation.\n"
"//\n"
"//  Regular patch for Loop subdivision -- quartic triangular Box spline:\n"
"//\n"
"//                           10 --- 11\n"
"//                           . .   . .\n"
"//                          .   . .   .\n"
"//                         7 --- 8 --- 9\n"
"//                        . .   . .   . .\n"
"//                       .   . .   . .   .\n"
"//                      3 --- 4 --- 5 --- 6\n"
"//                       .   . .   . .   .\n"
"//                        . .   . .   . .\n"
"//                         0 --- 1 --- 2\n"
"//\n"
"//  The equivalant quartic Bezier triangle (15 points):\n"
"//\n"
"//                              14\n"
"//                              . .\n"
"//                             .   .\n"
"//                           12 --- 13\n"
"//                           . .   . .\n"
"//                          .   . .   .\n"
"//                         9 -- 10 --- 11\n"
"//                        . .   . .   . .\n"
"//                       .   . .   . .   .\n"
"//                      5 --- 6 --- 7 --- 8\n"
"//                     . .   . .   . .   . .\n"
"//                    .   . .   . .   . .   .\n"
"//                   0 --- 1 --- 2 --- 3 --- 4\n"
"//\n"
"//  A hybrid cubic/quartic Bezier patch with cubic boundaries is a close\n"
"//  approximation and would only use 12 control points, but we need a full\n"
"//  quartic patch to maintain accuracy along boundary curves -- especially\n"
"//  between subdivision levels.\n"
"//\n"
"template<typename VertexType>\n"
"void\n"
"OsdComputePerPatchVertexBoxSplineTriangle(\n"
"        int3 patchParam, int ID,\n"
"        threadgroup VertexType* cv,\n"
"        device OsdPerPatchVertexBezier& result)\n"
"{\n"
"    //\n"
"    //  Conversion matrix from 12-point Box spline to 15-point quartic Bezier\n"
"    //  patch and its common scale factor:\n"
"    //\n"
"    const float boxToBezierMatrix[12*15] = {\n"
"    // L0   L1   L2     L3   L4   L5   L6     L7   L8   L9     L10  L11\n"
"        2,   2,   0,     2,  12,   2,   0,     2,   2,   0,     0,   0,  // B0\n"
"        1,   3,   0,     0,  12,   4,   0,     1,   3,   0,     0,   0,  // B1\n"
"        0,   4,   0,     0,   8,   8,   0,     0,   4,   0,     0,   0,  // B2\n"
"        0,   3,   1,     0,   4,  12,   0,     0,   3,   1,     0,   0,  // B3\n"
"        0,   2,   2,     0,   2,  12,   2,     0,   2,   2,     0,   0,  // B4\n"
"        0,   1,   0,     1,  12,   3,   0,     3,   4,   0,     0,   0,  // B5\n"
"        0,   1,   0,     0,  10,   6,   0,     1,   6,   0,     0,   0,  // B6\n"
"        0,   1,   0,     0,   6,  10,   0,     0,   6,   1,     0,   0,  // B7\n"
"        0,   1,   0,     0,   3,  12,   1,     0,   4,   3,     0,   0,  // B8\n"
"        0,   0,   0,     0,   8,   4,   0,     4,   8,   0,     0,   0,  // B9\n"
"        0,   0,   0,     0,   6,   6,   0,     1,  10,   1,     0,   0,  // B10\n"
"        0,   0,   0,     0,   4,   8,   0,     0,   8,   4,     0,   0,  // B11\n"
"        0,   0,   0,     0,   4,   3,   0,     3,  12,   1,     1,   0,  // B12\n"
"        0,   0,   0,     0,   3,   4,   0,     1,  12,   3,     0,   1,  // B13\n"
"        0,   0,   0,     0,   2,   2,   0,     2,  12,   2,     2,   2   // B14\n"
"    };\n"
"    const float boxToBezierMatrixScale = 1.0 / 24.0;\n"
"\n"
"    OsdComputeBoxSplineTriangleBoundaryPoints(cv, patchParam);\n"
"\n"
"    //result.patchParam = patchParam;\n"
"    result.P = float3(0);\n"
"\n"
"    int cvCoeffBase = 12 * ID;\n"
"\n"
"    for (int i = 0; i < 12; ++i) {\n"
"        result.P += boxToBezierMatrix[cvCoeffBase + i] * cv[i].GetPosition();\n"
"    }\n"
"    result.P *= boxToBezierMatrixScale;\n"
"}\n"
"\n"
"template<typename PerPatchVertexBezier>\n"
"void\n"
"OsdEvalPatchBezierTriangle(int3 patchParam, float2 UV,\n"
"                       PerPatchVertexBezier cv,\n"
"                       thread float3& P, thread float3& dPu, thread float3& dPv,\n"
"                       thread float3& N, thread float3& dNu, thread float3& dNv)\n"
"{\n"
"    float u = UV.x;\n"
"    float v = UV.y;\n"
"    float w = 1.0 - u - v;\n"
"\n"
"    float uu = u * u;\n"
"    float vv = v * v;\n"
"    float ww = w * w;\n"
"\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    //\n"
"    //  When computing normal derivatives, we need 2nd derivatives, so compute\n"
"    //  an intermediate quadratic Bezier triangle from which 2nd derivatives\n"
"    //  can be easily computed, and which in turn yields the triangle that gives\n"
"    //  the position and 1st derivatives.\n"
"    //\n"
"    //  Quadratic barycentric basis functions (in addition to those above):\n"
"    float uv = u * v * 2.0;\n"
"    float vw = v * w * 2.0;\n"
"    float wu = w * u * 2.0;\n"
"\n"
"    float3 Q0 = ww * cv[ 0].P + wu * cv[ 1].P + uu * cv[ 2].P +\n"
"              uv * cv[ 6].P + vv * cv[ 9].P + vw * cv[ 5].P;\n"
"    float3 Q1 = ww * cv[ 1].P + wu * cv[ 2].P + uu * cv[ 3].P +\n"
"              uv * cv[ 7].P + vv * cv[10].P + vw * cv[ 6].P;\n"
"    float3 Q2 = ww * cv[ 2].P + wu * cv[ 3].P + uu * cv[ 4].P +\n"
"              uv * cv[ 8].P + vv * cv[11].P + vw * cv[ 7].P;\n"
"    float3 Q3 = ww * cv[ 5].P + wu * cv[ 6].P + uu * cv[ 7].P +\n"
"              uv * cv[10].P + vv * cv[12].P + vw * cv[ 9].P;\n"
"    float3 Q4 = ww * cv[ 6].P + wu * cv[ 7].P + uu * cv[ 8].P +\n"
"              uv * cv[11].P + vv * cv[13].P + vw * cv[10].P;\n"
"    float3 Q5 = ww * cv[ 9].P + wu * cv[10].P + uu * cv[11].P +\n"
"              uv * cv[13].P + vv * cv[14].P + vw * cv[12].P;\n"
"\n"
"    float3 V0 = w * Q0 + u * Q1 + v * Q3;\n"
"    float3 V1 = w * Q1 + u * Q2 + v * Q4;\n"
"    float3 V2 = w * Q3 + u * Q4 + v * Q5;\n"
"#else\n"
"    //\n"
"    //  When 2nd derivatives are not required, factor the recursive evaluation\n"
"    //  of a point to directly provide the three points of the triangle at the\n"
"    //  last stage -- which then trivially provides both position and 1st\n"
"    //  derivatives.  Each point of the triangle results from evaluating the\n"
"    //  corresponding cubic Bezier sub-triangle for each corner of the quartic:\n"
"    //\n"
"    //  Cubic barycentric basis functions:\n"
"    float uuu = uu * u;\n"
"    float uuv = uu * v * 3.0;\n"
"    float uvv = u * vv * 3.0;\n"
"    float vvv = vv * v;\n"
"    float vvw = vv * w * 3.0;\n"
"    float vww = v * ww * 3.0;\n"
"    float www = ww * w;\n"
"    float wwu = ww * u * 3.0;\n"
"    float wuu = w * uu * 3.0;\n"
"    float uvw = u * v * w * 6.0;\n"
"\n"
"    float3 V0 = www * cv[ 0].P + wwu * cv[ 1].P + wuu * cv[ 2].P\n"
"            + uuu * cv[ 3].P + uuv * cv[ 7].P + uvv * cv[10].P\n"
"            + vvv * cv[12].P + vvw * cv[ 9].P + vww * cv[ 5].P + uvw * cv[ 6].P;\n"
"\n"
"    float3 V1 = www * cv[ 1].P + wwu * cv[ 2].P + wuu * cv[ 3].P\n"
"            + uuu * cv[ 4].P + uuv * cv[ 8].P + uvv * cv[11].P\n"
"            + vvv * cv[13].P + vvw * cv[10].P + vww * cv[ 6].P + uvw * cv[ 7].P;\n"
"\n"
"    float3 V2 = www * cv[ 5].P + wwu * cv[ 6].P + wuu * cv[ 7].P\n"
"            + uuu * cv[ 8].P + uuv * cv[11].P + uvv * cv[13].P\n"
"            + vvv * cv[14].P + vvw * cv[12].P + vww * cv[ 9].P + uvw * cv[10].P;\n"
"#endif\n"
"\n"
"    //\n"
"    //  Compute P, du and dv all from the triangle formed from the three Vi:\n"
"    //\n"
"    P = w * V0 + u * V1 + v * V2;\n"
"\n"
"    int dSign = OsdGetPatchIsTriangleRotated(patchParam) ? -1 : 1;\n"
"    int level = OsdGetPatchFaceLevel(patchParam);\n"
"\n"
"    float d1Scale = dSign * level * 4;\n"
"\n"
"    dPu = (V1 - V0) * d1Scale;\n"
"    dPv = (V2 - V0) * d1Scale;\n"
"\n"
"    //  Compute N and test for degeneracy:\n"
"    //\n"
"    //  We need a geometric measure of the size of the patch for a suitable\n"
"    //  tolerance.  Magnitudes of the partials are generally proportional to\n"
"    //  that size -- the sum of the partials is readily available, cheap to\n"
"    //  compute, and has proved effective in most cases (though not perfect).\n"
"    //  The size of the bounding box of the patch, or some approximation to\n"
"    //  it, would be better but more costly to compute.\n"
"    //\n"
"    float proportionalNormalTolerance = 0.00001f;\n"
"\n"
"    float nEpsilon = (length(dPu) + length(dPv)) * proportionalNormalTolerance;\n"
"\n"
"    N = cross(dPu, dPv);\n"
"    float nLength = length(N);\n"
"\n"
"\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    //\n"
"    //  Compute normal derivatives using 2nd order partials, then use the\n"
"    //  normal derivatives to resolve a degenerate normal:\n"
"    //\n"
"    float d2Scale = dSign * level * level * 12;\n"
"\n"
"    float3 dUU = (Q0 - 2 * Q1 + Q2)  * d2Scale;\n"
"    float3 dVV = (Q0 - 2 * Q3 + Q5)  * d2Scale;\n"
"    float3 dUV = (Q0 - Q1 + Q4 - Q3) * d2Scale;\n"
"\n"
"    dNu = cross(dUU, dPv) + cross(dPu, dUV);\n"
"    dNv = cross(dUV, dPv) + cross(dPu, dVV);\n"
"\n"
"    if (nLength < nEpsilon) {\n"
"        //  Use 1st order Taylor approximation of N(u,v) within patch interior:\n"
"        if (w > 0.0) {\n"
"            N =  dNu + dNv;\n"
"        } else if (u >= 1.0) {\n"
"            N = -dNu + dNv;\n"
"        } else if (v >= 1.0) {\n"
"            N =  dNu - dNv;\n"
"        } else {\n"
"            N = -dNu - dNv;\n"
"        }\n"
"\n"
"        nLength = length(N);\n"
"        if (nLength < nEpsilon) {\n"
"            nLength = 1.0;\n"
"        }\n"
"    }\n"
"    N = N / nLength;\n"
"\n"
"    //  Project derivs of non-unit normal function onto tangent plane of N:\n"
"    dNu = (dNu - dot(dNu,N) * N) / nLength;\n"
"    dNv = (dNv - dot(dNv,N) * N) / nLength;\n"
"#else\n"
"    dNu = float3(0);\n"
"    dNv = float3(0);\n"
"\n"
"    //\n"
"    //  Resolve a degenerate normal using the interior triangle of the\n"
"    //  intermediate quadratic patch that results from recursive evaluation.\n"
"    //  This addresses common cases of degenerate or colinear boundaries\n"
"    //  without resorting to use of explicit 2nd derivatives:\n"
"    //\n"
"    if (nLength < nEpsilon) {\n"
"        float uv  = u * v * 2.0;\n"
"        float vw  = v * w * 2.0;\n"
"        float wu  = w * u * 2.0;\n"
"\n"
"        float3 Q1 = ww * cv[ 1].P + wu * cv[ 2].P + uu * cv[ 3].P +\n"
"                  uv * cv[ 7].P + vv * cv[10].P + vw * cv[ 6].P;\n"
"        float3 Q3 = ww * cv[ 5].P + wu * cv[ 6].P + uu * cv[ 7].P +\n"
"                  uv * cv[10].P + vv * cv[12].P + vw * cv[ 9].P;\n"
"        float3 Q4 = ww * cv[ 6].P + wu * cv[ 7].P + uu * cv[ 8].P +\n"
"                  uv * cv[11].P + vv * cv[13].P + vw * cv[10].P;\n"
"\n"
"        N = cross((Q4 - Q1), (Q3 - Q1));\n"
"        nLength = length(N);\n"
"        if (nLength < nEpsilon) {\n"
"            nLength = 1.0;\n"
"        }\n"
"    }\n"
"    N = N / nLength;\n"
"#endif\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchGregoryTriangle(int3 patchParam, float2 UV, float3 cv[18],\n"
"                        thread float3& P, thread float3& dPu, thread float3& dPv,\n"
"                        thread float3& N, thread float3& dNu, thread float3& dNv)\n"
"{\n"
"    float u = UV.x;\n"
"    float v = UV.y;\n"
"    float w = 1.0 - u - v;\n"
"\n"
"    float duv = u + v;\n"
"    float dvw = v + w;\n"
"    float dwu = w + u;\n"
"\n"
"    OsdPerPatchVertexBezier bezcv[15];\n"
"\n"
"    bezcv[ 6].P = (duv == 0.0) ? cv[3]  : ((u*cv[ 3] + v*cv[ 4]) / duv);\n"
"    bezcv[ 7].P = (dvw == 0.0) ? cv[8]  : ((v*cv[ 8] + w*cv[ 9]) / dvw);\n"
"    bezcv[10].P = (dwu == 0.0) ? cv[13] : ((w*cv[13] + u*cv[14]) / dwu);\n"
"\n"
"    bezcv[ 0].P = cv[ 0];\n"
"    bezcv[ 1].P = cv[ 1];\n"
"    bezcv[ 2].P = cv[15];\n"
"    bezcv[ 3].P = cv[ 7];\n"
"    bezcv[ 4].P = cv[ 5];\n"
"    bezcv[ 5].P = cv[ 2];\n"
"    bezcv[ 8].P = cv[ 6];\n"
"    bezcv[ 9].P = cv[17];\n"
"    bezcv[11].P = cv[16];\n"
"    bezcv[12].P = cv[11];\n"
"    bezcv[13].P = cv[12];\n"
"    bezcv[14].P = cv[10];\n"
"\n"
"    OsdEvalPatchBezierTriangle(patchParam, UV, bezcv, P, dPu, dPv, N, dNu, dNv);\n"
"}\n"
"\n"
"\n"
);
static std::string commonTessShaderSource(
"#line 0 \"osd/mtlPatchCommonTess.metal\"\n"
"\n"
"//\n"
"//   Copyright 2015-2019 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Tessellation\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"// For now, fractional spacing is supported only with screen space tessellation\n"
"#ifndef OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"#undef OSD_FRACTIONAL_EVEN_SPACING\n"
"#undef OSD_FRACTIONAL_ODD_SPACING\n"
"#endif\n"
"\n"
"//\n"
"// Organization of B-spline and Bezier control points.\n"
"//\n"
"// Each patch is defined by 16 control points (labeled 0-15).\n"
"//\n"
"// The patch will be evaluated across the domain from (0,0) at\n"
"// the lower-left to (1,1) at the upper-right. When computing\n"
"// adaptive tessellation metrics, we consider refined vertex-vertex\n"
"// and edge-vertex points along the transition edges of the patch\n"
"// (labeled vv* and ev* respectively).\n"
"//\n"
"// The two segments of each transition edge are labeled Lo and Hi,\n"
"// with the Lo segment occurring before the Hi segment along the\n"
"// transition edge's domain parameterization. These Lo and Hi segment\n"
"// tessellation levels determine how domain evaluation coordinates\n"
"// are remapped along transition edges. The Hi segment value will\n"
"// be zero for a non-transition edge.\n"
"//\n"
"// (0,1)                                         (1,1)\n"
"//\n"
"//   vv3                  ev23                   vv2\n"
"//        |       Lo3       |       Hi3       |\n"
"//      --O-----------O-----+-----O-----------O--\n"
"//        | 12        | 13     14 |        15 |\n"
"//        |           |           |           |\n"
"//        |           |           |           |\n"
"//    Hi0 |           |           |           | Hi2\n"
"//        |           |           |           |\n"
"//        O-----------O-----------O-----------O\n"
"//        | 8         | 9      10 |        11 |\n"
"//        |           |           |           |\n"
"// ev03 --+           |           |           +-- ev12\n"
"//        |           |           |           |\n"
"//        | 4         | 5       6 |         7 |\n"
"//        O-----------O-----------O-----------O\n"
"//        |           |           |           |\n"
"//    Lo0 |           |           |           | Lo2\n"
"//        |           |           |           |\n"
"//        |           |           |           |\n"
"//        | 0         | 1       2 |         3 |\n"
"//      --O-----------O-----+-----O-----------O--\n"
"//        |       Lo1       |       Hi1       |\n"
"//   vv0                  ev01                   vv1\n"
"//\n"
"// (0,0)                                         (1,0)\n"
"//\n"
"\n"
"#ifndef OSD_MAX_TESS_LEVEL\n"
"#define OSD_MAX_TESS_LEVEL 64\n"
"#endif\n"
"\n"
"float OsdComputePostProjectionSphereExtent(\n"
"        const float4x4 OsdProjectionMatrix, float3 center, float diameter)\n"
"{\n"
"    float4 p = OsdProjectionMatrix * float4(center, 1.0);\n"
"    return abs(diameter * OsdProjectionMatrix[1][1] / p.w);\n"
"}\n"
"\n"
"float OsdComputeTessLevel(\n"
"        const float OsdTessLevel,\n"
"        const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,\n"
"        float3 p0, float3 p1)\n"
"{\n"
"    // Adaptive factor can be any computation that depends only on arg values.\n"
"    // Project the diameter of the edge's bounding sphere instead of using the\n"
"    // length of the projected edge itself to avoid problems near silhouettes.\n"
"    p0 = (OsdModelViewMatrix * float4(p0, 1.0)).xyz;\n"
"    p1 = (OsdModelViewMatrix * float4(p1, 1.0)).xyz;\n"
"    float3 center = (p0 + p1) / 2.0;\n"
"    float diameter = distance(p0, p1);\n"
"    float projLength = OsdComputePostProjectionSphereExtent(OsdProjectionMatrix, center, diameter);\n"
"    float tessLevel = max(1.0, OsdTessLevel * projLength);\n"
"\n"
"    // We restrict adaptive tessellation levels to half of the device\n"
"    // supported maximum because transition edges are split into two\n"
"    // halves and the sum of the two corresponding levels must not exceed\n"
"    // the device maximum. We impose this limit even for non-transition\n"
"    // edges because a non-transition edge must be able to match up with\n"
"    // one half of the transition edge of an adjacent transition patch.\n"
"    return min(tessLevel, (float)(OSD_MAX_TESS_LEVEL / 2));\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsUniform(const float OsdTessLevel, int3 patchParam,\n"
"                        thread float4& tessOuterLo, thread float4& tessOuterHi)\n"
"{\n"
"    // Uniform factors are simple powers of two for each level.\n"
"    // The maximum here can be increased if we know the maximum\n"
"    // refinement level of the mesh:\n"
"    //     min(OSD_MAX_TESS_LEVEL, pow(2, MaximumRefinementLevel-1)\n"
"    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);\n"
"    float tessLevel = min(OsdTessLevel, (float)OSD_MAX_TESS_LEVEL) /\n"
"                        pow(2, refinementLevel - 1.0f);\n"
"\n"
"    // tessLevels of transition edge should be clamped to 2.\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"    float4 tessLevelMin = float4(1) + float4(((transitionMask & 8) >> 3),\n"
"                                             ((transitionMask & 1) >> 0),\n"
"                                             ((transitionMask & 2) >> 1),\n"
"                                             ((transitionMask & 4) >> 2));\n"
"\n"
"    tessOuterLo = max(float4(tessLevel), tessLevelMin);\n"
"    tessOuterHi = float4(0);\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsUniformTriangle(const float OsdTessLevel, int3 patchParam,\n"
"                        thread float4& tessOuterLo, thread float4& tessOuterHi)\n"
"{\n"
"    // Uniform factors are simple powers of two for each level.\n"
"    // The maximum here can be increased if we know the maximum\n"
"    // refinement level of the mesh:\n"
"    //     min(OSD_MAX_TESS_LEVEL, pow(2, MaximumRefinementLevel-1)\n"
"    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);\n"
"    float tessLevel = min(OsdTessLevel, (float)OSD_MAX_TESS_LEVEL) /\n"
"                        pow(2, refinementLevel - 1.0f);\n"
"\n"
"    // tessLevels of transition edge should be clamped to 2.\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"    float4 tessLevelMin = float4(1) + float4(((transitionMask & 4) >> 2),\n"
"                                             ((transitionMask & 1) >> 0),\n"
"                                             ((transitionMask & 2) >> 1),\n"
"                                             0);\n"
"\n"
"    tessOuterLo = max(float4(tessLevel), tessLevelMin);\n"
"    tessOuterHi = float4(0);\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsRefinedPoints(\n"
"        const float OsdTessLevel,\n"
"        const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,\n"
"        float3 cp[16], int3 patchParam,\n"
"        thread float4& tessOuterLo, thread float4& tessOuterHi)\n"
"{\n"
"    // Each edge of a transition patch is adjacent to one or two patches\n"
"    // at the next refined level of subdivision. We compute the corresponding\n"
"    // vertex-vertex and edge-vertex refined points along the edges of the\n"
"    // patch using Catmull-Clark subdivision stencil weights.\n"
"    // For simplicity, we let the optimizer discard unused computation.\n"
"\n"
"    float3 vv0 = (cp[0] + cp[2] + cp[8] + cp[10]) * 0.015625 +\n"
"                 (cp[1] + cp[4] + cp[6] + cp[9]) * 0.09375 + cp[5] * 0.5625;\n"
"    float3 ev01 = (cp[1] + cp[2] + cp[9] + cp[10]) * 0.0625 +\n"
"                  (cp[5] + cp[6]) * 0.375;\n"
"\n"
"    float3 vv1 = (cp[1] + cp[3] + cp[9] + cp[11]) * 0.015625 +\n"
"                 (cp[2] + cp[5] + cp[7] + cp[10]) * 0.09375 + cp[6] * 0.5625;\n"
"    float3 ev12 = (cp[5] + cp[7] + cp[9] + cp[11]) * 0.0625 +\n"
"                  (cp[6] + cp[10]) * 0.375;\n"
"\n"
"    float3 vv2 = (cp[5] + cp[7] + cp[13] + cp[15]) * 0.015625 +\n"
"                 (cp[6] + cp[9] + cp[11] + cp[14]) * 0.09375 + cp[10] * 0.5625;\n"
"    float3 ev23 = (cp[5] + cp[6] + cp[13] + cp[14]) * 0.0625 +\n"
"                  (cp[9] + cp[10]) * 0.375;\n"
"\n"
"    float3 vv3 = (cp[4] + cp[6] + cp[12] + cp[14]) * 0.015625 +\n"
"                 (cp[5] + cp[8] + cp[10] + cp[13]) * 0.09375 + cp[9] * 0.5625;\n"
"    float3 ev03 = (cp[4] + cp[6] + cp[8] + cp[10]) * 0.0625 +\n"
"                  (cp[5] + cp[9]) * 0.375;\n"
"\n"
"    tessOuterLo = float4(0);\n"
"    tessOuterHi = float4(0);\n"
"\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"\n"
"    if ((transitionMask & 8) != 0) {\n"
"        tessOuterLo[0] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv0, ev03);\n"
"        tessOuterHi[0] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv3, ev03);\n"
"    } else {\n"
"        tessOuterLo[0] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[5], cp[9]);\n"
"    }\n"
"    if ((transitionMask & 1) != 0) {\n"
"        tessOuterLo[1] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv0, ev01);\n"
"        tessOuterHi[1] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv1, ev01);\n"
"    } else {\n"
"        tessOuterLo[1] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[5], cp[6]);\n"
"    }\n"
"    if ((transitionMask & 2) != 0) {\n"
"        tessOuterLo[2] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv1, ev12);\n"
"        tessOuterHi[2] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv2, ev12);\n"
"    } else {\n"
"        tessOuterLo[2] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[6], cp[10]);\n"
"    }\n"
"    if ((transitionMask & 4) != 0) {\n"
"        tessOuterLo[3] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv3, ev23);\n"
"        tessOuterHi[3] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv2, ev23);\n"
"    } else {\n"
"        tessOuterLo[3] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[9], cp[10]);\n"
"    }\n"
"}\n"
"\n"
"//\n"
"//  Patch boundary corners are ordered counter-clockwise from the first\n"
"//  corner while patch boundary edges and their midpoints are similarly\n"
"//  ordered counter-clockwise beginning at the edge preceding corner[0].\n"
"//\n"
"void\n"
"Osd_GetTessLevelsFromPatchBoundaries4(\n"
"        const float OsdTessLevel,\n"
"        const float4x4 OsdProjectionMatrix,\n"
"        const float4x4 OsdModelViewMatrix,\n"
"        float3 corners[3], float3 midpoints[3],\n"
"        int3 patchParam,\n"
"        thread float4& tessOuterLo, thread float4& tessOuterHi)\n"
"{\n"
"    tessOuterLo = float4(0);\n"
"    tessOuterHi = float4(0);\n"
"\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"\n"
"    if ((transitionMask & 8) != 0) {\n"
"        tessOuterLo[0] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[0], midpoints[0]);\n"
"        tessOuterHi[0] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[3], midpoints[0]);\n"
"    } else {\n"
"        tessOuterLo[0] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[0], corners[3]);\n"
"    }\n"
"    if ((transitionMask & 1) != 0) {\n"
"        tessOuterLo[1] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[0], midpoints[1]);\n"
"        tessOuterHi[1] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[1], midpoints[1]);\n"
"    } else {\n"
"        tessOuterLo[1] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[0], corners[1]);\n"
"    }\n"
"    if ((transitionMask & 2) != 0) {\n"
"        tessOuterLo[2] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[1], midpoints[2]);\n"
"        tessOuterHi[2] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[2], midpoints[2]);\n"
"    } else {\n"
"        tessOuterLo[2] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[1], corners[2]);\n"
"    }\n"
"    if ((transitionMask & 4) != 0) {\n"
"        tessOuterLo[3] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[3], midpoints[3]);\n"
"        tessOuterHi[3] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[2], midpoints[3]);\n"
"    } else {\n"
"        tessOuterLo[3] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[3], corners[2]);\n"
"    }\n"
"}\n"
"\n"
"void\n"
"Osd_GetTessLevelsFromPatchBoundaries3(\n"
"        const float OsdTessLevel,\n"
"        const float4x4 OsdProjectionMatrix,\n"
"        const float4x4 OsdModelViewMatrix,\n"
"        float3 corners[3], float3 midpoints[3],\n"
"        int3 patchParam,\n"
"        thread float4& tessOuterLo, thread float4& tessOuterHi)\n"
"{\n"
"    tessOuterLo = float4(0);\n"
"    tessOuterHi = float4(0);\n"
"\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"\n"
"    if ((transitionMask & 4) != 0) {\n"
"        tessOuterLo[0] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[0], midpoints[0]);\n"
"        tessOuterHi[0] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[2], midpoints[0]);\n"
"    } else {\n"
"        tessOuterLo[0] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[0], corners[2]);\n"
"    }\n"
"    if ((transitionMask & 1) != 0) {\n"
"        tessOuterLo[1] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[0], midpoints[1]);\n"
"        tessOuterHi[1] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[1], midpoints[1]);\n"
"    } else {\n"
"        tessOuterLo[1] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[0], corners[1]);\n"
"    }\n"
"    if ((transitionMask & 2) != 0) {\n"
"        tessOuterLo[2] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[2], midpoints[2]);\n"
"        tessOuterHi[2] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[1], midpoints[2]);\n"
"    } else {\n"
"        tessOuterLo[2] = OsdComputeTessLevel(\n"
"            OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"            corners[1], corners[2]);\n"
"    }\n"
"}\n"
"\n"
"float3\n"
"Osd_EvalBezierCurveMidPoint(float3 p0, float3 p1, float3 p2, float3 p3)\n"
"{\n"
"    //  Coefficients for the midpoint are { 1/8, 3/8, 3/8, 1/8 }:\n"
"    return 0.125 * (p0 + p3) + 0.375 * (p1 + p2);\n"
"}\n"
"\n"
"float3\n"
"Osd_EvalQuarticBezierCurveMidPoint(float3 p0, float3 p1, float3 p2, float3 p3, float3 p4)\n"
"{\n"
"    //  Coefficients for the midpoint are { 1/16, 1/4, 3/8, 1/4, 1/16 }:\n"
"    return 0.0625 * (p0 + p4) + 0.25 * (p1 + p3) + 0.375 * p2;\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchBezierTessLevels(\n"
"        const float OsdTessLevel,\n"
"        const float4x4 OsdProjectionMatrix,\n"
"        const float4x4 OsdModelViewMatrix,\n"
"        device OsdPerPatchVertexBezier* cpBezier,\n"
"        int3 patchParam,\n"
"        thread float4& tessOuterLo, thread float4& tessOuterHi)\n"
"{\n"
"    // Each edge of a transition patch is adjacent to one or two patches\n"
"    // at the next refined level of subdivision. When the patch control\n"
"    // points have been converted to the Bezier basis, the control points\n"
"    // at the four corners are on the limit surface (since a Bezier patch\n"
"    // interpolates its corner control points). We can compute an adaptive\n"
"    // tessellation level for transition edges on the limit surface by\n"
"    // evaluating a limit position at the mid point of each transition edge.\n"
"\n"
"    tessOuterLo = float4(0);\n"
"    tessOuterHi = float4(0);\n"
"\n"
"    float3 corners[4];\n"
"    float3 midpoints[4];\n"
"\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"\n"
"#if OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    corners[0] = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 0.0));\n"
"    corners[1] = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 0.0));\n"
"    corners[2] = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 1.0));\n"
"    corners[3] = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 1.0));\n"
"\n"
"    midpoints[0] = ((transitionMask & 8) == 0) ? float3(0) :\n"
"        OsdEvalBezier(cpBezier, patchParam, float2(0.0, 0.5));\n"
"    midpoints[1] = ((transitionMask & 1) == 0) ? float3(0) :\n"
"        OsdEvalBezier(cpBezier, patchParam, float2(0.5, 0.0));\n"
"    midpoints[2] = ((transitionMask & 2) == 0) ? float3(0) :\n"
"        OsdEvalBezier(cpBezier, patchParam, float2(1.0, 0.5));\n"
"    midpoints[3] = ((transitionMask & 4) == 0) ? float3(0) :\n"
"        OsdEvalBezier(cpBezier, patchParam, float2(0.5, 1.0));\n"
"\n"
"#else // OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    corners[0] = cpBezier[ 0].P;\n"
"    corners[1] = cpBezier[ 3].P;\n"
"    corners[2] = cpBezier[15].P;\n"
"    corners[3] = cpBezier[12].P;\n"
"\n"
"    midpoints[0] = ((transitionMask & 8) == 0) ? float3(0) :\n"
"        Osd_EvalBezierCurveMidPoint(\n"
"            cpBezier[0].P, cpBezier[4].P, cpBezier[8].P, cpBezier[12].P);\n"
"    midpoints[1] = ((transitionMask & 1) == 0) ? float3(0) :\n"
"        Osd_EvalBezierCurveMidPoint(\n"
"            cpBezier[0].P, cpBezier[1].P, cpBezier[2].P, cpBezier[3].P);\n"
"    midpoints[2] = ((transitionMask & 2) == 0) ? float3(0) :\n"
"        Osd_EvalBezierCurveMidPoint(\n"
"            cpBezier[3].P, cpBezier[7].P, cpBezier[11].P, cpBezier[15].P);\n"
"    midpoints[3] = ((transitionMask & 4) == 0) ? float3(0) :\n"
"        Osd_EvalBezierCurveMidPoint(\n"
"            cpBezier[12].P, cpBezier[13].P, cpBezier[14].P, cpBezier[15].P);\n"
"#endif\n"
"\n"
"    Osd_GetTessLevelsFromPatchBoundaries4(\n"
"        OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"        corners, midpoints, patchParam, tessOuterLo, tessOuterHi);\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchBezierTessLevels(\n"
"        const float OsdTessLevel,\n"
"        const float4x4 OsdProjectionMatrix,\n"
"        const float4x4 OsdModelViewMatrix,\n"
"        float3 cv[16],\n"
"        int3 patchParam,\n"
"        thread float4& tessOuterLo, thread float4& tessOuterHi)\n"
"{\n"
"    // Each edge of a transition patch is adjacent to one or two patches\n"
"    // at the next refined level of subdivision. When the patch control\n"
"    // points have been converted to the Bezier basis, the control points\n"
"    // at the four corners are on the limit surface (since a Bezier patch\n"
"    // interpolates its corner control points). We can compute an adaptive\n"
"    // tessellation level for transition edges on the limit surface by\n"
"    // evaluating a limit position at the mid point of each transition edge.\n"
"\n"
"    tessOuterLo = float4(0);\n"
"    tessOuterHi = float4(0);\n"
"\n"
"    float3 corners[4];\n"
"    float3 midpoints[4];\n"
"\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"\n"
"    corners[0] = cv[ 0];\n"
"    corners[1] = cv[ 3];\n"
"    corners[2] = cv[15];\n"
"    corners[3] = cv[12];\n"
"\n"
"    midpoints[0] = ((transitionMask & 8) == 0) ? float3(0) :\n"
"        Osd_EvalBezierCurveMidPoint(cv[0], cv[4], cv[8], cv[12]);\n"
"    midpoints[1] = ((transitionMask & 1) == 0) ? float3(0) :\n"
"        Osd_EvalBezierCurveMidPoint(cv[0], cv[1], cv[2], cv[3]);\n"
"    midpoints[2] = ((transitionMask & 2) == 0) ? float3(0) :\n"
"        Osd_EvalBezierCurveMidPoint(cv[3], cv[7], cv[11], cv[15]);\n"
"    midpoints[3] = ((transitionMask & 4) == 0) ? float3(0) :\n"
"        Osd_EvalBezierCurveMidPoint(cv[12], cv[13], cv[14], cv[15]);\n"
"\n"
"    Osd_GetTessLevelsFromPatchBoundaries4(\n"
"        OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"        corners, midpoints, patchParam, tessOuterLo, tessOuterHi);\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchBezierTriangleTessLevels(\n"
"        const float OsdTessLevel,\n"
"        const float4x4 OsdProjectionMatrix,\n"
"        const float4x4 OsdModelViewMatrix,\n"
"        float3 cv[15],\n"
"        int3 patchParam,\n"
"        thread float4& tessOuterLo, thread float4& tessOuterHi)\n"
"{\n"
"    // Each edge of a transition patch is adjacent to one or two patches\n"
"    // at the next refined level of subdivision. When the patch control\n"
"    // points have been converted to the Bezier basis, the control points\n"
"    // at the corners are on the limit surface (since a Bezier patch\n"
"    // interpolates its corner control points). We can compute an adaptive\n"
"    // tessellation level for transition edges on the limit surface by\n"
"    // evaluating a limit position at the mid point of each transition edge.\n"
"\n"
"    tessOuterLo = float4(0);\n"
"    tessOuterHi = float4(0);\n"
"\n"
"    int transitionMask = OsdGetPatchTransitionMask(patchParam);\n"
"\n"
"    float3 corners[3];\n"
"    corners[0] = cv[0];\n"
"    corners[1] = cv[4];\n"
"    corners[2] = cv[14];\n"
"\n"
"    float3 midpoints[3];\n"
"    midpoints[0] = ((transitionMask & 4) == 0) ? float3(0) :\n"
"        Osd_EvalQuarticBezierCurveMidPoint(cv[0], cv[5], cv[9], cv[12], cv[14]);\n"
"    midpoints[1] = ((transitionMask & 1) == 0) ? float3(0) :\n"
"        Osd_EvalQuarticBezierCurveMidPoint(cv[0], cv[1], cv[2], cv[3], cv[4]);\n"
"    midpoints[2] = ((transitionMask & 2) == 0) ? float3(0) :\n"
"        Osd_EvalQuarticBezierCurveMidPoint(cv[4], cv[8], cv[11], cv[13], cv[14]);\n"
"\n"
"    Osd_GetTessLevelsFromPatchBoundaries3(\n"
"        OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"        corners, midpoints, patchParam, tessOuterLo, tessOuterHi);\n"
"}\n"
"\n"
"// Round up to the nearest even integer\n"
"float OsdRoundUpEven(float x) {\n"
"    return 2*ceil(x/2);\n"
"}\n"
"\n"
"// Round up to the nearest odd integer\n"
"float OsdRoundUpOdd(float x) {\n"
"    return 2*ceil((x+1)/2)-1;\n"
"}\n"
"\n"
"// Compute outer and inner tessellation levels taking into account the\n"
"// current tessellation spacing mode.\n"
"void\n"
"OsdComputeTessLevels(thread float4& tessOuterLo, thread float4& tessOuterHi,\n"
"                     thread float4& tessLevelOuter, thread float2& tessLevelInner)\n"
"{\n"
"    // Outer levels are the sum of the Lo and Hi segments where the Hi\n"
"    // segments will have lengths of zero for non-transition edges.\n"
"\n"
"#if defined OSD_FRACTIONAL_EVEN_SPACING\n"
"    // Combine fractional outer transition edge levels before rounding.\n"
"    float4 combinedOuter = tessOuterLo + tessOuterHi;\n"
"\n"
"    // Round the segments of transition edges separately. We will recover the\n"
"    // fractional parameterization of transition edges after tessellation.\n"
"\n"
"    tessLevelOuter = combinedOuter;\n"
"    if (tessOuterHi[0] > 0) {\n"
"        tessLevelOuter[0] =\n"
"            OsdRoundUpEven(tessOuterLo[0]) + OsdRoundUpEven(tessOuterHi[0]);\n"
"    }\n"
"    if (tessOuterHi[1] > 0) {\n"
"        tessLevelOuter[1] =\n"
"            OsdRoundUpEven(tessOuterLo[1]) + OsdRoundUpEven(tessOuterHi[1]);\n"
"    }\n"
"    if (tessOuterHi[2] > 0) {\n"
"        tessLevelOuter[2] =\n"
"            OsdRoundUpEven(tessOuterLo[2]) + OsdRoundUpEven(tessOuterHi[2]);\n"
"    }\n"
"    if (tessOuterHi[3] > 0) {\n"
"        tessLevelOuter[3] =\n"
"            OsdRoundUpEven(tessOuterLo[3]) + OsdRoundUpEven(tessOuterHi[3]);\n"
"    }\n"
"#elif defined OSD_FRACTIONAL_ODD_SPACING\n"
"    // Combine fractional outer transition edge levels before rounding.\n"
"    float4 combinedOuter = tessOuterLo + tessOuterHi;\n"
"\n"
"    // Round the segments of transition edges separately. We will recover the\n"
"    // fractional parameterization of transition edges after tessellation.\n"
"    //\n"
"    // The sum of the two outer odd segment lengths will be an even number\n"
"    // which the tessellator will increase by +1 so that there will be a\n"
"    // total odd number of segments. We clamp the combinedOuter tess levels\n"
"    // (used to compute the inner tess levels) so that the outer transition\n"
"    // edges will be sampled without degenerate triangles.\n"
"\n"
"    tessLevelOuter = combinedOuter;\n"
"    if (tessOuterHi[0] > 0) {\n"
"        tessLevelOuter[0] =\n"
"            OsdRoundUpOdd(tessOuterLo[0]) + OsdRoundUpOdd(tessOuterHi[0]);\n"
"        combinedOuter = max(float4(3), combinedOuter);\n"
"    }\n"
"    if (tessOuterHi[1] > 0) {\n"
"        tessLevelOuter[1] =\n"
"            OsdRoundUpOdd(tessOuterLo[1]) + OsdRoundUpOdd(tessOuterHi[1]);\n"
"        combinedOuter = max(float4(3), combinedOuter);\n"
"    }\n"
"    if (tessOuterHi[2] > 0) {\n"
"        tessLevelOuter[2] =\n"
"            OsdRoundUpOdd(tessOuterLo[2]) + OsdRoundUpOdd(tessOuterHi[2]);\n"
"        combinedOuter = max(float4(3), combinedOuter);\n"
"    }\n"
"    if (tessOuterHi[3] > 0) {\n"
"        tessLevelOuter[3] =\n"
"            OsdRoundUpOdd(tessOuterLo[3]) + OsdRoundUpOdd(tessOuterHi[3]);\n"
"        combinedOuter = max(float4(3), combinedOuter);\n"
"    }\n"
"#else\n"
"    // Round equally spaced transition edge levels before combining.\n"
"    tessOuterLo = round(tessOuterLo);\n"
"    tessOuterHi = round(tessOuterHi);\n"
"\n"
"    float4 combinedOuter = tessOuterLo + tessOuterHi;\n"
"    tessLevelOuter = combinedOuter;\n"
"#endif\n"
"\n"
"    // Inner levels are the averages the corresponding outer levels.\n"
"    tessLevelInner[0] = (combinedOuter[1] + combinedOuter[3]) * 0.5;\n"
"    tessLevelInner[1] = (combinedOuter[0] + combinedOuter[2]) * 0.5;\n"
"}\n"
"\n"
"void\n"
"OsdComputeTessLevelsTriangle(\n"
"        thread float4& tessOuterLo, thread float4& tessOuterHi,\n"
"        thread float4& tessLevelOuter, thread float2& tessLevelInner)\n"
"{\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi,\n"
"                         tessLevelOuter, tessLevelInner);\n"
"\n"
"    // Inner level is the max of the three outer levels.\n"
"    tessLevelInner[0] = max(max(tessLevelOuter[0],\n"
"                                tessLevelOuter[1]),\n"
"                                tessLevelOuter[2]);\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsUniform(\n"
"        const float OsdTessLevel, int3 patchParam,\n"
"        thread float4& tessLevelOuter, thread float2& tessLevelInner,\n"
"        thread float4& tessOuterLo, thread float4& tessOuterHi)\n"
"{\n"
"    OsdGetTessLevelsUniform(OsdTessLevel, patchParam, tessOuterLo, tessOuterHi);\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi, tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsUniformTriangle(\n"
"        const float OsdTessLevel, int3 patchParam,\n"
"        thread float4& tessLevelOuter, thread float2& tessLevelInner,\n"
"        thread float4& tessOuterLo, thread float4& tessOuterHi)\n"
"{\n"
"    OsdGetTessLevelsUniformTriangle(OsdTessLevel, patchParam, tessOuterLo, tessOuterHi);\n"
"    OsdComputeTessLevelsTriangle(tessOuterLo, tessOuterHi, tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchBezierTessLevels(\n"
"         const float OsdTessLevels,\n"
"         const float4x4 OsdProjectionMatrix,\n"
"         const float4x4 OsdModelViewMatrix,\n"
"         device OsdPerPatchVertexBezier* cpBezier,\n"
"         int3 patchParam,\n"
"         thread float4& tessLevelOuter, thread float2& tessLevelInner,\n"
"         thread float4& tessOuterLo, thread float4& tessOuterHi)\n"
"{\n"
"    OsdEvalPatchBezierTessLevels(\n"
"                OsdTessLevels,\n"
"                OsdProjectionMatrix, OsdModelViewMatrix,\n"
"                cpBezier, patchParam,\n"
"                tessOuterLo, tessOuterHi);\n"
"\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi,\n"
"                         tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchBezierTessLevels(\n"
"         const float OsdTessLevels,\n"
"         const float4x4 OsdProjectionMatrix,\n"
"         const float4x4 OsdModelViewMatrix,\n"
"         float3 cv[16],\n"
"         int3 patchParam,\n"
"         thread float4& tessLevelOuter, thread float2& tessLevelInner,\n"
"         thread float4& tessOuterLo, thread float4& tessOuterHi)\n"
"{\n"
"    OsdEvalPatchBezierTessLevels(\n"
"                OsdTessLevels,\n"
"                OsdProjectionMatrix, OsdModelViewMatrix,\n"
"                cv, patchParam,\n"
"                tessOuterLo, tessOuterHi);\n"
"\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi,\n"
"                         tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"void\n"
"OsdEvalPatchBezierTriangleTessLevels(\n"
"         const float OsdTessLevels,\n"
"         const float4x4 OsdProjectionMatrix,\n"
"         const float4x4 OsdModelViewMatrix,\n"
"         float3 cv[15],\n"
"         int3 patchParam,\n"
"         thread float4& tessLevelOuter, thread float2& tessLevelInner,\n"
"         thread float4& tessOuterLo, thread float4& tessOuterHi)\n"
"{\n"
"    OsdEvalPatchBezierTriangleTessLevels(\n"
"                OsdTessLevels,\n"
"                OsdProjectionMatrix, OsdModelViewMatrix,\n"
"                cv, patchParam,\n"
"                tessOuterLo, tessOuterHi);\n"
"\n"
"    OsdComputeTessLevelsTriangle(tessOuterLo, tessOuterHi,\n"
"                                 tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"void\n"
"OsdGetTessLevelsAdaptiveRefinedPoints(\n"
"    const float OsdTessLevel,\n"
"    const float4x4 OsdProjectionMatrix,\n"
"    const float4x4 OsdModelViewMatrix,\n"
"    float3 cpRefined[16], int3 patchParam,\n"
"    thread float4& tessLevelOuter, thread float2& tessLevelInner,\n"
"    thread float4& tessOuterLo, thread float4& tessOuterHi)\n"
"{\n"
"    OsdGetTessLevelsRefinedPoints(OsdTessLevel,\n"
"                                  OsdProjectionMatrix, OsdModelViewMatrix,\n"
"                                  cpRefined, patchParam,\n"
"                                  tessOuterLo, tessOuterHi);\n"
"\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi,\n"
"                         tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of newer Bezier patch equivalent:\n"
"void\n"
"OsdGetTessLevelsLimitPoints(\n"
"    const float OsdTessLevel,\n"
"    const float4x4 OsdProjectionMatrix,\n"
"    const float4x4 OsdModelViewMatrix,\n"
"    device OsdPerPatchVertexBezier* cpBezier,\n"
"    int3 patchParam,\n"
"    thread float4& tessOuterLo, thread float4& tessOuterHi)\n"
"{\n"
"    OsdEvalPatchBezierTessLevels(\n"
"        OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,\n"
"        cpBezier, patchParam, tessOuterLo, tessOuterHi);\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of newer Bezier patch equivalent:\n"
"void\n"
"OsdGetTessLevelsAdaptiveLimitPoints(\n"
"        const float OsdTessLevel,\n"
"        const float4x4 OsdProjectionMatrix,\n"
"        const float4x4 OsdModelViewMatrix,\n"
"        device OsdPerPatchVertexBezier* cpBezier,\n"
"        int3 patchParam,\n"
"        thread float4& tessLevelOuter, thread float2& tessLevelInner,\n"
"        thread float4& tessOuterLo, thread float4& tessOuterHi)\n"
"{\n"
"    OsdGetTessLevelsLimitPoints(OsdTessLevel,\n"
"                                OsdProjectionMatrix, OsdModelViewMatrix,\n"
"                                cpBezier, patchParam,\n"
"                                tessOuterLo, tessOuterHi);\n"
"\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi,\n"
"                         tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of newer Bezier patch equivalent:\n"
"void\n"
"OsdGetTessLevels(\n"
"        const float OsdTessLevel,\n"
"        const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,\n"
"        float3 cp0, float3 cp1, float3 cp2, float3 cp3, int3 patchParam,\n"
"        thread float4& tessLevelOuter, thread float2& tessLevelInner)\n"
"{\n"
"    float4 tessOuterLo = float4(0);\n"
"    float4 tessOuterHi = float4(0);\n"
"\n"
"#if OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    tessOuterLo[0] = OsdComputeTessLevel(\n"
"        OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp0, cp1);\n"
"    tessOuterLo[1] = OsdComputeTessLevel(\n"
"        OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp0, cp3);\n"
"    tessOuterLo[2] = OsdComputeTessLevel(\n"
"        OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp2, cp3);\n"
"    tessOuterLo[3] = OsdComputeTessLevel(\n"
"        OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp1, cp2);\n"
"#else\n"
"    OsdGetTessLevelsUniform(OsdTessLevel, patchParam, tessOuterLo, tessOuterHi);\n"
"#endif\n"
"\n"
"    OsdComputeTessLevels(tessOuterLo, tessOuterHi,\n"
"                         tessLevelOuter, tessLevelInner);\n"
"}\n"
"\n"
"#if defined OSD_FRACTIONAL_EVEN_SPACING || defined OSD_FRACTIONAL_ODD_SPACING\n"
"float\n"
"OsdGetTessFractionalSplit(float t, float level, float levelUp)\n"
"{\n"
"    // Fractional tessellation of an edge will produce n segments where n\n"
"    // is the tessellation level of the edge (level) rounded up to the\n"
"    // nearest even or odd integer (levelUp). There will be n-2 segments of\n"
"    // equal length (dx1) and two additional segments of equal length (dx0)\n"
"    // that are typically shorter than the other segments. The two additional\n"
"    // segments should be placed symmetrically on opposite sides of the\n"
"    // edge (offset).\n"
"\n"
"#if defined OSD_FRACTIONAL_EVEN_SPACING\n"
"    if (level <= 2) return t;\n"
"\n"
"    float base = pow(2.0,floor(log2(levelUp)));\n"
"    float offset = 1.0/(int(2*base-levelUp)/2 & int(base/2-1));\n"
"\n"
"#elif defined OSD_FRACTIONAL_ODD_SPACING\n"
"    if (level <= 1) return t;\n"
"\n"
"    float base = pow(2.0,floor(log2(levelUp)));\n"
"    float offset = 1.0/(((int(2*base-levelUp)/2+1) & int(base/2-1))+1);\n"
"#endif\n"
"\n"
"    float dx0 = (1.0 - (levelUp-level)/2) / levelUp;\n"
"    float dx1 = (1.0 - 2.0*dx0) / (levelUp - 2.0*ceil(dx0));\n"
"\n"
"    if (t < 0.5) {\n"
"        float x = levelUp/2 - round(t*levelUp);\n"
"        return 0.5 - (x*dx1 + int(x*offset > 1) * (dx0 - dx1));\n"
"    } else if (t > 0.5) {\n"
"        float x = round(t*levelUp) - levelUp/2;\n"
"        return 0.5 + (x*dx1 + int(x*offset > 1) * (dx0 - dx1));\n"
"    } else {\n"
"        return t;\n"
"    }\n"
"}\n"
"#endif\n"
"\n"
"float\n"
"OsdGetTessTransitionSplit(float t, float lo, float hi)\n"
"{\n"
"#if defined OSD_FRACTIONAL_EVEN_SPACING\n"
"    float loRoundUp = OsdRoundUpEven(lo);\n"
"    float hiRoundUp = OsdRoundUpEven(hi);\n"
"\n"
"    // Convert the parametric t into a segment index along the combined edge.\n"
"    float ti = round(t * (loRoundUp + hiRoundUp));\n"
"\n"
"    if (ti <= loRoundUp) {\n"
"        float t0 = ti / loRoundUp;\n"
"        return OsdGetTessFractionalSplit(t0, lo, loRoundUp) * 0.5;\n"
"    } else {\n"
"        float t1 = (ti - loRoundUp) / hiRoundUp;\n"
"        return OsdGetTessFractionalSplit(t1, hi, hiRoundUp) * 0.5 + 0.5;\n"
"    }\n"
"#elif defined OSD_FRACTIONAL_ODD_SPACING\n"
"    float loRoundUp = OsdRoundUpOdd(lo);\n"
"    float hiRoundUp = OsdRoundUpOdd(hi);\n"
"\n"
"    // Convert the parametric t into a segment index along the combined edge.\n"
"    // The +1 below is to account for the extra segment produced by the\n"
"    // tessellator since the sum of two odd tess levels will be rounded\n"
"    // up by one to the next odd integer tess level.\n"
"    float ti = round(t * (loRoundUp + hiRoundUp + 1));\n"
"\n"
"    if (ti <= loRoundUp) {\n"
"        float t0 = ti / loRoundUp;\n"
"        return OsdGetTessFractionalSplit(t0, lo, loRoundUp) * 0.5;\n"
"    } else if (ti > (loRoundUp+1)) {\n"
"        float t1 = (ti - (loRoundUp+1)) / hiRoundUp;\n"
"        return OsdGetTessFractionalSplit(t1, hi, hiRoundUp) * 0.5 + 0.5;\n"
"    } else {\n"
"        return 0.5;\n"
"    }\n"
"#else\n"
"    // Convert the parametric t into a segment index along the combined edge.\n"
"    float ti = round(t * (lo + hi));\n"
"\n"
"    if (ti <= lo) {\n"
"        return (ti / lo) * 0.5;\n"
"    } else {\n"
"        return ((ti - lo) / hi) * 0.5 + 0.5;\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"float2\n"
"OsdGetTessParameterization(float2 p, float4 tessOuterLo, float4 tessOuterHi)\n"
"{\n"
"    float2 UV = p;\n"
"    if (p.x == 0 && tessOuterHi[0] > 0) {\n"
"        UV.y = OsdGetTessTransitionSplit(UV.y, tessOuterLo[0], tessOuterHi[0]);\n"
"    } else\n"
"    if (p.y == 0 && tessOuterHi[1] > 0) {\n"
"        UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[1], tessOuterHi[1]);\n"
"    } else\n"
"    if (p.x == 1 && tessOuterHi[2] > 0) {\n"
"        UV.y = OsdGetTessTransitionSplit(UV.y, tessOuterLo[2], tessOuterHi[2]);\n"
"    } else\n"
"    if (p.y == 1 && tessOuterHi[3] > 0) {\n"
"        UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[3], tessOuterHi[3]);\n"
"    }\n"
"    return UV;\n"
"}\n"
"\n"
"float2\n"
"OsdGetTessParameterizationTriangle(float3 p, float4 tessOuterLo, float4 tessOuterHi)\n"
"{\n"
"    float2 UV = p.xy;\n"
"    if (p.x == 0 && tessOuterHi[0] > 0) {\n"
"        UV.y = OsdGetTessTransitionSplit(UV.y, tessOuterLo[0], tessOuterHi[0]);\n"
"    } else\n"
"    if (p.y == 0 && tessOuterHi[1] > 0) {\n"
"        UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[1], tessOuterHi[1]);\n"
"    } else\n"
"    if (p.z == 0 && tessOuterHi[2] > 0) {\n"
"        UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[2], tessOuterHi[2]);\n"
"        UV.y = 1.0 - UV.x;\n"
"    }\n"
"    return UV;\n"
"}\n"
"\n"
);
static std::string patchLegacyShaderSource(
"#line 0 \"osd/mtlPatchBoxSplineTriangle.metal\"\n"
"\n"
"//\n"
"//   Copyright 2015-2019 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Common\n"
"//----------------------------------------------------------\n"
"\n"
"#define offsetof_(X, Y) &(((device X*)nullptr)->Y)\n"
"\n"
"#define OSD_IS_ADAPTIVE (OSD_PATCH_REGULAR || OSD_PATCH_BOX_SPLINE_TRIANGLE || OSD_PATCH_GREGORY_BASIS || OSD_PATCH_GREGORY_TRIANGLE || OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY)\n"
"\n"
"#ifndef OSD_NUM_ELEMENTS\n"
"#define OSD_NUM_ELEMENTS 3\n"
"#endif\n"
"\n"
"struct OsdPerVertexGregory {\n"
"    float3 P;\n"
"    short3 clipFlag;\n"
"    int valence;\n"
"    float3 e0;\n"
"    float3 e1;\n"
"#if OSD_PATCH_GREGORY_BOUNDARY\n"
"    int zerothNeighbor;\n"
"    float3 org;\n"
"#endif\n"
"    float3 r[OSD_MAX_VALENCE];\n"
"};\n"
"\n"
"struct OsdPerPatchVertexGregory {\n"
"    packed_float3 P;\n"
"    packed_float3 Ep;\n"
"    packed_float3 Em;\n"
"    packed_float3 Fp;\n"
"    packed_float3 Fm;\n"
"};\n"
"\n"
"//----------------------------------------------------------\n"
"// HLSL->Metal Compatibility\n"
"//----------------------------------------------------------\n"
"\n"
"float4 mul(float4x4 a, float4 b)\n"
"{\n"
"    return a * b;\n"
"}\n"
"\n"
"float3 mul(float4x4 a, float3 b)\n"
"{\n"
"    float3x3 m(a[0].xyz, a[1].xyz, a[2].xyz);\n"
"    return m * b;\n"
"\n"
"}\n"
"\n"
"struct HullVertex {\n"
"    float4 position;\n"
"#if OSD_ENABLE_PATCH_CULL\n"
"    short3 clipFlag;\n"
"#endif\n"
"\n"
"    float3 GetPosition() threadgroup\n"
"    {\n"
"        return position.xyz;\n"
"    }\n"
"\n"
"    void SetPosition(float3 v) threadgroup\n"
"    {\n"
"        position.xyz = v;\n"
"    }\n"
"};\n"
"\n"
"// XXXdyu all downstream data can be handled by client code\n"
"struct OsdPatchVertex {\n"
"    float3 position;\n"
"    float3 normal;\n"
"    float3 tangent;\n"
"    float3 bitangent;\n"
"    float4 patchCoord; //u, v, faceLevel, faceId\n"
"    float2 tessCoord; // tesscoord.st\n"
"#if OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    float3 Nu;\n"
"    float3 Nv;\n"
"#endif\n"
"#if OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    float2 vSegments;\n"
"#endif\n"
"};\n"
"\n"
"struct OsdPerPatchTessFactors {\n"
"    float4 tessOuterLo;\n"
"    float4 tessOuterHi;\n"
"};\n"
"\n"
"using OsdPatchParamBufferType = packed_int3;\n"
"\n"
"#if OSD_PATCH_REGULAR || OSD_PATCH_BOX_SPLINE_TRIANGLE\n"
"using PatchVertexType = HullVertex;\n"
"using PerPatchVertexType = OsdPerPatchVertexBezier;\n"
"#elif OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY\n"
"using PatchVertexType = OsdPerVertexGregory;\n"
"using PerPatchVertexType = OsdPerPatchVertexGregory;\n"
"#elif OSD_PATCH_GREGORY_BASIS || OSD_PATCH_GREGORY_TRIANGLE\n"
"using PatchVertexType = HullVertex;\n"
"using PerPatchVertexType = OsdPerPatchVertexGregoryBasis;\n"
"#else\n"
"using PatchVertexType = OsdInputVertexType;\n"
"using PerPatchVertexType = OsdInputVertexType;\n"
"#endif\n"
"\n"
"//Shared buffers used by OSD that are common to all kernels\n"
"struct OsdPatchParamBufferSet\n"
"{\n"
"    const device OsdInputVertexType* vertexBuffer [[buffer(VERTEX_BUFFER_INDEX)]];\n"
"    const device unsigned* indexBuffer [[buffer(CONTROL_INDICES_BUFFER_INDEX)]];\n"
"\n"
"    const device OsdPatchParamBufferType* patchParamBuffer [[buffer(OSD_PATCHPARAM_BUFFER_INDEX)]];\n"
"\n"
"    device PerPatchVertexType* perPatchVertexBuffer [[buffer(OSD_PERPATCHVERTEX_BUFFER_INDEX)]];\n"
"\n"
"#if !USE_PTVS_FACTORS\n"
"    device OsdPerPatchTessFactors* patchTessBuffer [[buffer(OSD_PERPATCHTESSFACTORS_BUFFER_INDEX)]];\n"
"#endif\n"
"\n"
"#if OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY\n"
"    const device int* quadOffsetBuffer [[buffer(OSD_QUADOFFSET_BUFFER_INDEX)]];\n"
"    const device int* valenceBuffer [[buffer(OSD_VALENCE_BUFFER_INDEX)]];\n"
"#endif\n"
"\n"
"    const constant unsigned& kernelExecutionLimit [[buffer(OSD_KERNELLIMIT_BUFFER_INDEX)]];\n"
"};\n"
"\n"
"//Shared buffers used by OSD that are common to all PTVS implementations\n"
"struct OsdVertexBufferSet\n"
"{\n"
"    const device OsdInputVertexType* vertexBuffer [[buffer(VERTEX_BUFFER_INDEX)]];\n"
"    const device unsigned* indexBuffer [[buffer(CONTROL_INDICES_BUFFER_INDEX)]];\n"
"\n"
"    const device OsdPatchParamBufferType* patchParamBuffer [[buffer(OSD_PATCHPARAM_BUFFER_INDEX)]];\n"
"\n"
"    device PerPatchVertexType* perPatchVertexBuffer [[buffer(OSD_PERPATCHVERTEX_BUFFER_INDEX)]];\n"
"\n"
"#if !USE_PTVS_FACTORS\n"
"    device OsdPerPatchTessFactors* patchTessBuffer [[buffer(OSD_PERPATCHTESSFACTORS_BUFFER_INDEX)]];\n"
"#endif\n"
"};\n"
"\n"
"// These are stored in OsdPatchParamBuffer indexed by the value returned\n"
"// from OsdGetPatchIndex() which is a function of the current PrimitiveID\n"
"// along with an optional client provided offset.\n"
"\n"
"int3 OsdGetPatchParam(int patchIndex, const device OsdPatchParamBufferType* osdPatchParamBuffer)\n"
"{\n"
"#if OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    return int3(osdPatchParamBuffer[patchIndex]);\n"
"#else\n"
"    auto p = osdPatchParamBuffer[patchIndex];\n"
"    return int3(p[0], p[1], 0);\n"
"#endif\n"
"}\n"
"\n"
"int OsdGetPatchIndex(int primitiveId)\n"
"{\n"
"    return primitiveId;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// patch culling\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"bool OsdCullPerPatchVertex(\n"
"        threadgroup PatchVertexType* patch,\n"
"        float4x4 ModelViewMatrix\n"
"        )\n"
"{\n"
"#if OSD_ENABLE_BACKPATCH_CULL && OSD_PATCH_REGULAR\n"
"    auto v0 = float3(ModelViewMatrix * patch[5].position);\n"
"    auto v3 = float3(ModelViewMatrix * patch[6].position);\n"
"    auto v12 = float3(ModelViewMatrix * patch[9].position);\n"
"\n"
"    auto n = normalize(cross(v3 - v0, v12 - v0));\n"
"    v0 = normalize(v0 + v3 + v12);\n"
"\n"
"    if(dot(v0, n) > 0.6f)\n"
"    {\n"
"        return false;\n"
"    }\n"
"#endif\n"
"#if OSD_ENABLE_PATCH_CULL\n"
"    short3 clipFlag = short3(0,0,0);\n"
"    for(int i = 0; i < CONTROL_POINTS_PER_PATCH; ++i) {\n"
"        clipFlag |= patch[i].clipFlag;\n"
"    }\n"
"    if (any(clipFlag != short3(3,3,3))) {\n"
"        return false;\n"
"    }\n"
"#endif\n"
"    return true;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Legacy Gregory\n"
"// ----------------------------------------------------------------------------\n"
"#if defined(OSD_PATCH_GREGORY) || defined(OSD_PATCH_GREGORY_BOUNDARY)\n"
"\n"
"// precomputed catmark coefficient table up to valence 29\n"
"constant float OsdCatmarkCoefficient[30] = {\n"
"    0, 0, 0, 0.812816, 0.500000, 0.363644, 0.287514,\n"
"    0.238688, 0.204544, 0.179229, 0.159657,\n"
"    0.144042, 0.131276, 0.120632, 0.111614,\n"
"    0.103872, 0.09715, 0.0912559, 0.0860444,\n"
"    0.0814022, 0.0772401, 0.0734867, 0.0700842,\n"
"    0.0669851, 0.0641504, 0.0615475, 0.0591488,\n"
"    0.0569311, 0.0548745, 0.0529621\n"
"};\n"
"\n"
"float\n"
"OsdComputeCatmarkCoefficient(int valence)\n"
"{\n"
"#if OSD_MAX_VALENCE < 30\n"
"    return OsdCatmarkCoefficient[valence];\n"
"#else\n"
"    if (valence < 30) {\n"
"        return OsdCatmarkCoefficient[valence];\n"
"    } else {\n"
"        float t = 2.0f / float(valence);\n"
"        return 1.0f / (valence * (cospi(t) + 5.0f +\n"
"                                  sqrt((cospi(t) + 9) * (cospi(t) + 1)))/16.0f);\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"float cosfn(int n, int j) {\n"
"    return cospi((2.0f * j)/float(n));\n"
"}\n"
"\n"
"float sinfn(int n, int j) {\n"
"    return sinpi((2.0f * j)/float(n));\n"
"}\n"
"\n"
"#ifndef OSD_MAX_VALENCE\n"
"#define OSD_MAX_VALENCE 4\n"
"#endif\n"
"\n"
"template<typename OsdVertexBuffer>\n"
"float3 OsdReadVertex(int vertexIndex, OsdVertexBuffer osdVertexBuffer)\n"
"{\n"
"    int index = (vertexIndex /*+ OsdBaseVertex()*/);\n"
"    return osdVertexBuffer[index].position;\n"
"}\n"
"\n"
"template<typename OsdValenceBuffer>\n"
"int OsdReadVertexValence(int vertexID, OsdValenceBuffer osdValenceBuffer)\n"
"{\n"
"    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1));\n"
"    return osdValenceBuffer[index];\n"
"}\n"
"\n"
"template<typename OsdValenceBuffer>\n"
"int OsdReadVertexIndex(int vertexID, int valenceVertex, OsdValenceBuffer osdValenceBuffer)\n"
"{\n"
"    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1) + 1 + valenceVertex);\n"
"    return osdValenceBuffer[index];\n"
"}\n"
"\n"
"template<typename OsdQuadOffsetBuffer>\n"
"int OsdReadQuadOffset(int primitiveID, int offsetVertex, OsdQuadOffsetBuffer osdQuadOffsetBuffer)\n"
"{\n"
"    int index = int(4*primitiveID + offsetVertex);\n"
"    return osdQuadOffsetBuffer[index];\n"
"}\n"
"\n"
"\n"
"void OsdComputePerVertexGregory(unsigned vID, float3 P, threadgroup OsdPerVertexGregory& v, OsdPatchParamBufferSet osdBuffers)\n"
"{\n"
"    v.clipFlag = short3(0,0,0);\n"
"\n"
"    int ivalence = OsdReadVertexValence(vID, osdBuffers.valenceBuffer);\n"
"    v.valence = ivalence;\n"
"    int valence = abs(ivalence);\n"
"\n"
"    float3 f[OSD_MAX_VALENCE];\n"
"    float3 pos = P;\n"
"    float3 opos = float3(0,0,0);\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    v.org = pos;\n"
"    int boundaryEdgeNeighbors[2];\n"
"    int currNeighbor = 0;\n"
"    int ibefore = 0;\n"
"    int zerothNeighbor = 0;\n"
"#endif\n"
"\n"
"    for (int i=0; i<valence; ++i) {\n"
"        int im = (i+valence-1)%valence;\n"
"        int ip = (i+1)%valence;\n"
"\n"
"        int idx_neighbor = OsdReadVertexIndex(vID, 2*i, osdBuffers.valenceBuffer);\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"        bool isBoundaryNeighbor = false;\n"
"        int valenceNeighbor = OsdReadVertexValence(idx_neighbor, osdBuffers.valenceBuffer);\n"
"\n"
"        if (valenceNeighbor < 0) {\n"
"            isBoundaryNeighbor = true;\n"
"            if (currNeighbor<2) {\n"
"                boundaryEdgeNeighbors[currNeighbor] = idx_neighbor;\n"
"            }\n"
"            currNeighbor++;\n"
"            if (currNeighbor == 1) {\n"
"                ibefore = i;\n"
"                zerothNeighbor = i;\n"
"            } else {\n"
"                if (i-ibefore == 1) {\n"
"                    int tmp = boundaryEdgeNeighbors[0];\n"
"                    boundaryEdgeNeighbors[0] = boundaryEdgeNeighbors[1];\n"
"                    boundaryEdgeNeighbors[1] = tmp;\n"
"                    zerothNeighbor = i;\n"
"                }\n"
"            }\n"
"        }\n"
"#endif\n"
"\n"
"        float3 neighbor = OsdReadVertex(idx_neighbor, osdBuffers.vertexBuffer);\n"
"\n"
"        int idx_diagonal = OsdReadVertexIndex(vID, 2*i + 1, osdBuffers.valenceBuffer);\n"
"        float3 diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);\n"
"\n"
"        int idx_neighbor_p = OsdReadVertexIndex(vID, 2*ip, osdBuffers.valenceBuffer);\n"
"        float3 neighbor_p = OsdReadVertex(idx_neighbor_p, osdBuffers.vertexBuffer);\n"
"\n"
"        int idx_neighbor_m = OsdReadVertexIndex(vID, 2*im, osdBuffers.valenceBuffer);\n"
"        float3 neighbor_m = OsdReadVertex(idx_neighbor_m, osdBuffers.vertexBuffer);\n"
"\n"
"        int idx_diagonal_m = OsdReadVertexIndex(vID, 2*im + 1, osdBuffers.valenceBuffer);\n"
"        float3 diagonal_m = OsdReadVertex(idx_diagonal_m, osdBuffers.vertexBuffer);\n"
"\n"
"        f[i] = (pos * float(valence) + (neighbor_p + neighbor)*2.0f + diagonal) / (float(valence)+5.0f);\n"
"\n"
"        opos += f[i];\n"
"        v.r[i] = (neighbor_p-neighbor_m)/3.0f + (diagonal - diagonal_m)/6.0f;\n"
"    }\n"
"\n"
"    opos /= valence;\n"
"    v.P = float4(opos, 1.0f).xyz;\n"
"\n"
"    float3 e;\n"
"    v.e0 = float3(0,0,0);\n"
"    v.e1 = float3(0,0,0);\n"
"\n"
"    for(int i=0; i<valence; ++i) {\n"
"        int im = (i + valence -1) % valence;\n"
"        e = 0.5f * (f[i] + f[im]);\n"
"        v.e0 += cosfn(valence, i)*e;\n"
"        v.e1 += sinfn(valence, i)*e;\n"
"    }\n"
"    float ef = OsdComputeCatmarkCoefficient(valence);\n"
"    v.e0 *= ef;\n"
"    v.e1 *= ef;\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    v.zerothNeighbor = zerothNeighbor;\n"
"    if (currNeighbor == 1) {\n"
"        boundaryEdgeNeighbors[1] = boundaryEdgeNeighbors[0];\n"
"    }\n"
"\n"
"    if (ivalence < 0) {\n"
"        if (valence > 2) {\n"
"            v.P = (OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) +\n"
"                   OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer) +\n"
"                   4.0f * pos)/6.0f;\n"
"        } else {\n"
"            v.P = pos;\n"
"        }\n"
"\n"
"        v.e0 = (OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) -\n"
"                OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer))/6.0;\n"
"\n"
"        float k = float(float(valence) - 1.0f);    //k is the number of faces\n"
"        float c = cospi(1.0/k);\n"
"        float s = sinpi(1.0/k);\n"
"        float gamma = -(4.0f*s)/(3.0f*k+c);\n"
"        float alpha_0k = -((1.0f+2.0f*c)*sqrt(1.0f+c))/((3.0f*k+c)*sqrt(1.0f-c));\n"
"        float beta_0 = s/(3.0f*k + c);\n"
"\n"
"        int idx_diagonal = OsdReadVertexIndex(vID, 2*zerothNeighbor + 1, osdBuffers.valenceBuffer);\n"
"        float3 diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);\n"
"\n"
"        v.e1 = gamma * pos +\n"
"            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) +\n"
"            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer) +\n"
"            beta_0 * diagonal;\n"
"\n"
"        for (int x=1; x<valence - 1; ++x) {\n"
"            int curri = ((x + zerothNeighbor)%valence);\n"
"            float alpha = (4.0f*sinpi((float(x))/k))/(3.0f*k+c);\n"
"            float beta = (sinpi((float(x))/k) + sinpi((float(x+1))/k))/(3.0f*k+c);\n"
"\n"
"            int idx_neighbor = OsdReadVertexIndex(vID, 2*curri, osdBuffers.valenceBuffer);\n"
"            float3 neighbor = OsdReadVertex(idx_neighbor, osdBuffers.vertexBuffer);\n"
"\n"
"            idx_diagonal = OsdReadVertexIndex(vID, 2*curri + 1, osdBuffers.valenceBuffer);\n"
"            diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);\n"
"\n"
"            v.e1 += alpha * neighbor + beta * diagonal;\n"
"        }\n"
"\n"
"        v.e1 /= 3.0f;\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"void\n"
"OsdComputePerPatchVertexGregory(int3 patchParam, unsigned ID, unsigned primitiveID,\n"
"                                threadgroup OsdPerVertexGregory* v,\n"
"                                device OsdPerPatchVertexGregory& result,\n"
"                                OsdPatchParamBufferSet osdBuffers)\n"
"{\n"
"    result.P = v[ID].P;\n"
"\n"
"    int i = ID;\n"
"    int ip = (i+1)%4;\n"
"    int im = (i+3)%4;\n"
"    int valence = abs(v[i].valence);\n"
"    int n = valence;\n"
"\n"
"    int start = OsdReadQuadOffset(primitiveID, i, osdBuffers.quadOffsetBuffer) & 0xff;\n"
"    int prev = (OsdReadQuadOffset(primitiveID, i, osdBuffers.quadOffsetBuffer) >> 8) & 0xff;\n"
"\n"
"    int start_m = OsdReadQuadOffset(primitiveID, im, osdBuffers.quadOffsetBuffer) & 0xff;\n"
"    int prev_p = (OsdReadQuadOffset(primitiveID, ip, osdBuffers.quadOffsetBuffer) >> 8) & 0xff;\n"
"\n"
"    int np = abs(v[ip].valence);\n"
"    int nm = abs(v[im].valence);\n"
"\n"
"    // Control Vertices based on :\n"
"    // \"Approximating Subdivision Surfaces with Gregory Patches\n"
"    //  for Hardware Tessellation\"\n"
"    // Loop, Schaefer, Ni, Castano (ACM ToG Siggraph Asia 2009)\n"
"    //\n"
"    //  P3         e3-      e2+         P2\n"
"    //     O--------O--------O--------O\n"
"    //     |        |        |        |\n"
"    //     |        |        |        |\n"
"    //     |        | f3-    | f2+    |\n"
"    //     |        O        O        |\n"
"    // e3+ O------O            O------O e2-\n"
"    //     |     f3+          f2-     |\n"
"    //     |                          |\n"
"    //     |                          |\n"
"    //     |      f0-         f1+     |\n"
"    // e0- O------O            O------O e1+\n"
"    //     |        O        O        |\n"
"    //     |        | f0+    | f1-    |\n"
"    //     |        |        |        |\n"
"    //     |        |        |        |\n"
"    //     O--------O--------O--------O\n"
"    //  P0         e0+      e1-         P1\n"
"    //\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    float3 Em_ip;\n"
"    if (v[ip].valence < -2) {\n"
"        int j = (np + prev_p - v[ip].zerothNeighbor) % np;\n"
"        Em_ip = v[ip].P + cospi(j/float(np-1))*v[ip].e0 + sinpi(j/float(np-1))*v[ip].e1;\n"
"    } else {\n"
"        Em_ip = v[ip].P + v[ip].e0*cosfn(np, prev_p) + v[ip].e1*sinfn(np, prev_p);\n"
"    }\n"
"\n"
"    float3 Ep_im;\n"
"    if (v[im].valence < -2) {\n"
"        int j = (nm + start_m - v[im].zerothNeighbor) % nm;\n"
"        Ep_im = v[im].P + cospi(j/float(nm-1))*v[im].e0 + sinpi(j/float(nm-1))*v[im].e1;\n"
"    } else {\n"
"        Ep_im = v[im].P + v[im].e0*cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);\n"
"    }\n"
"\n"
"    if (v[i].valence < 0) {\n"
"        n = (n-1)*2;\n"
"    }\n"
"    if (v[im].valence < 0) {\n"
"        nm = (nm-1)*2;\n"
"    }\n"
"    if (v[ip].valence < 0) {\n"
"        np = (np-1)*2;\n"
"    }\n"
"\n"
"    if (v[i].valence > 2) {\n"
"        result.Ep = v[i].P + (v[i].e0*cosfn(n, start) + v[i].e1*sinfn(n, start));\n"
"        result.Em = v[i].P + (v[i].e0*cosfn(n, prev) +  v[i].e1*sinfn(n, prev));\n"
"\n"
"        float s1=3-2*cosfn(n,1)-cosfn(np,1);\n"
"        float s2=2*cosfn(n,1);\n"
"\n"
"        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"        s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));\n"
"        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"\n"
"    } else if (v[i].valence < -2) {\n"
"        int j = (valence + start - v[i].zerothNeighbor) % valence;\n"
"\n"
"        result.Ep = v[i].P + cospi(j/float(valence-1))*v[i].e0 + sinpi(j/float(valence-1))*v[i].e1;\n"
"        j = (valence + prev - v[i].zerothNeighbor) % valence;\n"
"        result.Em = v[i].P + cospi(j/float(valence-1))*v[i].e0 + sinpi(j/float(valence-1))*v[i].e1;\n"
"\n"
"        float3 Rp = ((-2.0f * v[i].org - 1.0f * v[im].org) + (2.0f * v[ip].org + 1.0f * v[(i+2)%4].org))/3.0f;\n"
"        float3 Rm = ((-2.0f * v[i].org - 1.0f * v[ip].org) + (2.0f * v[im].org + 1.0f * v[(i+2)%4].org))/3.0f;\n"
"\n"
"        float s1 = 3-2*cosfn(n,1)-cosfn(np,1);\n"
"        float s2 = 2*cosfn(n,1);\n"
"\n"
"        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"        s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));\n"
"        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"\n"
"        if (v[im].valence < 0) {\n"
"            s1 = 3-2*cosfn(n,1)-cosfn(np,1);\n"
"            result.Fp = result.Fm = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"        } else if (v[ip].valence < 0) {\n"
"            s1 = 3.0f-2.0f*cospi(2.0f/n)-cospi(2.0f/nm);\n"
"            result.Fm = result.Fp = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;\n"
"        }\n"
"\n"
"    } else if (v[i].valence == -2) {\n"
"        result.Ep = (2.0f * v[i].org + v[ip].org)/3.0f;\n"
"        result.Em = (2.0f * v[i].org + v[im].org)/3.0f;\n"
"        result.Fp = result.Fm = (4.0f * v[i].org + v[(i+2)%n].org + 2.0f * v[ip].org + 2.0f * v[im].org)/9.0f;\n"
"    }\n"
"\n"
"#else // not OSD_PATCH_GREGORY_BOUNDARY\n"
"\n"
"    result.Ep = v[i].P + v[i].e0 * cosfn(n, start) + v[i].e1*sinfn(n, start);\n"
"    result.Em = v[i].P + v[i].e0 * cosfn(n, prev ) + v[i].e1*sinfn(n, prev );\n"
"\n"
"    float3 Em_ip = v[ip].P + v[ip].e0*cosfn(np, prev_p) + v[ip].e1*sinfn(np, prev_p);\n"
"    float3 Ep_im = v[im].P + v[im].e0*cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);\n"
"\n"
"    float s1 = 3-2*cosfn(n,1)-cosfn(np,1);\n"
"    float s2 = 2*cosfn(n,1);\n"
"\n"
"    result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;\n"
"    s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));\n"
"    result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em +s2*Ep_im - v[i].r[prev])/3.0f;\n"
"#endif\n"
"}\n"
"\n"
"#endif  // OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY\n"
"\n"
);
static std::string patchBasisTypesShaderSource(
"//\n"
"//   Copyright 2018 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"#ifndef OPENSUBDIV3_OSD_PATCH_BASIS_TYPES_H\n"
"#define OPENSUBDIV3_OSD_PATCH_BASIS_TYPES_H\n"
"\n"
"/// This is an implementation of the functionality from osd/types.h\n"
"/// which can be used from client shader and kernel code, i.e for\n"
"/// GLSL, HLSL, CUDA, OpenCL, Metal, and C++ shaders and kernels.\n"
"///\n"
"/// This is defined within the OpenSubdiv::Osd namespace for C++, but\n"
"/// the methods and types also have an Osd prefix for consistency with\n"
"/// environments (e.g. GLSL, etc.) where C++ namespaces are not available.\n"
"\n"
"#if !defined(OSD_PATCH_BASIS_GLSL) && "
"    !defined(OSD_PATCH_BASIS_HLSL) && "
"    !defined(OSD_PATCH_BASIS_CUDA) && "
"    !defined(OSD_PATCH_BASIS_OPENCL) && "
"    !defined(OSD_PATCH_BASIS_METAL)\n"
"\n"
"#include \"../version.h\"\n"
"\n"
"namespace OpenSubdiv {\n"
"namespace OPENSUBDIV_VERSION {\n"
"\n"
"namespace Osd {\n"
"\n"
"#endif\n"
"\n"
"#if defined(OSD_PATCH_BASIS_GLSL)\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS\n"
"    #define OSD_DATA_STORAGE_CLASS\n"
"    #define OSD_REAL float\n"
"    #define OSD_REAL_CAST float\n"
"    #define OSD_OPTIONAL(a) true\n"
"    #define OSD_OPTIONAL_INIT(a,b) b\n"
"    #define OSD_ARRAY_ARG_BOUND_OPTIONAL 0\n"
"    #define OSD_IN_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_OUT_ARRAY(elementType, identifier, arraySize) "
"            out elementType identifier[arraySize]\n"
"    #define OSD_INOUT_ARRAY(elementType, identifier, arraySize) "
"            inout elementType identifier[arraySize]\n"
"    #define OSD_ARRAY_2(elementType,a0,a1) "
"            elementType[](a0,a1)\n"
"    #define OSD_ARRAY_3(elementType,a0,a1,a2) "
"            elementType[](a0,a1,a2)\n"
"    #define OSD_ARRAY_4(elementType,a0,a1,a2,a3) "
"            elementType[](a0,a1,a2,a3)\n"
"    #define OSD_ARRAY_6(elementType,a0,a1,a2,a3,a4,a5) "
"            elementType[](a0,a1,a2,a3,a4,a5)\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            elementType[](a0,a1,a2,a3,a4,a5,a6,a7)\n"
"    #define OSD_ARRAY_9(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8) "
"            elementType[](a0,a1,a2,a3,a4,a5,a6,a7,a8)\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            elementType[](a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)\n"
"\n"
"#elif defined(OSD_PATCH_BASIS_HLSL)\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS\n"
"    #define OSD_DATA_STORAGE_CLASS\n"
"    #define OSD_REAL float\n"
"    #define OSD_REAL_CAST float\n"
"    #define OSD_OPTIONAL(a) true\n"
"    #define OSD_OPTIONAL_INIT(a,b) b\n"
"    #define OSD_ARRAY_ARG_BOUND_OPTIONAL 0\n"
"    #define OSD_IN_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_OUT_ARRAY(elementType, identifier, arraySize) "
"            out elementType identifier[arraySize]\n"
"    #define OSD_INOUT_ARRAY(elementType, identifier, arraySize) "
"            inout elementType identifier[arraySize]\n"
"    #define OSD_ARRAY_2(elementType,a0,a1) "
"            {a0,a1}\n"
"    #define OSD_ARRAY_3(elementType,a0,a1,a2) "
"            {a0,a1,a2}\n"
"    #define OSD_ARRAY_4(elementType,a0,a1,a2,a3) "
"            {a0,a1,a2,a3}\n"
"    #define OSD_ARRAY_6(elementType,a0,a1,a2,a3,a4,a5) "
"            {a0,a1,a2,a3,a4,a5}\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            {a0,a1,a2,a3,a4,a5,a6,a7}\n"
"    #define OSD_ARRAY_9(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8}\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}\n"
"\n"
"#elif defined(OSD_PATCH_BASIS_CUDA)\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS __device__\n"
"    #define OSD_DATA_STORAGE_CLASS\n"
"    #define OSD_REAL float\n"
"    #define OSD_REAL_CAST float\n"
"    #define OSD_OPTIONAL(a) true\n"
"    #define OSD_OPTIONAL_INIT(a,b) b\n"
"    #define OSD_ARRAY_ARG_BOUND_OPTIONAL 0\n"
"    #define OSD_IN_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_OUT_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_INOUT_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_ARRAY_2(elementType,a0,a1) "
"            {a0,a1}\n"
"    #define OSD_ARRAY_3(elementType,a0,a1,a2) "
"            {a0,a1,a2}\n"
"    #define OSD_ARRAY_4(elementType,a0,a1,a2,a3) "
"            {a0,a1,a2,a3}\n"
"    #define OSD_ARRAY_6(elementType,a0,a1,a2,a3,a4,a5) "
"            {a0,a1,a2,a3,a4,a5}\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            {a0,a1,a2,a3,a4,a5,a6,a7}\n"
"    #define OSD_ARRAY_9(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8}\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}\n"
"\n"
"#elif defined(OSD_PATCH_BASIS_OPENCL)\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS static\n"
"    #define OSD_DATA_STORAGE_CLASS\n"
"    #define OSD_REAL float\n"
"    #define OSD_REAL_CAST convert_float\n"
"    #define OSD_OPTIONAL(a) true\n"
"    #define OSD_OPTIONAL_INIT(a,b) b\n"
"    #define OSD_ARRAY_ARG_BOUND_OPTIONAL 0\n"
"    #define OSD_IN_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_OUT_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_INOUT_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_ARRAY_2(elementType,a0,a1) "
"            {a0,a1}\n"
"    #define OSD_ARRAY_3(elementType,a0,a1,a2) "
"            {a0,a1,a2}\n"
"    #define OSD_ARRAY_4(elementType,a0,a1,a2,a3) "
"            {a0,a1,a2,a3}\n"
"    #define OSD_ARRAY_6(elementType,a0,a1,a2,a3,a4,a5) "
"            {a0,a1,a2,a3,a4,a5}\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            {a0,a1,a2,a3,a4,a5,a6,a7}\n"
"    #define OSD_ARRAY_9(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8}\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}\n"
"\n"
"#elif defined(OSD_PATCH_BASIS_METAL)\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS\n"
"    #define OSD_DATA_STORAGE_CLASS\n"
"    #define OSD_REAL float\n"
"    #define OSD_REAL_CAST float\n"
"    #define OSD_OPTIONAL(a) true\n"
"    #define OSD_OPTIONAL_INIT(a,b) b\n"
"    #define OSD_ARRAY_ARG_BOUND_OPTIONAL 0\n"
"    #define OSD_IN_ARRAY(elementType, identifier, arraySize) "
"            thread elementType* identifier\n"
"    #define OSD_OUT_ARRAY(elementType, identifier, arraySize) "
"            thread elementType* identifier\n"
"    #define OSD_INOUT_ARRAY(elementType, identifier, arraySize) "
"            thread elementType* identifier\n"
"    #define OSD_ARRAY_2(elementType,a0,a1) "
"            {a0,a1}\n"
"    #define OSD_ARRAY_3(elementType,a0,a1,a2) "
"            {a0,a1,a2}\n"
"    #define OSD_ARRAY_4(elementType,a0,a1,a2,a3) "
"            {a0,a1,a2,a3}\n"
"    #define OSD_ARRAY_6(elementType,a0,a1,a2,a3,a4,a5) "
"            {a0,a1,a2,a3,a4,a5}\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            {a0,a1,a2,a3,a4,a5,a6,a7}\n"
"    #define OSD_ARRAY_9(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8}\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}\n"
"\n"
"#else\n"
"\n"
"    #define OSD_FUNCTION_STORAGE_CLASS static inline\n"
"    #define OSD_DATA_STORAGE_CLASS static\n"
"    #define OSD_REAL float\n"
"    #define OSD_REAL_CAST float\n"
"    #define OSD_OPTIONAL(a) (a)\n"
"    #define OSD_OPTIONAL_INIT(a,b) (a ? b : 0)\n"
"    #define OSD_ARRAY_ARG_BOUND_OPTIONAL 1\n"
"    #define OSD_IN_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_OUT_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_INOUT_ARRAY(elementType, identifier, arraySize) "
"            elementType identifier[arraySize]\n"
"    #define OSD_ARRAY_2(elementType,a0,a1) "
"            {a0,a1}\n"
"    #define OSD_ARRAY_3(elementType,a0,a1,a2) "
"            {a0,a1,a2}\n"
"    #define OSD_ARRAY_4(elementType,a0,a1,a2,a3) "
"            {a0,a1,a2,a3}\n"
"    #define OSD_ARRAY_6(elementType,a0,a1,a2,a3,a4,a5) "
"            {a0,a1,a2,a3,a4,a5}\n"
"    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7) "
"            {a0,a1,a2,a3,a4,a5,a6,a7}\n"
"    #define OSD_ARRAY_9(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8}\n"
"    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) "
"            {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}\n"
"\n"
"#endif\n"
"\n"
"#if defined(OSD_PATCH_BASIS_OPENCL)\n"
"// OpenCL binding uses typedef to provide the required \"struct\" type specifier.\n"
"typedef struct OsdPatchParam OsdPatchParam;\n"
"typedef struct OsdPatchArray OsdPatchArray;\n"
"typedef struct OsdPatchCoord OsdPatchCoord;\n"
"#endif\n"
"\n"
"// Osd reflection of Far::PatchDescriptor\n"
"#define OSD_PATCH_DESCRIPTOR_QUADS            3\n"
"#define OSD_PATCH_DESCRIPTOR_TRIANGLES        4\n"
"#define OSD_PATCH_DESCRIPTOR_LOOP             5\n"
"#define OSD_PATCH_DESCRIPTOR_REGULAR          6\n"
"#define OSD_PATCH_DESCRIPTOR_GREGORY_BASIS    9\n"
"#define OSD_PATCH_DESCRIPTOR_GREGORY_TRIANGLE 10\n"
"\n"
"// Osd reflection of Osd::PatchCoord\n"
"struct OsdPatchCoord {\n"
"   int arrayIndex;\n"
"   int patchIndex;\n"
"   int vertIndex;\n"
"   float s;\n"
"   float t;\n"
"};\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"OsdPatchCoord\n"
"OsdPatchCoordInit(\n"
"    int arrayIndex, int patchIndex, int vertIndex, float s, float t)\n"
"{\n"
"    OsdPatchCoord coord;\n"
"    coord.arrayIndex = arrayIndex;\n"
"    coord.patchIndex = patchIndex;\n"
"    coord.vertIndex = vertIndex;\n"
"    coord.s = s;\n"
"    coord.t = t;\n"
"    return coord;\n"
"}\n"
"\n"
"// Osd reflection of Osd::PatchArray\n"
"struct OsdPatchArray {\n"
"    int regDesc;\n"
"    int desc;\n"
"    int numPatches;\n"
"    int indexBase;\n"
"    int stride;\n"
"    int primitiveIdBase;\n"
"};\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"OsdPatchArray\n"
"OsdPatchArrayInit(\n"
"    int regDesc, int desc,\n"
"    int numPatches, int indexBase, int stride, int primitiveIdBase)\n"
"{\n"
"    OsdPatchArray array;\n"
"    array.regDesc = regDesc;\n"
"    array.desc = desc;\n"
"    array.numPatches = numPatches;\n"
"    array.indexBase = indexBase;\n"
"    array.stride = stride;\n"
"    array.primitiveIdBase = primitiveIdBase;\n"
"    return array;\n"
"}\n"
"\n"
"// Osd reflection of Osd::PatchParam\n"
"struct OsdPatchParam {\n"
"    int field0;\n"
"    int field1;\n"
"    float sharpness;\n"
"};\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"OsdPatchParam\n"
"OsdPatchParamInit(int field0, int field1, float sharpness)\n"
"{\n"
"    OsdPatchParam param;\n"
"    param.field0 = field0;\n"
"    param.field1 = field1;\n"
"    param.sharpness = sharpness;\n"
"    return param;\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"OsdPatchParamGetFaceId(OsdPatchParam param)\n"
"{\n"
"    return (param.field0 & 0xfffffff);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"OsdPatchParamGetU(OsdPatchParam param)\n"
"{\n"
"    return ((param.field1 >> 22) & 0x3ff);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"OsdPatchParamGetV(OsdPatchParam param)\n"
"{\n"
"    return ((param.field1 >> 12) & 0x3ff);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"OsdPatchParamGetTransition(OsdPatchParam param)\n"
"{\n"
"    return ((param.field0 >> 28) & 0xf);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"OsdPatchParamGetBoundary(OsdPatchParam param)\n"
"{\n"
"    return ((param.field1 >> 7) & 0x1f);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"OsdPatchParamGetNonQuadRoot(OsdPatchParam param)\n"
"{\n"
"    return ((param.field1 >> 4) & 0x1);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"OsdPatchParamGetDepth(OsdPatchParam param)\n"
"{\n"
"    return (param.field1 & 0xf);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"OSD_REAL\n"
"OsdPatchParamGetParamFraction(OsdPatchParam param)\n"
"{\n"
"    return 1.0f / OSD_REAL_CAST(1 <<\n"
"        (OsdPatchParamGetDepth(param) - OsdPatchParamGetNonQuadRoot(param)));\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"bool\n"
"OsdPatchParamIsRegular(OsdPatchParam param)\n"
"{\n"
"    return (((param.field1 >> 5) & 0x1) != 0);\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"bool\n"
"OsdPatchParamIsTriangleRotated(OsdPatchParam param)\n"
"{\n"
"    return ((OsdPatchParamGetU(param) + OsdPatchParamGetV(param)) >=\n"
"            (1 << OsdPatchParamGetDepth(param)));\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdPatchParamNormalize(\n"
"        OsdPatchParam param,\n"
"        OSD_INOUT_ARRAY(OSD_REAL, uv, 2))\n"
"{\n"
"    OSD_REAL fracInv = 1.0f / OsdPatchParamGetParamFraction(param);\n"
"\n"
"    uv[0] = uv[0] * fracInv - OSD_REAL_CAST(OsdPatchParamGetU(param));\n"
"    uv[1] = uv[1] * fracInv - OSD_REAL_CAST(OsdPatchParamGetV(param));\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdPatchParamUnnormalize(\n"
"        OsdPatchParam param,\n"
"        OSD_INOUT_ARRAY(OSD_REAL, uv, 2))\n"
"{\n"
"    OSD_REAL frac = OsdPatchParamGetParamFraction(param);\n"
"\n"
"    uv[0] = (uv[0] + OSD_REAL_CAST(OsdPatchParamGetU(param))) * frac;\n"
"    uv[1] = (uv[1] + OSD_REAL_CAST(OsdPatchParamGetV(param))) * frac;\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdPatchParamNormalizeTriangle(\n"
"        OsdPatchParam param,\n"
"        OSD_INOUT_ARRAY(OSD_REAL, uv, 2))\n"
"{\n"
"    if (OsdPatchParamIsTriangleRotated(param)) {\n"
"        OSD_REAL fracInv = 1.0f / OsdPatchParamGetParamFraction(param);\n"
"\n"
"        int depthFactor = 1 << OsdPatchParamGetDepth(param);\n"
"        uv[0] = OSD_REAL_CAST(depthFactor - OsdPatchParamGetU(param)) - (uv[0] * fracInv);\n"
"        uv[1] = OSD_REAL_CAST(depthFactor - OsdPatchParamGetV(param)) - (uv[1] * fracInv);\n"
"    } else {\n"
"        OsdPatchParamNormalize(param, uv);\n"
"    }\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdPatchParamUnnormalizeTriangle(\n"
"        OsdPatchParam param,\n"
"        OSD_INOUT_ARRAY(OSD_REAL, uv, 2))\n"
"{\n"
"    if (OsdPatchParamIsTriangleRotated(param)) {\n"
"        OSD_REAL frac = OsdPatchParamGetParamFraction(param);\n"
"\n"
"        int depthFactor = 1 << OsdPatchParamGetDepth(param);\n"
"        uv[0] = (OSD_REAL_CAST(depthFactor - OsdPatchParamGetU(param)) - uv[0]) * frac;\n"
"        uv[1] = (OSD_REAL_CAST(depthFactor - OsdPatchParamGetV(param)) - uv[1]) * frac;\n"
"    } else {\n"
"        OsdPatchParamUnnormalize(param, uv);\n"
"    }\n"
"}\n"
"\n"
"#if !defined(OSD_PATCH_BASIS_GLSL) && "
"    !defined(OSD_PATCH_BASIS_HLSL) && "
"    !defined(OSD_PATCH_BASIS_CUDA) && "
"    !defined(OSD_PATCH_BASIS_OPENCL) && "
"    !defined(OSD_PATCH_BASIS_METAL)\n"
"\n"
"}  // end namespace Osd\n"
"\n"
"}  // end namespace OPENSUBDIV_VERSION\n"
"using namespace OPENSUBDIV_VERSION;\n"
"\n"
"}  // end namespace OpenSubdiv\n"
"\n"
"#endif\n"
"\n"
"#endif /* OPENSUBDIV3_OSD_PATCH_BASIS_TYPES_H */\n"
"\n"
);
static std::string patchBasisShaderSource(
"//\n"
"//   Copyright 2016-2018 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"#ifndef OPENSUBDIV3_OSD_PATCH_BASIS_H\n"
"#define OPENSUBDIV3_OSD_PATCH_BASIS_H\n"
"\n"
"/// This is an implementation of the functionality from far/patchBasis.h\n"
"/// which can be used from client shader and kernel code, i.e for\n"
"/// GLSL, HLSL, CUDA, OpenCL, Metal, and C++ shaders and kernels.\n"
"///\n"
"/// This is defined within the OpenSubdiv::Osd namespace for C++, but\n"
"/// the methods and types also have an Osd prefix for consistency with\n"
"/// environments (e.g. GLSL, etc.) where C++ namespaces are not available.\n"
"\n"
"#if !defined(OSD_PATCH_BASIS_GLSL) && "
"    !defined(OSD_PATCH_BASIS_HLSL) && "
"    !defined(OSD_PATCH_BASIS_CUDA) && "
"    !defined(OSD_PATCH_BASIS_OPENCL) && "
"    !defined(OSD_PATCH_BASIS_METAL)\n"
"\n"
"#include \"../version.h\"\n"
"\n"
"#include \"../osd/patchBasisTypes.h\"\n"
"\n"
"namespace OpenSubdiv {\n"
"namespace OPENSUBDIV_VERSION {\n"
"\n"
"namespace Osd {\n"
"\n"
"#endif\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"Osd_EvalBasisLinear(OSD_REAL s, OSD_REAL t,\n"
"        OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDs, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDt, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDss, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDst, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDtt, 4)) {\n"
"\n"
"    OSD_REAL sC = 1.0f - s;\n"
"    OSD_REAL tC = 1.0f - t;\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        wP[0] = sC * tC;\n"
"        wP[1] =  s * tC;\n"
"        wP[2] =  s * t;\n"
"        wP[3] = sC * t;\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        wDs[0] = -tC;\n"
"        wDs[1] =  tC;\n"
"        wDs[2] =   t;\n"
"        wDs[3] =  -t;\n"
"\n"
"        wDt[0] = -sC;\n"
"        wDt[1] =  -s;\n"
"        wDt[2] =   s;\n"
"        wDt[3] =  sC;\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            for(int i = 0; i < 4; ++i) {\n"
"                wDss[i] = 0.0f;\n"
"                wDtt[i] = 0.0f;\n"
"            }\n"
"\n"
"            wDst[0] =  1.0f;\n"
"            wDst[1] = -1.0f;\n"
"            wDst[2] =  1.0f;\n"
"            wDst[3] = -1.0f;\n"
"        }\n"
"    }\n"
"    return 4;\n"
"}\n"
"\n"
"// namespace {\n"
"    //\n"
"    //  Cubic BSpline curve basis evaluation:\n"
"    //\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_evalBSplineCurve(OSD_REAL t,\n"
"        OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDP2, 4)) {\n"
"\n"
"        const OSD_REAL one6th = OSD_REAL_CAST(1.0f / 6.0f);\n"
"\n"
"        OSD_REAL t2 = t * t;\n"
"        OSD_REAL t3 = t * t2;\n"
"\n"
"        wP[0] = one6th * (1.0f - 3.0f*(t -      t2) -      t3);\n"
"        wP[1] = one6th * (4.0f           - 6.0f*t2  + 3.0f*t3);\n"
"        wP[2] = one6th * (1.0f + 3.0f*(t +      t2  -      t3));\n"
"        wP[3] = one6th * (                                 t3);\n"
"\n"
"        if (OSD_OPTIONAL(wDP)) {\n"
"            wDP[0] = -0.5f*t2 +      t - 0.5f;\n"
"            wDP[1] =  1.5f*t2 - 2.0f*t;\n"
"            wDP[2] = -1.5f*t2 +      t + 0.5f;\n"
"            wDP[3] =  0.5f*t2;\n"
"        }\n"
"        if (OSD_OPTIONAL(wDP2)) {\n"
"            wDP2[0] = -       t + 1.0f;\n"
"            wDP2[1] =  3.0f * t - 2.0f;\n"
"            wDP2[2] = -3.0f * t + 1.0f;\n"
"            wDP2[3] =         t;\n"
"        }\n"
"    }\n"
"\n"
"    //\n"
"    //  Weight adjustments to account for phantom end points:\n"
"    //\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_adjustBSplineBoundaryWeights(\n"
"            int boundary,\n"
"            OSD_INOUT_ARRAY(OSD_REAL, w, 16)) {\n"
"\n"
"        if ((boundary & 1) != 0) {\n"
"            for (int i = 0; i < 4; ++i) {\n"
"                w[i + 8] -= w[i + 0];\n"
"                w[i + 4] += w[i + 0] * 2.0f;\n"
"                w[i + 0]  = 0.0f;\n"
"            }\n"
"        }\n"
"        if ((boundary & 2) != 0) {\n"
"            for (int i = 0; i < 16; i += 4) {\n"
"                w[i + 1] -= w[i + 3];\n"
"                w[i + 2] += w[i + 3] * 2.0f;\n"
"                w[i + 3]  = 0.0f;\n"
"            }\n"
"        }\n"
"        if ((boundary & 4) != 0) {\n"
"            for (int i = 0; i < 4; ++i) {\n"
"                w[i +  4] -= w[i + 12];\n"
"                w[i +  8] += w[i + 12] * 2.0f;\n"
"                w[i + 12]  = 0.0f;\n"
"            }\n"
"        }\n"
"        if ((boundary & 8) != 0) {\n"
"            for (int i = 0; i < 16; i += 4) {\n"
"                w[i + 2] -= w[i + 0];\n"
"                w[i + 1] += w[i + 0] * 2.0f;\n"
"                w[i + 0]  = 0.0f;\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_boundBasisBSpline(\n"
"            int boundary,\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wP, 16),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDs, 16),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDt, 16),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDss, 16),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDst, 16),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDtt, 16)) {\n"
"\n"
"        if (OSD_OPTIONAL(wP)) {\n"
"            Osd_adjustBSplineBoundaryWeights(boundary, wP);\n"
"        }\n"
"        if (OSD_OPTIONAL(wDs && wDt)) {\n"
"            Osd_adjustBSplineBoundaryWeights(boundary, wDs);\n"
"            Osd_adjustBSplineBoundaryWeights(boundary, wDt);\n"
"\n"
"            if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"                Osd_adjustBSplineBoundaryWeights(boundary, wDss);\n"
"                Osd_adjustBSplineBoundaryWeights(boundary, wDst);\n"
"                Osd_adjustBSplineBoundaryWeights(boundary, wDtt);\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"// } // end namespace\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"Osd_EvalBasisBSpline(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 16)) {\n"
"\n"
"    OSD_REAL sWeights[4], tWeights[4], dsWeights[4], dtWeights[4], dssWeights[4], dttWeights[4];\n"
"\n"
"    Osd_evalBSplineCurve(s, sWeights, OSD_OPTIONAL_INIT(wDs, dsWeights), OSD_OPTIONAL_INIT(wDss, dssWeights));\n"
"    Osd_evalBSplineCurve(t, tWeights, OSD_OPTIONAL_INIT(wDt, dtWeights), OSD_OPTIONAL_INIT(wDtt, dttWeights));\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wP[4*i+j] = sWeights[j] * tWeights[i];\n"
"            }\n"
"        }\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wDs[4*i+j] = dsWeights[j] * tWeights[i];\n"
"                wDt[4*i+j] = sWeights[j] * dtWeights[i];\n"
"            }\n"
"        }\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            for (int i = 0; i < 4; ++i) {\n"
"                for (int j = 0; j < 4; ++j) {\n"
"                    wDss[4*i+j] = dssWeights[j] * tWeights[i];\n"
"                    wDst[4*i+j] = dsWeights[j] * dtWeights[i];\n"
"                    wDtt[4*i+j] = sWeights[j] * dttWeights[i];\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"    return 16;\n"
"}\n"
"\n"
"// namespace {\n"
"    //\n"
"    //  Cubic Bezier curve basis evaluation:\n"
"    //\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_evalBezierCurve(\n"
"        OSD_REAL t,\n"
"        OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDP2, 4)) {\n"
"\n"
"        // The four uniform cubic Bezier basis functions (in terms of t and its\n"
"        // complement tC) evaluated at t:\n"
"        OSD_REAL t2 = t*t;\n"
"        OSD_REAL tC = 1.0f - t;\n"
"        OSD_REAL tC2 = tC * tC;\n"
"\n"
"        wP[0] = tC2 * tC;\n"
"        wP[1] = tC2 * t * 3.0f;\n"
"        wP[2] = t2 * tC * 3.0f;\n"
"        wP[3] = t2 * t;\n"
"\n"
"        // Derivatives of the above four basis functions at t:\n"
"        if (OSD_OPTIONAL(wDP)) {\n"
"           wDP[0] = -3.0f * tC2;\n"
"           wDP[1] =  9.0f * t2 - 12.0f * t + 3.0f;\n"
"           wDP[2] = -9.0f * t2 +  6.0f * t;\n"
"           wDP[3] =  3.0f * t2;\n"
"        }\n"
"\n"
"        // Second derivatives of the basis functions at t:\n"
"        if (OSD_OPTIONAL(wDP2)) {\n"
"            wDP2[0] =   6.0f * tC;\n"
"            wDP2[1] =  18.0f * t - 12.0f;\n"
"            wDP2[2] = -18.0f * t +  6.0f;\n"
"            wDP2[3] =   6.0f * t;\n"
"        }\n"
"    }\n"
"// } // end namespace\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"Osd_EvalBasisBezier(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 16)) {\n"
"\n"
"    OSD_REAL sWeights[4], tWeights[4], dsWeights[4], dtWeights[4], dssWeights[4], dttWeights[4];\n"
"\n"
"    Osd_evalBezierCurve(s, OSD_OPTIONAL_INIT(wP, sWeights), OSD_OPTIONAL_INIT(wDs, dsWeights), OSD_OPTIONAL_INIT(wDss, dssWeights));\n"
"    Osd_evalBezierCurve(t, OSD_OPTIONAL_INIT(wP, tWeights), OSD_OPTIONAL_INIT(wDt, dtWeights), OSD_OPTIONAL_INIT(wDtt, dttWeights));\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wP[4*i+j] = sWeights[j] * tWeights[i];\n"
"            }\n"
"        }\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wDs[4*i+j] = dsWeights[j] * tWeights[i];\n"
"                wDt[4*i+j] = sWeights[j] * dtWeights[i];\n"
"            }\n"
"        }\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            for (int i = 0; i < 4; ++i) {\n"
"                for (int j = 0; j < 4; ++j) {\n"
"                    wDss[4*i+j] = dssWeights[j] * tWeights[i];\n"
"                    wDst[4*i+j] = dsWeights[j] * dtWeights[i];\n"
"                    wDtt[4*i+j] = sWeights[j] * dttWeights[i];\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"    return 16;\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"int\n"
"Osd_EvalBasisGregory(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 20)) {\n"
"\n"
"    //  Indices of boundary and interior points and their corresponding Bezier points\n"
"    //  (this can be reduced with more direct indexing and unrolling of loops):\n"
"    //\n"
"    OSD_DATA_STORAGE_CLASS const int boundaryGregory[12] = OSD_ARRAY_12(int, 0, 1, 7, 5, 2, 6, 16, 12, 15, 17, 11, 10 );\n"
"    OSD_DATA_STORAGE_CLASS const int boundaryBezSCol[12] = OSD_ARRAY_12(int, 0, 1, 2, 3, 0, 3,  0,  3,  0,  1,  2,  3 );\n"
"    OSD_DATA_STORAGE_CLASS const int boundaryBezTRow[12] = OSD_ARRAY_12(int, 0, 0, 0, 0, 1, 1,  2,  2,  3,  3,  3,  3 );\n"
"\n"
"    OSD_DATA_STORAGE_CLASS const int interiorGregory[8] = OSD_ARRAY_8(int, 3, 4,  8, 9,  13, 14,  18, 19 );\n"
"    OSD_DATA_STORAGE_CLASS const int interiorBezSCol[8] = OSD_ARRAY_8(int, 1, 1,  2, 2,   2,  2,   1,  1 );\n"
"    OSD_DATA_STORAGE_CLASS const int interiorBezTRow[8] = OSD_ARRAY_8(int, 1, 1,  1, 1,   2,  2,   2,  2 );\n"
"\n"
"    //\n"
"    //  Bezier basis functions are denoted with B while the rational multipliers for the\n"
"    //  interior points will be denoted G -- so we have B(s), B(t) and G(s,t):\n"
"    //\n"
"    //  Directional Bezier basis functions B at s and t:\n"
"    OSD_REAL Bs[4], Bds[4], Bdss[4];\n"
"    OSD_REAL Bt[4], Bdt[4], Bdtt[4];\n"
"\n"
"    Osd_evalBezierCurve(s, Bs, OSD_OPTIONAL_INIT(wDs, Bds), OSD_OPTIONAL_INIT(wDss, Bdss));\n"
"    Osd_evalBezierCurve(t, Bt, OSD_OPTIONAL_INIT(wDt, Bdt), OSD_OPTIONAL_INIT(wDtt, Bdtt));\n"
"\n"
"    //  Rational multipliers G at s and t:\n"
"    OSD_REAL sC = 1.0f - s;\n"
"    OSD_REAL tC = 1.0f - t;\n"
"\n"
"    //  Use <= here to avoid compiler warnings -- the sums should always be non-negative:\n"
"    OSD_REAL df0 = s  + t;   df0 = (df0 <= 0.0f) ? 1.0f : (1.0f / df0);\n"
"    OSD_REAL df1 = sC + t;   df1 = (df1 <= 0.0f) ? 1.0f : (1.0f / df1);\n"
"    OSD_REAL df2 = sC + tC;  df2 = (df2 <= 0.0f) ? 1.0f : (1.0f / df2);\n"
"    OSD_REAL df3 = s  + tC;  df3 = (df3 <= 0.0f) ? 1.0f : (1.0f / df3);\n"
"\n"
"    //  Make sure the G[i] for pairs of interior points sum to 1 in all cases:\n"
"    OSD_REAL G[8] = OSD_ARRAY_8(OSD_REAL,  s*df0, (1.0f -  s*df0),\n"
"                                           t*df1, (1.0f -  t*df1),\n"
"                                          sC*df2, (1.0f - sC*df2),\n"
"                                          tC*df3, (1.0f - tC*df3) );\n"
"\n"
"    //  Combined weights for boundary and interior points:\n"
"    for (int i = 0; i < 12; ++i) {\n"
"        wP[boundaryGregory[i]] = Bs[boundaryBezSCol[i]] * Bt[boundaryBezTRow[i]];\n"
"    }\n"
"    for (int j = 0; j < 8; ++j) {\n"
"        wP[interiorGregory[j]] = Bs[interiorBezSCol[j]] * Bt[interiorBezTRow[j]] * G[j];\n"
"    }\n"
"\n"
"    //\n"
"    //  For derivatives, the basis functions for the interior points are rational and ideally\n"
"    //  require appropriate differentiation, i.e. product rule for the combination of B and G\n"
"    //  and the quotient rule for the rational G itself.  As initially proposed by Loop et al\n"
"    //  though, the approximation using the 16 Bezier points arising from the G(s,t) has\n"
"    //  proved adequate (and is what the GPU shaders use) so we continue to use that here.\n"
"    //\n"
"    //  An implementation of the true derivatives is provided and conditionally compiled for\n"
"    //  those that require it, e.g.:\n"
"    //\n"
"    //    dclyde's note: skipping half of the product rule like this does seem to change the\n"
"    //    result a lot in my tests.  This is not a runtime bottleneck for cloth sims anyway\n"
"    //    so I'm just using the accurate version.\n"
"    //\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        bool find_second_partials = OSD_OPTIONAL(wDs && wDst && wDtt);\n"
"\n"
"        //  Combined weights for boundary points -- simple tensor products:\n"
"        for (int i = 0; i < 12; ++i) {\n"
"            int iDst = boundaryGregory[i];\n"
"            int tRow = boundaryBezTRow[i];\n"
"            int sCol = boundaryBezSCol[i];\n"
"\n"
"            wDs[iDst] = Bds[sCol] * Bt[tRow];\n"
"            wDt[iDst] = Bdt[tRow] * Bs[sCol];\n"
"\n"
"            if (find_second_partials) {\n"
"                wDss[iDst] = Bdss[sCol] * Bt[tRow];\n"
"                wDst[iDst] = Bds[sCol] * Bdt[tRow];\n"
"                wDtt[iDst] = Bs[sCol] * Bdtt[tRow];\n"
"            }\n"
"        }\n"
"\n"
"#ifndef OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES\n"
"        //  Approximation to the true Gregory derivatives by differentiating the Bezier patch\n"
"        //  unique to the given (s,t), i.e. having F = (g^+ * f^+) + (g^- * f^-) as its four\n"
"        //  interior points:\n"
"        //\n"
"        //  Combined weights for interior points -- tensor products with G+ or G-:\n"
"        for (int j = 0; j < 8; ++j) {\n"
"            int iDst = interiorGregory[j];\n"
"            int tRow = interiorBezTRow[j];\n"
"            int sCol = interiorBezSCol[j];\n"
"\n"
"            wDs[iDst] = Bds[sCol] * Bt[tRow] * G[j];\n"
"            wDt[iDst] = Bdt[tRow] * Bs[sCol] * G[j];\n"
"\n"
"            if (find_second_partials) {\n"
"                wDss[iDst] = Bdss[sCol] * Bt[tRow] * G[j];\n"
"                wDst[iDst] = Bds[sCol] * Bdt[tRow] * G[j];\n"
"                wDtt[iDst] = Bs[sCol] * Bdtt[tRow] * G[j];\n"
"            }\n"
"        }\n"
"#else\n"
"        //  True Gregory derivatives using appropriate differentiation of composite functions:\n"
"        //\n"
"        //  Note that for G(s,t) = N(s,t) / D(s,t), all N' and D' are trivial constants (which\n"
"        //  simplifies things for higher order derivatives).  And while each pair of functions\n"
"        //  G (i.e. the G+ and G- corresponding to points f+ and f-) must sum to 1 to ensure\n"
"        //  Bezier equivalence (when f+ = f-), the pairs of G' must similarly sum to 0.  So we\n"
"        //  can potentially compute only one of the pair and negate the result for the other\n"
"        //  (and with 4 or 8 computations involving these constants, this is all very SIMD\n"
"        //  friendly...) but for now we treat all 8 independently for simplicity.\n"
"        //\n"
"        //float N[8] = OSD_ARRAY_8(float,    s,     t,      t,     sC,      sC,     tC,      tC,     s );\n"
"        OSD_REAL D[8] = OSD_ARRAY_8(OSD_REAL,  df0,   df0,    df1,    df1,     df2,    df2,     df3,   df3 );\n"
"\n"
"        OSD_DATA_STORAGE_CLASS const OSD_REAL Nds[8] = OSD_ARRAY_8(OSD_REAL, 1.0f, 0.0f,  0.0f, -1.0f, -1.0f,  0.0f,  0.0f,  1.0f );\n"
"        OSD_DATA_STORAGE_CLASS const OSD_REAL Ndt[8] = OSD_ARRAY_8(OSD_REAL, 0.0f, 1.0f,  1.0f,  0.0f,  0.0f, -1.0f, -1.0f,  0.0f );\n"
"\n"
"        OSD_DATA_STORAGE_CLASS const OSD_REAL Dds[8] = OSD_ARRAY_8(OSD_REAL, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f );\n"
"        OSD_DATA_STORAGE_CLASS const OSD_REAL Ddt[8] = OSD_ARRAY_8(OSD_REAL, 1.0f, 1.0f,  1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f );\n"
"        //  Combined weights for interior points -- (scaled) combinations of B, B', G and G':\n"
"        for (int k = 0; k < 8; ++k) {\n"
"            int iDst = interiorGregory[k];\n"
"            int tRow = interiorBezTRow[k];\n"
"            int sCol = interiorBezSCol[k];\n"
"\n"
"            //  Quotient rule for G' (re-expressed in terms of G to simplify (and D = 1/D)):\n"
"            OSD_REAL Gds = (Nds[k] - Dds[k] * G[k]) * D[k];\n"
"            OSD_REAL Gdt = (Ndt[k] - Ddt[k] * G[k]) * D[k];\n"
"\n"
"            //  Product rule combining B and B' with G and G':\n"
"            wDs[iDst] = (Bds[sCol] * G[k] + Bs[sCol] * Gds) * Bt[tRow];\n"
"            wDt[iDst] = (Bdt[tRow] * G[k] + Bt[tRow] * Gdt) * Bs[sCol];\n"
"\n"
"            if (find_second_partials) {\n"
"                OSD_REAL Dsqr_inv = D[k]*D[k];\n"
"\n"
"                OSD_REAL Gdss = 2.0f * Dds[k] * Dsqr_inv * (G[k] * Dds[k] - Nds[k]);\n"
"                OSD_REAL Gdst = Dsqr_inv * (2.0f * G[k] * Dds[k] * Ddt[k] - Nds[k] * Ddt[k] - Ndt[k] * Dds[k]);\n"
"                OSD_REAL Gdtt = 2.0f * Ddt[k] * Dsqr_inv * (G[k] * Ddt[k] - Ndt[k]);\n"
"\n"
"                wDss[iDst] = (Bdss[sCol] * G[k] + 2.0f * Bds[sCol] * Gds + Bs[sCol] * Gdss) * Bt[tRow];\n"
"                wDst[iDst] =  Bt[tRow] * (Bs[sCol] * Gdst + Bds[sCol] * Gdt) +\n"
"                             Bdt[tRow] * (Bds[sCol] * G[k] + Bs[sCol] * Gds);\n"
"                wDtt[iDst] = (Bdtt[tRow] * G[k] + 2.0f * Bdt[tRow] * Gdt + Bt[tRow] * Gdtt) * Bs[sCol];\n"
"            }\n"
"        }\n"
"#endif\n"
"    }\n"
"    return 20;\n"
"}\n"
"\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"Osd_EvalBasisLinearTri(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 3),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 3),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 3),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 3),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 3),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 3)) {\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        wP[0] = 1.0f - s - t;\n"
"        wP[1] = s;\n"
"        wP[2] = t;\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        wDs[0] = -1.0f;\n"
"        wDs[1] =  1.0f;\n"
"        wDs[2] =  0.0f;\n"
"\n"
"        wDt[0] = -1.0f;\n"
"        wDt[1] =  0.0f;\n"
"        wDt[2] =  1.0f;\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            wDss[0] = wDss[1] = wDss[2] = 0.0f;\n"
"            wDst[0] = wDst[1] = wDst[2] = 0.0f;\n"
"            wDtt[0] = wDtt[1] = wDtt[2] = 0.0f;\n"
"        }\n"
"    }\n"
"    return 3;\n"
"}\n"
"\n"
"\n"
"// namespace {\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_evalBivariateMonomialsQuartic(\n"
"        OSD_REAL s, OSD_REAL t,\n"
"        OSD_OUT_ARRAY(OSD_REAL, M, 15)) {\n"
"\n"
"        M[0] = 1.0;\n"
"\n"
"        M[1] = s;\n"
"        M[2] = t;\n"
"\n"
"        M[3] = s * s;\n"
"        M[4] = s * t;\n"
"        M[5] = t * t;\n"
"\n"
"        M[6] = M[3] * s;\n"
"        M[7] = M[4] * s;\n"
"        M[8] = M[4] * t;\n"
"        M[9] = M[5] * t;\n"
"\n"
"        M[10] = M[6] * s;\n"
"        M[11] = M[7] * s;\n"
"        M[12] = M[3] * M[5];\n"
"        M[13] = M[8] * t;\n"
"        M[14] = M[9] * t;\n"
"    }\n"
"\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_evalBoxSplineTriDerivWeights(\n"
"        OSD_INOUT_ARRAY(OSD_REAL, /*stMonomials*/M, 15),\n"
"        int ds, int dt,\n"
"        OSD_OUT_ARRAY(OSD_REAL, w, 12)) {\n"
"\n"
"        // const OSD_REAL M[15] = stMonomials;\n"
"\n"
"        OSD_REAL S = 1.0f;\n"
"\n"
"        int totalOrder = ds + dt;\n"
"        if (totalOrder == 0) {\n"
"            S *= OSD_REAL_CAST(1.0f / 12.0f);\n"
"\n"
"            w[0]  = S * (1 - 2*M[1] - 4*M[2]          + 6*M[4] + 6*M[5] + 2*M[6]          - 6*M[8] - 4*M[9] -   M[10] - 2*M[11] + 2*M[13] +   M[14]);\n"
"            w[1]  = S * (1 + 2*M[1] - 2*M[2]          - 6*M[4]          - 4*M[6]          + 6*M[8] + 2*M[9] + 2*M[10] + 4*M[11] - 2*M[13] -   M[14]);\n"
"            w[2]  = S * (                                                 2*M[6]                            -   M[10] - 2*M[11]                    );\n"
"            w[3]  = S * (1 - 4*M[1] - 2*M[2] + 6*M[3] + 6*M[4]          - 4*M[6] - 6*M[7]          + 2*M[9] +   M[10] + 2*M[11] - 2*M[13] -   M[14]);\n"
"            w[4]  = S * (6                   -12*M[3] -12*M[4] -12*M[5] + 8*M[6] +12*M[7] +12*M[8] + 8*M[9] -   M[10] - 2*M[11] - 2*M[13] -   M[14]);\n"
"            w[5]  = S * (1 + 4*M[1] + 2*M[2] + 6*M[3] + 6*M[4]          - 4*M[6] - 6*M[7] -12*M[8] - 4*M[9] -   M[10] - 2*M[11] + 4*M[13] + 2*M[14]);\n"
"            w[6]  = S * (                                                                                       M[10] + 2*M[11]                    );\n"
"            w[7]  = S * (1 - 2*M[1] + 2*M[2]          - 6*M[4]          + 2*M[6] + 6*M[7]          - 4*M[9] -   M[10] - 2*M[11] + 4*M[13] + 2*M[14]);\n"
"            w[8]  = S * (1 + 2*M[1] + 4*M[2]          + 6*M[4] + 6*M[5] - 4*M[6] -12*M[7] - 6*M[8] - 4*M[9] + 2*M[10] + 4*M[11] - 2*M[13] -   M[14]);\n"
"            w[9]  = S * (                                                 2*M[6] + 6*M[7] + 6*M[8] + 2*M[9] -   M[10] - 2*M[11] - 2*M[13] -   M[14]);\n"
"            w[10] = S * (                                                                            2*M[9]                     - 2*M[13] -   M[14]);\n"
"            w[11] = S * (                                                                                                         2*M[13] +   M[14]);\n"
"        } else if (totalOrder == 1) {\n"
"            S *= OSD_REAL_CAST(1.0f / 6.0f);\n"
"\n"
"            if (ds != 0) {\n"
"                w[0]  = S * (-1          + 3*M[2] + 3*M[3]          - 3*M[5] - 2*M[6] - 3*M[7] +   M[9]);\n"
"                w[1]  = S * ( 1          - 3*M[2] - 6*M[3]          + 3*M[5] + 4*M[6] + 6*M[7] -   M[9]);\n"
"                w[2]  = S * (                       3*M[3]                   - 2*M[6] - 3*M[7]         );\n"
"                w[3]  = S * (-2 + 6*M[1] + 3*M[2] - 6*M[3] - 6*M[4]          + 2*M[6] + 3*M[7] -   M[9]);\n"
"                w[4]  = S * (   -12*M[1] - 6*M[2] +12*M[3] +12*M[4] + 6*M[5] - 2*M[6] - 3*M[7] -   M[9]);\n"
"                w[5]  = S * ( 2 + 6*M[1] + 3*M[2] - 6*M[3] - 6*M[4] - 6*M[5] - 2*M[6] - 3*M[7] + 2*M[9]);\n"
"                w[6]  = S * (                                                  2*M[6] + 3*M[7]         );\n"
"                w[7]  = S * (-1          - 3*M[2] + 3*M[3] + 6*M[4]          - 2*M[6] - 3*M[7] + 2*M[9]);\n"
"                w[8]  = S * ( 1          + 3*M[2] - 6*M[3] -12*M[4] - 3*M[5] + 4*M[6] + 6*M[7] -   M[9]);\n"
"                w[9]  = S * (                       3*M[3] + 6*M[4] + 3*M[5] - 2*M[6] - 3*M[7] -   M[9]);\n"
"                w[10] = S * (                                                                  -   M[9]);\n"
"                w[11] = S * (                                                                      M[9]);\n"
"            } else {\n"
"                w[0]  = S * (-2 + 3*M[1] + 6*M[2]          - 6*M[4] - 6*M[5]  -   M[6] + 3*M[8] + 2*M[9]);\n"
"                w[1]  = S * (-1 - 3*M[1]                   + 6*M[4] + 3*M[5]  + 2*M[6] - 3*M[8] - 2*M[9]);\n"
"                w[2]  = S * (                                                 -   M[6]                  );\n"
"                w[3]  = S * (-1 + 3*M[1]          - 3*M[3]          + 3*M[5]  +   M[6] - 3*M[8] - 2*M[9]);\n"
"                w[4]  = S * (   - 6*M[1] -12*M[2] + 6*M[3] +12*M[4] +12*M[5]  -   M[6] - 3*M[8] - 2*M[9]);\n"
"                w[5]  = S * ( 1 + 3*M[1]          - 3*M[3] -12*M[4] - 6*M[5]  -   M[6] + 6*M[8] + 4*M[9]);\n"
"                w[6]  = S * (                                                 +   M[6]                  );\n"
"                w[7]  = S * ( 1 - 3*M[1]          + 3*M[3]          - 6*M[5]  -   M[6] + 6*M[8] + 4*M[9]);\n"
"                w[8]  = S * ( 2 + 3*M[1] + 6*M[2] - 6*M[3] - 6*M[4] - 6*M[5]  + 2*M[6] - 3*M[8] - 2*M[9]);\n"
"                w[9]  = S * (                     + 3*M[3] + 6*M[4] + 3*M[5]  -   M[6] - 3*M[8] - 2*M[9]);\n"
"                w[10] = S * (                                         3*M[5]           - 3*M[8] - 2*M[9]);\n"
"                w[11] = S * (                                                            3*M[8] + 2*M[9]);\n"
"            }\n"
"        } else if (totalOrder == 2) {\n"
"            if (ds == 2) {\n"
"                w[0]  = S * (   +   M[1]          -   M[3] -   M[4]);\n"
"                w[1]  = S * (   - 2*M[1]          + 2*M[3] + 2*M[4]);\n"
"                w[2]  = S * (       M[1]          -   M[3] -   M[4]);\n"
"                w[3]  = S * ( 1 - 2*M[1] -   M[2] +   M[3] +   M[4]);\n"
"                w[4]  = S * (-2 + 4*M[1] + 2*M[2] -   M[3] -   M[4]);\n"
"                w[5]  = S * ( 1 - 2*M[1] -   M[2] -   M[3] -   M[4]);\n"
"                w[6]  = S * (                         M[3] +   M[4]);\n"
"                w[7]  = S * (   +   M[1] +   M[2] -   M[3] -   M[4]);\n"
"                w[8]  = S * (   - 2*M[1] - 2*M[2] + 2*M[3] + 2*M[4]);\n"
"                w[9]  = S * (       M[1] +   M[2] -   M[3] -   M[4]);\n"
"                w[10] =     0;\n"
"                w[11] =     0;\n"
"            } else if (dt == 2) {\n"
"                w[0]  = S * ( 1 -   M[1] - 2*M[2] +   M[4] +   M[5]);\n"
"                w[1]  = S * (   +   M[1] +   M[2] -   M[4] -   M[5]);\n"
"                w[2]  =     0;\n"
"                w[3]  = S * (            +   M[2] -   M[4] -   M[5]);\n"
"                w[4]  = S * (-2 + 2*M[1] + 4*M[2] -   M[4] -   M[5]);\n"
"                w[5]  = S * (   - 2*M[1] - 2*M[2] + 2*M[4] + 2*M[5]);\n"
"                w[6]  =     0;\n"
"                w[7]  = S * (            - 2*M[2] + 2*M[4] + 2*M[5]);\n"
"                w[8]  = S * ( 1 -   M[1] - 2*M[2] -   M[4] -   M[5]);\n"
"                w[9]  = S * (   +   M[1] +   M[2] -   M[4] -   M[5]);\n"
"                w[10] = S * (                M[2] -   M[4] -   M[5]);\n"
"                w[11] = S * (                         M[4] +   M[5]);\n"
"            } else {\n"
"                S *= OSD_REAL_CAST(1.0f / 2.0f);\n"
"\n"
"                w[0]  = S * ( 1          - 2*M[2] -   M[3] +   M[5]);\n"
"                w[1]  = S * (-1          + 2*M[2] + 2*M[3] -   M[5]);\n"
"                w[2]  = S * (                     -   M[3]         );\n"
"                w[3]  = S * ( 1 - 2*M[1]          +   M[3] -   M[5]);\n"
"                w[4]  = S * (-2 + 4*M[1] + 4*M[2] -   M[3] -   M[5]);\n"
"                w[5]  = S * ( 1 - 2*M[1] - 4*M[2] -   M[3] + 2*M[5]);\n"
"                w[6]  = S * (                     +   M[3]         );\n"
"                w[7]  = S * (-1 + 2*M[1]          -   M[3] + 2*M[5]);\n"
"                w[8]  = S * ( 1 - 4*M[1] - 2*M[2] + 2*M[3] -   M[5]);\n"
"                w[9]  = S * (   + 2*M[1] + 2*M[2] -   M[3] -   M[5]);\n"
"                w[10] = S * (                              -   M[5]);\n"
"                w[11] = S * (                                  M[5]);\n"
"            }\n"
"        } else {\n"
"            // assert(totalOrder <= 2);\n"
"        }\n"
"    }\n"
"\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_adjustBoxSplineTriBoundaryWeights(\n"
"        int boundaryMask,\n"
"        OSD_INOUT_ARRAY(OSD_REAL, weights, 12)) {\n"
"\n"
"        if (boundaryMask == 0) return;\n"
"\n"
"        //\n"
"        //  Determine boundary edges and vertices from the lower 3 and upper\n"
"        //  2 bits of the 5-bit mask:\n"
"        //\n"
"        int upperBits = (boundaryMask >> 3) & 0x3;\n"
"        int lowerBits = boundaryMask & 7;\n"
"\n"
"        int eBits = lowerBits;\n"
"        int vBits = 0;\n"
"\n"
"        if (upperBits == 1) {\n"
"            //  Boundary vertices only:\n"
"            vBits = eBits;\n"
"            eBits = 0;\n"
"        } else if (upperBits == 2) {\n"
"            //  Opposite vertex bit is edge bit rotated one to the right:\n"
"            vBits = ((eBits & 1) << 2) | (eBits >> 1);\n"
"        }\n"
"\n"
"        bool edge0IsBoundary = (eBits & 1) != 0;\n"
"        bool edge1IsBoundary = (eBits & 2) != 0;\n"
"        bool edge2IsBoundary = (eBits & 4) != 0;\n"
"\n"
"        //\n"
"        //  Adjust weights for the 4 boundary points and 3 interior points\n"
"        //  to account for the 3 phantom points adjacent to each\n"
"        //  boundary edge:\n"
"        //\n"
"        if (edge0IsBoundary) {\n"
"            OSD_REAL w0 = weights[0];\n"
"            if (edge2IsBoundary) {\n"
"                //  P0 = B1 + (B1 - I1)\n"
"                weights[4] += w0;\n"
"                weights[4] += w0;\n"
"                weights[8] -= w0;\n"
"            } else {\n"
"                //  P0 = B1 + (B0 - I0)\n"
"                weights[4] += w0;\n"
"                weights[3] += w0;\n"
"                weights[7] -= w0;\n"
"            }\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[1];\n"
"            weights[4] += w1;\n"
"            weights[5] += w1;\n"
"            weights[8] -= w1;\n"
"\n"
"            OSD_REAL w2 = weights[2];\n"
"            if (edge1IsBoundary) {\n"
"                //  P2 = B2 + (B2 - I1)\n"
"                weights[5] += w2;\n"
"                weights[5] += w2;\n"
"                weights[8] -= w2;\n"
"            } else {\n"
"                //  P2 = B2 + (B3 - I2)\n"
"                weights[5] += w2;\n"
"                weights[6] += w2;\n"
"                weights[9] -= w2;\n"
"            }\n"
"            //  Clear weights for the phantom points:\n"
"            weights[0] = weights[1] = weights[2] = 0.0f;\n"
"        }\n"
"        if (edge1IsBoundary) {\n"
"            OSD_REAL w0 = weights[6];\n"
"            if (edge0IsBoundary) {\n"
"                //  P0 = B1 + (B1 - I1)\n"
"                weights[5] += w0;\n"
"                weights[5] += w0;\n"
"                weights[4] -= w0;\n"
"            } else {\n"
"                //  P0 = B1 + (B0 - I0)\n"
"                weights[5] += w0;\n"
"                weights[2] += w0;\n"
"                weights[1] -= w0;\n"
"            }\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[9];\n"
"            weights[5] += w1;\n"
"            weights[8] += w1;\n"
"            weights[4] -= w1;\n"
"\n"
"            OSD_REAL w2 = weights[11];\n"
"            if (edge2IsBoundary) {\n"
"                //  P2 = B2 + (B2 - I1)\n"
"                weights[8] += w2;\n"
"                weights[8] += w2;\n"
"                weights[4] -= w2;\n"
"            } else {\n"
"                //  P2 = B2 + (B3 - I2)\n"
"                weights[8]  += w2;\n"
"                weights[10] += w2;\n"
"                weights[7]  -= w2;\n"
"            }\n"
"            //  Clear weights for the phantom points:\n"
"            weights[6] = weights[9] = weights[11] = 0.0f;\n"
"        }\n"
"        if (edge2IsBoundary) {\n"
"            OSD_REAL w0 = weights[10];\n"
"            if (edge1IsBoundary) {\n"
"                //  P0 = B1 + (B1 - I1)\n"
"                weights[8] += w0;\n"
"                weights[8] += w0;\n"
"                weights[5] -= w0;\n"
"            } else {\n"
"                //  P0 = B1 + (B0 - I0)\n"
"                weights[8]  += w0;\n"
"                weights[11] += w0;\n"
"                weights[9]  -= w0;\n"
"            }\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[7];\n"
"            weights[8] += w1;\n"
"            weights[4] += w1;\n"
"            weights[5] -= w1;\n"
"\n"
"            OSD_REAL w2 = weights[3];\n"
"            if (edge0IsBoundary) {\n"
"                //  P2 = B2 + (B2 - I1)\n"
"                weights[4] += w2;\n"
"                weights[4] += w2;\n"
"                weights[5] -= w2;\n"
"            } else {\n"
"                //  P2 = B2 + (B3 - I2)\n"
"                weights[4] += w2;\n"
"                weights[0] += w2;\n"
"                weights[1] -= w2;\n"
"            }\n"
"            //  Clear weights for the phantom points:\n"
"            weights[10] = weights[7] = weights[3] = 0.0f;\n"
"        }\n"
"\n"
"        //\n"
"        //  Adjust weights for the 3 boundary points and the 2 interior\n"
"        //  points to account for the 2 phantom points adjacent to\n"
"        //  each boundary vertex:\n"
"        //\n"
"        if ((vBits & 1) != 0) {\n"
"            //  P0 = B1 + (B0 - I0)\n"
"            OSD_REAL w0 = weights[3];\n"
"            weights[4] += w0;\n"
"            weights[7] += w0;\n"
"            weights[8] -= w0;\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[0];\n"
"            weights[4] += w1;\n"
"            weights[1] += w1;\n"
"            weights[5] -= w1;\n"
"\n"
"            //  Clear weights for the phantom points:\n"
"            weights[3] = weights[0] = 0.0f;\n"
"        }\n"
"        if ((vBits & 2) != 0) {\n"
"            //  P0 = B1 + (B0 - I0)\n"
"            OSD_REAL w0 = weights[2];\n"
"            weights[5] += w0;\n"
"            weights[1] += w0;\n"
"            weights[4] -= w0;\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[6];\n"
"            weights[5] += w1;\n"
"            weights[9] += w1;\n"
"            weights[8] -= w1;\n"
"\n"
"            //  Clear weights for the phantom points:\n"
"            weights[2] = weights[6] = 0.0f;\n"
"        }\n"
"        if ((vBits & 4) != 0) {\n"
"            //  P0 = B1 + (B0 - I0)\n"
"            OSD_REAL w0 = weights[11];\n"
"            weights[8] += w0;\n"
"            weights[9] += w0;\n"
"            weights[5] -= w0;\n"
"\n"
"            //  P1 = B1 + (B2 - I1)\n"
"            OSD_REAL w1 = weights[10];\n"
"            weights[8] += w1;\n"
"            weights[7] += w1;\n"
"            weights[4] -= w1;\n"
"\n"
"            //  Clear weights for the phantom points:\n"
"            weights[11] = weights[10] = 0.0f;\n"
"        }\n"
"    }\n"
"\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_boundBasisBoxSplineTri(\n"
"            int boundary,\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wP, 12),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDs, 12),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDt, 12),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDss, 12),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDst, 12),\n"
"            OSD_INOUT_ARRAY(OSD_REAL, wDtt, 12)) {\n"
"\n"
"        if (OSD_OPTIONAL(wP)) {\n"
"            Osd_adjustBoxSplineTriBoundaryWeights(boundary, wP);\n"
"        }\n"
"        if (OSD_OPTIONAL(wDs && wDt)) {\n"
"            Osd_adjustBoxSplineTriBoundaryWeights(boundary, wDs);\n"
"            Osd_adjustBoxSplineTriBoundaryWeights(boundary, wDt);\n"
"\n"
"            if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"                Osd_adjustBoxSplineTriBoundaryWeights(boundary, wDss);\n"
"                Osd_adjustBoxSplineTriBoundaryWeights(boundary, wDst);\n"
"                Osd_adjustBoxSplineTriBoundaryWeights(boundary, wDtt);\n"
"            }\n"
"        }\n"
"    }\n"
"// }  // namespace\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"Osd_EvalBasisBoxSplineTri(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 12),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 12),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 12),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 12),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 12),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 12)) {\n"
"\n"
"    OSD_REAL stMonomials[15];\n"
"    Osd_evalBivariateMonomialsQuartic(s, t, stMonomials);\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        Osd_evalBoxSplineTriDerivWeights(stMonomials, 0, 0, wP);\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        Osd_evalBoxSplineTriDerivWeights(stMonomials, 1, 0, wDs);\n"
"        Osd_evalBoxSplineTriDerivWeights(stMonomials, 0, 1, wDt);\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            Osd_evalBoxSplineTriDerivWeights(stMonomials, 2, 0, wDss);\n"
"            Osd_evalBoxSplineTriDerivWeights(stMonomials, 1, 1, wDst);\n"
"            Osd_evalBoxSplineTriDerivWeights(stMonomials, 0, 2, wDtt);\n"
"        }\n"
"    }\n"
"    return 12;\n"
"}\n"
"\n"
"\n"
"// namespace {\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_evalBezierTriDerivWeights(\n"
"        OSD_REAL s, OSD_REAL t, int ds, int dt,\n"
"        OSD_OUT_ARRAY(OSD_REAL, wB, 15)) {\n"
"\n"
"        OSD_REAL u  = s;\n"
"        OSD_REAL v  = t;\n"
"        OSD_REAL w  = 1 - u - v;\n"
"\n"
"        OSD_REAL uu = u * u;\n"
"        OSD_REAL vv = v * v;\n"
"        OSD_REAL ww = w * w;\n"
"\n"
"        OSD_REAL uv = u * v;\n"
"        OSD_REAL vw = v * w;\n"
"        OSD_REAL uw = u * w;\n"
"\n"
"        int totalOrder = ds + dt;\n"
"        if (totalOrder == 0) {\n"
"            wB[0]  =      ww * ww;\n"
"            wB[1]  =  4 * uw * ww;\n"
"            wB[2]  =  6 * uw * uw;\n"
"            wB[3]  =  4 * uw * uu;\n"
"            wB[4]  =      uu * uu;\n"
"            wB[5]  =  4 * vw * ww;\n"
"            wB[6]  = 12 * ww * uv;\n"
"            wB[7]  = 12 * uu * vw;\n"
"            wB[8]  =  4 * uv * uu;\n"
"            wB[9]  =  6 * vw * vw;\n"
"            wB[10] = 12 * vv * uw;\n"
"            wB[11] =  6 * uv * uv;\n"
"            wB[12] =  4 * vw * vv;\n"
"            wB[13] =  4 * uv * vv;\n"
"            wB[14] =      vv * vv;\n"
"        } else if (totalOrder == 1) {\n"
"            if (ds == 1) {\n"
"                wB[0]  =  -4 * ww * w;\n"
"                wB[1]  =   4 * ww * (w - 3 * u);\n"
"                wB[2]  =  12 * uw * (w - u);\n"
"                wB[3]  =   4 * uu * (3 * w - u);\n"
"                wB[4]  =   4 * uu * u;\n"
"                wB[5]  = -12 * vw * w;\n"
"                wB[6]  =  12 * vw * (w - 2 * u);\n"
"                wB[7]  =  12 * uv * (2 * w - u);\n"
"                wB[8]  =  12 * uv * u;\n"
"                wB[9]  = -12 * vv * w;\n"
"                wB[10] =  12 * vv * (w - u);\n"
"                wB[11] =  12 * vv * u;\n"
"                wB[12] =  -4 * vv * v;\n"
"                wB[13] =   4 * vv * v;\n"
"                wB[14] =   0;\n"
"            } else {\n"
"                wB[0]  =  -4 * ww * w;\n"
"                wB[1]  = -12 * ww * u;\n"
"                wB[2]  = -12 * uu * w;\n"
"                wB[3]  =  -4 * uu * u;\n"
"                wB[4]  =   0;\n"
"                wB[5]  =   4 * ww * (w - 3 * v);\n"
"                wB[6]  =  12 * uw * (w - 2 * v);\n"
"                wB[7]  =  12 * uu * (w - v);\n"
"                wB[8]  =   4 * uu * u;\n"
"                wB[9]  =  12 * vw * (w - v);\n"
"                wB[10] =  12 * uv * (2 * w - v);\n"
"                wB[11] =  12 * uv * u;;\n"
"                wB[12] =   4 * vv * (3 * w - v);\n"
"                wB[13] =  12 * vv * u;\n"
"                wB[14] =   4 * vv * v;\n"
"            }\n"
"        } else if (totalOrder == 2) {\n"
"            if (ds == 2) {\n"
"                wB[0]  =  12 * ww;\n"
"                wB[1]  =  24 * (uw - ww);\n"
"                wB[2]  =  12 * (uu - 4 * uw + ww);\n"
"                wB[3]  =  24 * (uw - uu);\n"
"                wB[4]  =  12 * uu;\n"
"                wB[5]  =  24 * vw;\n"
"                wB[6]  =  24 * (uv - 2 * vw);\n"
"                wB[7]  =  24 * (vw - 2 * uv);\n"
"                wB[8]  =  24 * uv;\n"
"                wB[9]  =  12 * vv;\n"
"                wB[10] = -24 * vv;\n"
"                wB[11] =  12 * vv;\n"
"                wB[12] =   0;\n"
"                wB[13] =   0;\n"
"                wB[14] =   0;\n"
"            } else if (dt == 2) {\n"
"                wB[0]  =  12 * ww;\n"
"                wB[1]  =  24 * uw;\n"
"                wB[2]  =  12 * uu;\n"
"                wB[3]  =   0;\n"
"                wB[4]  =   0;\n"
"                wB[5]  =  24 * (vw - ww);\n"
"                wB[6]  =  24 * (uv - 2 * uw);\n"
"                wB[7]  = -24 * uu;\n"
"                wB[8]  =   0;\n"
"                wB[9]  =  12 * (vv - 4 * vw + ww);\n"
"                wB[10] =  24 * (uw - 2 * uv);\n"
"                wB[11] =  12 * uu;\n"
"                wB[12] =  24 * (vw - vv);\n"
"                wB[13] =  24 * uv;\n"
"                wB[14] =  12 * vv;\n"
"            } else {\n"
"                wB[0]  =  12 * ww;\n"
"                wB[3]  = -12 * uu;\n"
"                wB[13] =  12 * vv;\n"
"                wB[11] =  24 * uv;\n"
"                wB[1]  =  24 * uw - wB[0];\n"
"                wB[2]  = -24 * uw - wB[3];\n"
"                wB[5]  =  24 * vw - wB[0];\n"
"                wB[6]  = -24 * vw + wB[11] - wB[1];\n"
"                wB[8]  = - wB[3];\n"
"                wB[7]  = -(wB[11] + wB[2]);\n"
"                wB[9]  =   wB[13] - wB[5] - wB[0];\n"
"                wB[10] = -(wB[9] + wB[11]);\n"
"                wB[12] = - wB[13];\n"
"                wB[4]  =   0;\n"
"                wB[14] =   0;\n"
"            }\n"
"        } else {\n"
"            // assert(totalOrder <= 2);\n"
"        }\n"
"    }\n"
"// } // end namespace\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"Osd_EvalBasisBezierTri(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 15),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 15),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 15),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 15),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 15),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 15)) {\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        Osd_evalBezierTriDerivWeights(s, t, 0, 0, wP);\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        Osd_evalBezierTriDerivWeights(s, t, 1, 0, wDs);\n"
"        Osd_evalBezierTriDerivWeights(s, t, 0, 1, wDt);\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            Osd_evalBezierTriDerivWeights(s, t, 2, 0, wDss);\n"
"            Osd_evalBezierTriDerivWeights(s, t, 1, 1, wDst);\n"
"            Osd_evalBezierTriDerivWeights(s, t, 0, 2, wDtt);\n"
"        }\n"
"    }\n"
"    return 15;\n"
"}\n"
"\n"
"\n"
"// namespace {\n"
"    //\n"
"    //  Expanding a set of 15 Bezier basis functions for the 6 (3 pairs) of\n"
"    //  rational weights for the 18 Gregory basis functions:\n"
"    //\n"
"    OSD_FUNCTION_STORAGE_CLASS\n"
"    // template <typename REAL>\n"
"    void\n"
"    Osd_convertBezierWeightsToGregory(\n"
"        OSD_INOUT_ARRAY(OSD_REAL, wB, 15),\n"
"        OSD_INOUT_ARRAY(OSD_REAL, rG,  6),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wG, 18)) {\n"
"\n"
"        wG[0]  = wB[0];\n"
"        wG[1]  = wB[1];\n"
"        wG[2]  = wB[5];\n"
"        wG[3]  = wB[6] * rG[0];\n"
"        wG[4]  = wB[6] * rG[1];\n"
"\n"
"        wG[5]  = wB[4];\n"
"        wG[6]  = wB[8];\n"
"        wG[7]  = wB[3];\n"
"        wG[8]  = wB[7] * rG[2];\n"
"        wG[9]  = wB[7] * rG[3];\n"
"\n"
"        wG[10] = wB[14];\n"
"        wG[11] = wB[12];\n"
"        wG[12] = wB[13];\n"
"        wG[13] = wB[10] * rG[4];\n"
"        wG[14] = wB[10] * rG[5];\n"
"\n"
"        wG[15] = wB[2];\n"
"        wG[16] = wB[11];\n"
"        wG[17] = wB[9];\n"
"    }\n"
"// } // end namespace\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"Osd_EvalBasisGregoryTri(OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 18),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 18),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 18),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 18),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 18),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 18)) {\n"
"\n"
"    //\n"
"    //  Bezier basis functions are denoted with B while the rational multipliers for the\n"
"    //  interior points will be denoted G -- so we have B(s,t) and G(s,t) (though we\n"
"    //  switch to barycentric (u,v,w) briefly to compute G)\n"
"    //\n"
"    OSD_REAL BP[15], BDs[15], BDt[15], BDss[15], BDst[15], BDtt[15];\n"
"\n"
"    OSD_REAL G[6] = OSD_ARRAY_6(OSD_REAL, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f );\n"
"    OSD_REAL u = s;\n"
"    OSD_REAL v = t;\n"
"    OSD_REAL w = 1 - u - v;\n"
"\n"
"    if ((u + v) > 0) {\n"
"        G[0]  = u / (u + v);\n"
"        G[1]  = v / (u + v);\n"
"    }\n"
"    if ((v + w) > 0) {\n"
"        G[2] = v / (v + w);\n"
"        G[3] = w / (v + w);\n"
"    }\n"
"    if ((w + u) > 0) {\n"
"        G[4] = w / (w + u);\n"
"        G[5] = u / (w + u);\n"
"    }\n"
"\n"
"    //\n"
"    //  Compute Bezier basis functions and convert, adjusting interior points:\n"
"    //\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        Osd_evalBezierTriDerivWeights(s, t, 0, 0, BP);\n"
"        Osd_convertBezierWeightsToGregory(BP, G, wP);\n"
"    }\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        //  TBD -- ifdef OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES\n"
"\n"
"        Osd_evalBezierTriDerivWeights(s, t, 1, 0, BDs);\n"
"        Osd_evalBezierTriDerivWeights(s, t, 0, 1, BDt);\n"
"\n"
"        Osd_convertBezierWeightsToGregory(BDs, G, wDs);\n"
"        Osd_convertBezierWeightsToGregory(BDt, G, wDt);\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            Osd_evalBezierTriDerivWeights(s, t, 2, 0, BDss);\n"
"            Osd_evalBezierTriDerivWeights(s, t, 1, 1, BDst);\n"
"            Osd_evalBezierTriDerivWeights(s, t, 0, 2, BDtt);\n"
"\n"
"            Osd_convertBezierWeightsToGregory(BDss, G, wDss);\n"
"            Osd_convertBezierWeightsToGregory(BDst, G, wDst);\n"
"            Osd_convertBezierWeightsToGregory(BDtt, G, wDtt);\n"
"        }\n"
"    }\n"
"    return 18;\n"
"}\n"
"\n"
"// The following functions are low-level internal methods which\n"
"// were exposed in earlier releases, but were never intended to\n"
"// be part of the supported public API.\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBezierWeights(\n"
"    OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDP, 4),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDP2, 4)) {\n"
"\n"
"    Osd_evalBezierCurve(t, wP, wDP, wDP2);\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBSplineWeights(\n"
"    OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDP, 4),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDP2, 4)) {\n"
"\n"
"    Osd_evalBSplineCurve(t, wP, wDP, wDP2);\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBoxSplineWeights(\n"
"    float s, float t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 12)) {\n"
"\n"
"    OSD_REAL stMonomials[15];\n"
"    Osd_evalBivariateMonomialsQuartic(s, t, stMonomials);\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        Osd_evalBoxSplineTriDerivWeights(stMonomials, 0, 0, wP);\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdAdjustBoundaryWeights(\n"
"        int boundary,\n"
"        OSD_INOUT_ARRAY(OSD_REAL, sWeights, 4),\n"
"        OSD_INOUT_ARRAY(OSD_REAL, tWeights, 4)) {\n"
"\n"
"    if ((boundary & 1) != 0) {\n"
"        tWeights[2] -= tWeights[0];\n"
"        tWeights[1] += tWeights[0] * 2.0f;\n"
"        tWeights[0]  = 0.0f;\n"
"    }\n"
"    if ((boundary & 2) != 0) {\n"
"        sWeights[1] -= sWeights[3];\n"
"        sWeights[2] += sWeights[3] * 2.0f;\n"
"        sWeights[3]  = 0.0f;\n"
"    }\n"
"    if ((boundary & 4) != 0) {\n"
"        tWeights[1] -= tWeights[3];\n"
"        tWeights[2] += tWeights[3] * 2.0f;\n"
"        tWeights[3]  = 0.0f;\n"
"    }\n"
"    if ((boundary & 8) != 0) {\n"
"        sWeights[2] -= sWeights[0];\n"
"        sWeights[1] += sWeights[0] * 2.0f;\n"
"        sWeights[0]  = 0.0f;\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdComputeTensorProductPatchWeights(\n"
"    float dScale, int boundary,\n"
"    OSD_IN_ARRAY(float, sWeights, 4),\n"
"    OSD_IN_ARRAY(float, tWeights, 4),\n"
"    OSD_IN_ARRAY(float, dsWeights, 4),\n"
"    OSD_IN_ARRAY(float, dtWeights, 4),\n"
"    OSD_IN_ARRAY(float, dssWeights, 4),\n"
"    OSD_IN_ARRAY(float, dttWeights, 4),\n"
"    OSD_OUT_ARRAY(float, wP, 16),\n"
"    OSD_OUT_ARRAY(float, wDs, 16),\n"
"    OSD_OUT_ARRAY(float, wDt, 16),\n"
"    OSD_OUT_ARRAY(float, wDss, 16),\n"
"    OSD_OUT_ARRAY(float, wDst, 16),\n"
"    OSD_OUT_ARRAY(float, wDtt, 16)) {\n"
"\n"
"    if (OSD_OPTIONAL(wP)) {\n"
"        // Compute the tensor product weight of the (s,t) basis function\n"
"        // corresponding to each control vertex:\n"
"\n"
"        OsdAdjustBoundaryWeights(boundary, sWeights, tWeights);\n"
"\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wP[4*i+j] = sWeights[j] * tWeights[i];\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        // Compute the tensor product weight of the differentiated (s,t) basis\n"
"        // function corresponding to each control vertex (scaled accordingly):\n"
"\n"
"        OsdAdjustBoundaryWeights(boundary, dsWeights, dtWeights);\n"
"\n"
"        for (int i = 0; i < 4; ++i) {\n"
"            for (int j = 0; j < 4; ++j) {\n"
"                wDs[4*i+j] = dsWeights[j] * tWeights[i] * dScale;\n"
"                wDt[4*i+j] = sWeights[j] * dtWeights[i] * dScale;\n"
"            }\n"
"        }\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            // Compute the tensor product weight of appropriate differentiated\n"
"            // (s,t) basis functions for each control vertex (scaled accordingly):\n"
"            float d2Scale = dScale * dScale;\n"
"\n"
"            OsdAdjustBoundaryWeights(boundary, dssWeights, dttWeights);\n"
"\n"
"            for (int i = 0; i < 4; ++i) {\n"
"                for (int j = 0; j < 4; ++j) {\n"
"                    wDss[4*i+j] = dssWeights[j] * tWeights[i] * d2Scale;\n"
"                    wDst[4*i+j] = dsWeights[j] * dtWeights[i] * d2Scale;\n"
"                    wDtt[4*i+j] = sWeights[j] * dttWeights[i] * d2Scale;\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBilinearPatchWeights(\n"
"        OSD_REAL s, OSD_REAL t, OSD_REAL d1Scale,\n"
"        OSD_OUT_ARRAY(OSD_REAL, wP, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDs, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDt, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDss, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDst, 4),\n"
"        OSD_OUT_ARRAY(OSD_REAL, wDtt, 4)) {\n"
"\n"
"    int nPoints = Osd_EvalBasisLinear(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < nPoints; ++i) {\n"
"            wDs[i] *= d1Scale;\n"
"            wDt[i] *= d1Scale;\n"
"        }\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            OSD_REAL d2Scale = d1Scale * d1Scale;\n"
"\n"
"            for (int i = 0; i < nPoints; ++i) {\n"
"                wDss[i] *= d2Scale;\n"
"                wDst[i] *= d2Scale;\n"
"                wDtt[i] *= d2Scale;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBSplinePatchWeights(\n"
"    OSD_REAL s, OSD_REAL t, OSD_REAL d1Scale, int boundary,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 16)) {\n"
"\n"
"    int nPoints = Osd_EvalBasisBSpline(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    Osd_boundBasisBSpline(boundary, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < nPoints; ++i) {\n"
"            wDs[i] *= d1Scale;\n"
"            wDt[i] *= d1Scale;\n"
"        }\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            OSD_REAL d2Scale = d1Scale * d1Scale;\n"
"\n"
"            for (int i = 0; i < nPoints; ++i) {\n"
"                wDss[i] *= d2Scale;\n"
"                wDst[i] *= d2Scale;\n"
"                wDtt[i] *= d2Scale;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetBezierPatchWeights(\n"
"    OSD_REAL s, OSD_REAL t, OSD_REAL d1Scale,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 16),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 16)) {\n"
"    int nPoints = Osd_EvalBasisBezier(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < nPoints; ++i) {\n"
"            wDs[i] *= d1Scale;\n"
"            wDt[i] *= d1Scale;\n"
"        }\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            OSD_REAL d2Scale = d1Scale * d1Scale;\n"
"\n"
"            for (int i = 0; i < nPoints; ++i) {\n"
"                wDss[i] *= d2Scale;\n"
"                wDst[i] *= d2Scale;\n"
"                wDtt[i] *= d2Scale;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"//  Deprecated -- prefer use of OsdEvaluatePatchBasis() and\n"
"//  OsdEvaluatePatchBasisNormalized() methods.\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"void\n"
"OsdGetGregoryPatchWeights(\n"
"    OSD_REAL s, OSD_REAL t, OSD_REAL d1Scale,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 20)) {\n"
"    int nPoints = Osd_EvalBasisGregory(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        for (int i = 0; i < nPoints; ++i) {\n"
"            wDs[i] *= d1Scale;\n"
"            wDt[i] *= d1Scale;\n"
"        }\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            OSD_REAL d2Scale = d1Scale * d1Scale;\n"
"\n"
"            for (int i = 0; i < nPoints; ++i) {\n"
"                wDss[i] *= d2Scale;\n"
"                wDst[i] *= d2Scale;\n"
"                wDtt[i] *= d2Scale;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"//\n"
"//  Higher level basis evaluation functions that deal with parameterization and\n"
"//  boundary issues (reflected in PatchParam) for all patch types:\n"
"//\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"OsdEvaluatePatchBasisNormalized(\n"
"    int patchType, OsdPatchParam param,\n"
"    OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 20)) {\n"
"\n"
"    int boundaryMask = OsdPatchParamGetBoundary(param);\n"
"\n"
"    int nPoints = 0;\n"
"    if (patchType == OSD_PATCH_DESCRIPTOR_REGULAR) {\n"
"#if OSD_ARRAY_ARG_BOUND_OPTIONAL\n"
"        nPoints = Osd_EvalBasisBSpline(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"        if (boundaryMask != 0) {\n"
"            Osd_boundBasisBSpline(\n"
"                boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"        }\n"
"#else\n"
"        OSD_REAL wP16[16], wDs16[16], wDt16[16],\n"
"                 wDss16[16], wDst16[16], wDtt16[16];\n"
"        nPoints = Osd_EvalBasisBSpline(\n"
"                s, t, wP16, wDs16, wDt16, wDss16, wDst16, wDtt16);\n"
"        if (boundaryMask != 0) {\n"
"            Osd_boundBasisBSpline(\n"
"                boundaryMask, wP16, wDs16, wDt16, wDss16, wDst16, wDtt16);\n"
"        }\n"
"        for (int i=0; i<nPoints; ++i) {\n"
"            wP[i] = wP16[i];\n"
"            wDs[i] = wDs16[i]; wDt[i] = wDt16[i];\n"
"            wDss[i] = wDss16[i]; wDst[i] = wDst16[i]; wDtt[i] = wDtt16[i];\n"
"        }\n"
"#endif\n"
"    } else if (patchType == OSD_PATCH_DESCRIPTOR_LOOP) {\n"
"#if OSD_ARRAY_ARG_BOUND_OPTIONAL\n"
"        nPoints = Osd_EvalBasisBoxSplineTri(\n"
"                s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"        if (boundaryMask != 0) {\n"
"            Osd_boundBasisBoxSplineTri(\n"
"                boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"        }\n"
"#else\n"
"        OSD_REAL wP12[12], wDs12[12], wDt12[12],\n"
"                 wDss12[12], wDst12[12], wDtt12[12];\n"
"        nPoints = Osd_EvalBasisBoxSplineTri(\n"
"                s, t, wP12, wDs12, wDt12, wDss12, wDst12, wDtt12);\n"
"        if (boundaryMask != 0) {\n"
"            Osd_boundBasisBoxSplineTri(\n"
"                boundaryMask, wP12, wDs12, wDt12, wDss12, wDst12, wDtt12);\n"
"        }\n"
"        for (int i=0; i<nPoints; ++i) {\n"
"            wP[i] = wP12[i];\n"
"            wDs[i] = wDs12[i]; wDt[i] = wDt12[i];\n"
"            wDss[i] = wDss12[i]; wDst[i] = wDst12[i]; wDtt[i] = wDtt12[i];\n"
"        }\n"
"#endif\n"
"    } else if (patchType == OSD_PATCH_DESCRIPTOR_GREGORY_BASIS) {\n"
"        nPoints = Osd_EvalBasisGregory(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"    } else if (patchType == OSD_PATCH_DESCRIPTOR_GREGORY_TRIANGLE) {\n"
"#if OSD_ARRAY_ARG_BOUND_OPTIONAL\n"
"        nPoints = Osd_EvalBasisGregoryTri(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"#else\n"
"        OSD_REAL wP18[18], wDs18[18], wDt18[18],\n"
"                 wDss18[18], wDst18[18], wDtt18[18];\n"
"        nPoints = Osd_EvalBasisGregoryTri(\n"
"                s, t, wP18, wDs18, wDt18, wDss18, wDst18, wDtt18);\n"
"        for (int i=0; i<nPoints; ++i) {\n"
"            wP[i] = wP18[i];\n"
"            wDs[i] = wDs18[i]; wDt[i] = wDt18[i];\n"
"            wDss[i] = wDss18[i]; wDst[i] = wDst18[i]; wDtt[i] = wDtt18[i];\n"
"        }\n"
"#endif\n"
"    } else if (patchType == OSD_PATCH_DESCRIPTOR_QUADS) {\n"
"#if OSD_ARRAY_ARG_BOUND_OPTIONAL\n"
"        nPoints = Osd_EvalBasisLinear(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"#else\n"
"        OSD_REAL wP4[4], wDs4[4], wDt4[4],\n"
"                 wDss4[4], wDst4[4], wDtt4[4];\n"
"        nPoints = Osd_EvalBasisLinear(\n"
"                s, t, wP4, wDs4, wDt4, wDss4, wDst4, wDtt4);\n"
"        for (int i=0; i<nPoints; ++i) {\n"
"            wP[i] = wP4[i];\n"
"            wDs[i] = wDs4[i]; wDt[i] = wDt4[i];\n"
"            wDss[i] = wDss4[i]; wDst[i] = wDst4[i]; wDtt[i] = wDtt4[i];\n"
"        }\n"
"#endif\n"
"    } else if (patchType == OSD_PATCH_DESCRIPTOR_TRIANGLES) {\n"
"#if OSD_ARRAY_ARG_BOUND_OPTIONAL\n"
"        nPoints = Osd_EvalBasisLinearTri(s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"#else\n"
"        OSD_REAL wP3[3], wDs3[3], wDt3[3],\n"
"                 wDss3[3], wDst3[3], wDtt3[3];\n"
"        nPoints = Osd_EvalBasisLinearTri(\n"
"                s, t, wP3, wDs3, wDt3, wDss3, wDst3, wDtt3);\n"
"        for (int i=0; i<nPoints; ++i) {\n"
"            wP[i] = wP3[i];\n"
"            wDs[i] = wDs3[i]; wDt[i] = wDt3[i];\n"
"            wDss[i] = wDss3[i]; wDst[i] = wDst3[i]; wDtt[i] = wDtt3[i];\n"
"        }\n"
"#endif\n"
"    } else {\n"
"        // assert(0);\n"
"    }\n"
"    return nPoints;\n"
"}\n"
"\n"
"OSD_FUNCTION_STORAGE_CLASS\n"
"// template <typename REAL>\n"
"int\n"
"OsdEvaluatePatchBasis(\n"
"    int patchType, OsdPatchParam param,\n"
"    OSD_REAL s, OSD_REAL t,\n"
"    OSD_OUT_ARRAY(OSD_REAL, wP, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDs, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDt, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDss, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDst, 20),\n"
"    OSD_OUT_ARRAY(OSD_REAL, wDtt, 20)) {\n"
"\n"
"    OSD_REAL derivSign = 1.0f;\n"
"\n"
"    if ((patchType == OSD_PATCH_DESCRIPTOR_LOOP) ||\n"
"        (patchType == OSD_PATCH_DESCRIPTOR_GREGORY_TRIANGLE) ||\n"
"        (patchType == OSD_PATCH_DESCRIPTOR_TRIANGLES)) {\n"
"        OSD_REAL uv[2] = OSD_ARRAY_2(OSD_REAL, s, t);\n"
"        OsdPatchParamNormalizeTriangle(param, uv);\n"
"        s = uv[0];\n"
"        t = uv[1];\n"
"        if (OsdPatchParamIsTriangleRotated(param)) {\n"
"            derivSign = -1.0f;\n"
"        }\n"
"    } else {\n"
"        OSD_REAL uv[2] = OSD_ARRAY_2(OSD_REAL, s, t);\n"
"        OsdPatchParamNormalize(param, uv);\n"
"        s = uv[0];\n"
"        t = uv[1];\n"
"    }\n"
"\n"
"    int nPoints = OsdEvaluatePatchBasisNormalized(\n"
"        patchType, param, s, t, wP, wDs, wDt, wDss, wDst, wDtt);\n"
"\n"
"    if (OSD_OPTIONAL(wDs && wDt)) {\n"
"        OSD_REAL d1Scale =\n"
"                derivSign * OSD_REAL_CAST(1 << OsdPatchParamGetDepth(param));\n"
"\n"
"        for (int i = 0; i < nPoints; ++i) {\n"
"            wDs[i] *= d1Scale;\n"
"            wDt[i] *= d1Scale;\n"
"        }\n"
"\n"
"        if (OSD_OPTIONAL(wDss && wDst && wDtt)) {\n"
"            OSD_REAL d2Scale = derivSign * d1Scale * d1Scale;\n"
"\n"
"            for (int i = 0; i < nPoints; ++i) {\n"
"                wDss[i] *= d2Scale;\n"
"                wDst[i] *= d2Scale;\n"
"                wDtt[i] *= d2Scale;\n"
"            }\n"
"        }\n"
"    }\n"
"    return nPoints;\n"
"}\n"
"\n"
"#if !defined(OSD_PATCH_BASIS_GLSL) && "
"    !defined(OSD_PATCH_BASIS_HLSL) && "
"    !defined(OSD_PATCH_BASIS_CUDA) && "
"    !defined(OSD_PATCH_BASIS_OPENCL) && "
"    !defined(OSD_PATCH_BASIS_METAL)\n"
"\n"
"}  // end namespace Osd\n"
"\n"
"}  // end namespace OPENSUBDIV_VERSION\n"
"using namespace OPENSUBDIV_VERSION;\n"
"\n"
"}  // end namespace OpenSubdiv\n"
"\n"
"#endif\n"
"\n"
"#endif /* OPENSUBDIV3_OSD_PATCH_BASIS_H */\n"
"\n"
);
static std::string bsplineShaderSource(
"#line 0 \"osd/mtlPatchBSpline.metal\"\n"
"\n"
"//\n"
"//   Copyright 2015 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.BSpline.Hull\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerVertex(\n"
"        float4 position,\n"
"        threadgroup HullVertex& hullVertex,\n"
"        int vertexId,\n"
"        float4x4 modelViewProjectionMatrix,\n"
"        OsdPatchParamBufferSet osdBuffers\n"
"        )\n"
"{\n"
"    hullVertex.position = position;\n"
"#if OSD_ENABLE_PATCH_CULL\n"
"    float4 clipPos = mul(modelViewProjectionMatrix, position);\n"
"    short3 clip0 = short3(clipPos.x < clipPos.w,\n"
"                          clipPos.y < clipPos.w,\n"
"                          clipPos.z < clipPos.w);\n"
"    short3 clip1 = short3(clipPos.x > -clipPos.w,\n"
"                          clipPos.y > -clipPos.w,\n"
"                          clipPos.z > -clipPos.w);\n"
"    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);\n"
"#endif\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.BSpline.Factors\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerPatchBSplineFactors(\n"
"        int3 patchParam,\n"
"        float tessLevel,\n"
"        float4x4 projectionMatrix,\n"
"        float4x4 modelViewMatrix,\n"
"        device OsdPerPatchVertexBezier* patch,\n"
"#if !USE_PTVS_FACTORS\n"
"        device OsdPerPatchTessFactors& patchFactors,\n"
"#endif\n"
"        device MTLQuadTessellationFactorsHalf& quadFactors\n"
"        )\n"
"{\n"
"    float4 tessLevelOuter = float4(0);\n"
"    float2 tessLevelInner = float2(0);\n"
"    float4 tessOuterLo = float4(0);\n"
"    float4 tessOuterHi = float4(0);\n"
"\n"
"#if OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    OsdEvalPatchBezierTessLevels(\n"
"        tessLevel,\n"
"        projectionMatrix,\n"
"        modelViewMatrix,\n"
"        patch,\n"
"        patchParam,\n"
"        tessLevelOuter,\n"
"        tessLevelInner,\n"
"        tessOuterLo,\n"
"        tessOuterHi\n"
"        );\n"
"#else\n"
"    OsdGetTessLevelsUniform(\n"
"        tessLevel,\n"
"        patchParam,\n"
"        tessLevelOuter,\n"
"        tessLevelInner,\n"
"        tessOuterLo,\n"
"        tessOuterHi\n"
"        );\n"
"#endif\n"
"\n"
"    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];\n"
"    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];\n"
"    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];\n"
"    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];\n"
"    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];\n"
"    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];\n"
"#if !USE_PTVS_FACTORS\n"
"    patchFactors.tessOuterLo = tessOuterLo;\n"
"    patchFactors.tessOuterHi = tessOuterHi;\n"
"#endif\n"
"}\n"
"\n"
"void OsdComputePerPatchFactors(\n"
"        int3 patchParam,\n"
"        float tessLevel,\n"
"        unsigned patchID,\n"
"        float4x4 projectionMatrix,\n"
"        float4x4 modelViewMatrix,\n"
"        OsdPatchParamBufferSet osdBuffer,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"        device MTLQuadTessellationFactorsHalf& quadFactors\n"
"        )\n"
"{\n"
"    OsdComputePerPatchBSplineFactors(\n"
"        patchParam,\n"
"        tessLevel,\n"
"        projectionMatrix,\n"
"        modelViewMatrix,\n"
"        osdBuffer.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,\n"
"#if !USE_PTVS_FACTORS\n"
"        osdBuffer.patchTessBuffer[patchID],\n"
"#endif\n"
"        quadFactors\n"
"        );\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.BSpline.Vertex\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerPatchVertex(\n"
"        int3 patchParam,\n"
"        unsigned ID,\n"
"        unsigned PrimitiveID,\n"
"        unsigned ControlID,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"        OsdPatchParamBufferSet osdBuffers\n"
"        )\n"
"{\n"
"    OsdComputePerPatchVertexBSpline(patchParam, ID,\n"
"        patchVertices, osdBuffers.perPatchVertexBuffer[ControlID]);\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.BSpline.Domain\n"
"//----------------------------------------------------------\n"
"\n"
"template<typename PerPatchVertexBezier>\n"
"OsdPatchVertex ds_regular_patches(\n"
"        const float tessLevel,\n"
"#if !USE_PTVS_FACTORS\n"
"        float4 tessOuterLo,\n"
"        float4 tessOuterHi,\n"
"#endif\n"
"        PerPatchVertexBezier cv,\n"
"        int3 patchParam,\n"
"        float2 domainCoord\n"
"        )\n"
"{\n"
"#if USE_PTVS_FACTORS\n"
"    float4 tessOuterLo(0), tessOuterHi(0);\n"
"    OsdGetTessLevelsUniform(tessLevel, patchParam, tessOuterLo, tessOuterHi);\n"
"#endif\n"
"\n"
"    float2 UV = OsdGetTessParameterization(domainCoord,\n"
"                                           tessOuterLo,\n"
"                                           tessOuterHi);\n"
"\n"
"    OsdPatchVertex output;\n"
"\n"
"    float3 P = float3(0), dPu = float3(0), dPv = float3(0);\n"
"    float3 N = float3(0), dNu = float3(0), dNv = float3(0);\n"
"    float2 vSegments = float2(0);\n"
"\n"
"    OsdEvalPatchBezier(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv, vSegments);\n"
"\n"
"    output.normal = N;\n"
"    output.tangent = dPu;\n"
"    output.bitangent = dPv;\n"
"#if OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    output.Nu = dNu;\n"
"    output.Nv = dNv;\n"
"#endif\n"
"#if OSD_PATCH_ENABLE_SINGLE_CREASE\n"
"    output.vSegments = vSegments;\n"
"#endif\n"
"\n"
"    output.tessCoord = UV;\n"
"    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);\n"
"    output.position = P;\n"
"    return output;\n"
"}\n"
"\n"
"#if USE_STAGE_IN\n"
"template<typename PerPatchVertexBezier>\n"
"#endif\n"
"OsdPatchVertex OsdComputePatch(\n"
"        float tessLevel,\n"
"        float2 domainCoord,\n"
"        unsigned patchID,\n"
"#if USE_STAGE_IN\n"
"        PerPatchVertexBezier osdPatch\n"
"#else\n"
"        OsdVertexBufferSet osdBuffers\n"
"#endif\n"
"        )\n"
"{\n"
"    return ds_regular_patches(\n"
"            tessLevel,\n"
"#if !USE_PTVS_FACTORS\n"
"#if USE_STAGE_IN\n"
"            osdPatch.tessOuterLo,\n"
"            osdPatch.tessOuterHi,\n"
"#else\n"
"            osdBuffers.patchTessBuffer[patchID].tessOuterLo,\n"
"            osdBuffers.patchTessBuffer[patchID].tessOuterHi,\n"
"#endif\n"
"#endif\n"
"#if USE_STAGE_IN\n"
"            osdPatch.cv,\n"
"            osdPatch.patchParam,\n"
"#else\n"
"            osdBuffers.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,\n"
"            osdBuffers.patchParamBuffer[patchID],\n"
"#endif\n"
"            domainCoord\n"
"            );\n"
"}\n"
"\n"
"\n"
);
static std::string boxSplineTriangleShaderSource(
"#line 0 \"osd/mtlPatchBoxSplineTriangle.metal\"\n"
"\n"
"//\n"
"//   Copyright 2019 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.BoxSplineTriangle.Hull\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerVertex(\n"
"        float4 position,\n"
"        threadgroup HullVertex& hullVertex,\n"
"        int vertexId,\n"
"        float4x4 modelViewProjectionMatrix,\n"
"        OsdPatchParamBufferSet osdBuffers\n"
"        )\n"
"{\n"
"    hullVertex.position = position;\n"
"#if OSD_ENABLE_PATCH_CULL\n"
"    float4 clipPos = mul(modelViewProjectionMatrix, position);\n"
"    short3 clip0 = short3(clipPos.x < clipPos.w,\n"
"                          clipPos.y < clipPos.w,\n"
"                          clipPos.z < clipPos.w);\n"
"    short3 clip1 = short3(clipPos.x > -clipPos.w,\n"
"                          clipPos.y > -clipPos.w,\n"
"                          clipPos.z > -clipPos.w);\n"
"    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);\n"
"#endif\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.BoxSplineTriangle.Factors\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerPatchBezierTriangleFactors(\n"
"        int3 patchParam,\n"
"        float tessLevel,\n"
"        float4x4 projectionMatrix,\n"
"        float4x4 modelViewMatrix,\n"
"        device OsdPerPatchVertexBezier* patch,\n"
"#if !USE_PTVS_FACTORS\n"
"        device OsdPerPatchTessFactors& patchFactors,\n"
"#endif\n"
"        device MTLTriangleTessellationFactorsHalf& triFactors\n"
"        )\n"
"{\n"
"    float4 tessLevelOuter = float4(0);\n"
"    float2 tessLevelInner = float2(0);\n"
"    float4 tessOuterLo = float4(0);\n"
"    float4 tessOuterHi = float4(0);\n"
"\n"
"#if OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    // Gather bezier control points to compute limit surface tess levels\n"
"    float3 bezcv[15];\n"
"    for (int i=0; i<15; ++i) {\n"
"        bezcv[i] = patch[i].P;\n"
"    }\n"
"\n"
"    OsdEvalPatchBezierTriangleTessLevels(\n"
"        tessLevel,\n"
"        projectionMatrix,\n"
"        modelViewMatrix,\n"
"        bezcv,\n"
"        patchParam,\n"
"        tessLevelOuter,\n"
"        tessLevelInner,\n"
"        tessOuterLo,\n"
"        tessOuterHi\n"
"        );\n"
"#else\n"
"    OsdGetTessLevelsUniformTriangle(\n"
"        tessLevel,\n"
"        patchParam,\n"
"        tessLevelOuter,\n"
"        tessLevelInner,\n"
"        tessOuterLo,\n"
"        tessOuterHi\n"
"        );\n"
"#endif\n"
"\n"
"    triFactors.edgeTessellationFactor[0] = tessLevelOuter[0];\n"
"    triFactors.edgeTessellationFactor[1] = tessLevelOuter[1];\n"
"    triFactors.edgeTessellationFactor[2] = tessLevelOuter[2];\n"
"    triFactors.insideTessellationFactor  = tessLevelInner[0];\n"
"#if !USE_PTVS_FACTORS\n"
"    patchFactors.tessOuterLo = tessOuterLo;\n"
"    patchFactors.tessOuterHi = tessOuterHi;\n"
"#endif\n"
"}\n"
"\n"
"void OsdComputePerPatchFactors(\n"
"        int3 patchParam,\n"
"        float tessLevel,\n"
"        unsigned patchID,\n"
"        float4x4 projectionMatrix,\n"
"        float4x4 modelViewMatrix,\n"
"        OsdPatchParamBufferSet osdBuffer,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"        device MTLTriangleTessellationFactorsHalf& triFactors\n"
"        )\n"
"{\n"
"    OsdComputePerPatchBezierTriangleFactors(\n"
"            patchParam,\n"
"            tessLevel,\n"
"            projectionMatrix,\n"
"            modelViewMatrix,\n"
"            osdBuffer.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,\n"
"#if !USE_PTVS_FACTORS\n"
"            osdBuffer.patchTessBuffer[patchID],\n"
"#endif\n"
"            triFactors\n"
"            );\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.BoxSplineTriangle.Vertex\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerPatchVertex(\n"
"        int3 patchParam,\n"
"        unsigned ID,\n"
"        unsigned PrimitiveID,\n"
"        unsigned ControlID,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"        OsdPatchParamBufferSet osdBuffers\n"
"        )\n"
"{\n"
"    OsdComputePerPatchVertexBoxSplineTriangle(\n"
"        patchParam, ID, patchVertices,\n"
"        osdBuffers.perPatchVertexBuffer[ControlID]);\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.BoxSplineTriangle.Domain\n"
"//----------------------------------------------------------\n"
"\n"
"template<typename PerPatchVertexBezier>\n"
"OsdPatchVertex ds_regular_patches(\n"
"        float tessLevel,\n"
"#if !USE_PTVS_FACTORS\n"
"        float4 tessOuterLo,\n"
"        float4 tessOuterHi,\n"
"#endif\n"
"        PerPatchVertexBezier cv,\n"
"        int3 patchParam,\n"
"        float3 domainCoord\n"
"        )\n"
"{\n"
"#if USE_PTVS_FACTORS\n"
"    float4 tessOuterLo(0), tessOuterHi(0);\n"
"    OsdGetTessLevelsUniformTriangle(\n"
"        tessLevel, patchParam, tessOuterLo, tessOuterHi);\n"
"#endif\n"
"\n"
"    float2 UV = OsdGetTessParameterizationTriangle(domainCoord,\n"
"                                                   tessOuterLo,\n"
"                                                   tessOuterHi);\n"
"\n"
"    OsdPatchVertex output;\n"
"\n"
"    float3 P = float3(0), dPu = float3(0), dPv = float3(0);\n"
"    float3 N = float3(0), dNu = float3(0), dNv = float3(0);\n"
"\n"
"    OsdEvalPatchBezierTriangle(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);\n"
"\n"
"    output.normal = N;\n"
"    output.tangent = dPu;\n"
"    output.bitangent = dPv;\n"
"#if OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    output.Nu = dNu;\n"
"    output.Nv = dNv;\n"
"#endif\n"
"\n"
"    output.tessCoord = UV;\n"
"    output.patchCoord = OsdInterpolatePatchCoordTriangle(UV, patchParam);\n"
"    output.position = P;\n"
"    return output;\n"
"}\n"
"\n"
"#if USE_STAGE_IN\n"
"template<typename PerPatchVertexBezier>\n"
"#endif\n"
"OsdPatchVertex OsdComputePatch(\n"
"        float tessLevel,\n"
"        float3 domainCoord,\n"
"        unsigned patchID,\n"
"#if USE_STAGE_IN\n"
"        PerPatchVertexBezier osdPatch\n"
"#else\n"
"        OsdVertexBufferSet osdBuffers\n"
"#endif\n"
"        )\n"
"{\n"
"    return ds_regular_patches(\n"
"            tessLevel,\n"
"#if !USE_PTVS_FACTORS\n"
"#if USE_STAGE_IN\n"
"            osdPatch.tessOuterLo,\n"
"            osdPatch.tessOuterHi,\n"
"#else\n"
"            osdBuffers.patchTessBuffer[patchID].tessOuterLo,\n"
"            osdBuffers.patchTessBuffer[patchID].tessOuterHi,\n"
"#endif\n"
"#endif\n"
"#if USE_STAGE_IN\n"
"            osdPatch.cv,\n"
"            osdPatch.patchParam,\n"
"#else\n"
"            osdBuffers.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,\n"
"            osdBuffers.patchParamBuffer[patchID],\n"
"#endif\n"
"            domainCoord\n"
"            );\n"
"}\n"
"\n"
"\n"
);
static std::string gregoryShaderSource(
"#line 0 \"osd/mtlPatchGregory.metal\"\n"
"\n"
"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Gregory.Hull\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerVertex(\n"
"        float4 position,\n"
"        threadgroup OsdPerVertexGregory& hullVertex,\n"
"        int vertexId,\n"
"        float4x4 modelViewProjectionMatrix,\n"
"        OsdPatchParamBufferSet osdBuffers\n"
"        )\n"
"{\n"
"    OsdComputePerVertexGregory(vertexId, position.xyz, hullVertex, osdBuffers);\n"
"\n"
"#if OSD_ENABLE_PATCH_CULL\n"
"    float4 clipPos = mul(modelViewProjectionMatrix, position);\n"
"    short3 clip0 = short3(clipPos.x < clipPos.w,\n"
"                          clipPos.y < clipPos.w,\n"
"                          clipPos.z < clipPos.w);\n"
"    short3 clip1 = short3(clipPos.x > -clipPos.w,\n"
"                          clipPos.y > -clipPos.w,\n"
"                          clipPos.z > -clipPos.w);\n"
"    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);\n"
"#endif\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Gregory.Factors\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerPatchGregoryFactors(\n"
"        int3 patchParam,\n"
"        float tessLevel,\n"
"        float4x4 projectionMatrix,\n"
"        float4x4 modelViewMatrix,\n"
"        device OsdPerPatchVertexGregory* patchVertices,\n"
"#if !USE_PTVS_FACTORS\n"
"        device OsdPerPatchTessFactors& patchFactors,\n"
"#endif\n"
"        device MTLQuadTessellationFactorsHalf& quadFactors\n"
"        )\n"
"{\n"
"    float4 tessLevelOuter = float4(0);\n"
"    float2 tessLevelInner = float2(0);\n"
"    float4 tessOuterLo = float4(0);\n"
"    float4 tessOuterHi = float4(0);\n"
"\n"
"#if OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    // Gather bezier control points to compute limit surface tess levels\n"
"    float3 bezcv[16];\n"
"    bezcv[ 0] = patchVertices[0].P;\n"
"    bezcv[ 1] = patchVertices[0].Ep;\n"
"    bezcv[ 2] = patchVertices[1].Em;\n"
"    bezcv[ 3] = patchVertices[1].P;\n"
"    bezcv[ 4] = patchVertices[0].Em;\n"
"    bezcv[ 5] = patchVertices[0].Fp;\n"
"    bezcv[ 6] = patchVertices[1].Fm;\n"
"    bezcv[ 7] = patchVertices[1].Ep;\n"
"    bezcv[ 8] = patchVertices[3].Ep;\n"
"    bezcv[ 9] = patchVertices[3].Fm;\n"
"    bezcv[10] = patchVertices[2].Fp;\n"
"    bezcv[11] = patchVertices[2].Em;\n"
"    bezcv[12] = patchVertices[3].P;\n"
"    bezcv[13] = patchVertices[3].Em;\n"
"    bezcv[14] = patchVertices[2].Ep;\n"
"    bezcv[15] = patchVertices[2].P;\n"
"\n"
"    OsdEvalPatchBezierTessLevels(\n"
"        tessLevel,\n"
"        projectionMatrix,\n"
"        modelViewMatrix,\n"
"        bezcv,\n"
"        patchParam,\n"
"        tessLevelOuter,\n"
"        tessLevelInner,\n"
"        tessOuterLo,\n"
"        tessOuterHi\n"
"        );\n"
"#else\n"
"    OsdGetTessLevelsUniform(\n"
"        tessLevel,\n"
"        patchParam,\n"
"        tessLevelOuter,\n"
"        tessLevelInner,\n"
"        tessOuterLo,\n"
"        tessOuterHi\n"
"        );\n"
"#endif\n"
"\n"
"    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];\n"
"    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];\n"
"    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];\n"
"    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];\n"
"    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];\n"
"    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];\n"
"#if !USE_PTVS_FACTORS\n"
"    patchFactors.tessOuterLo = tessOuterLo;\n"
"    patchFactors.tessOuterHi = tessOuterHi;\n"
"#endif\n"
"}\n"
"\n"
"void OsdComputePerPatchFactors(\n"
"        int3 patchParam,\n"
"        float tessLevel,\n"
"        unsigned patchID,\n"
"        float4x4 projectionMatrix,\n"
"        float4x4 modelViewMatrix,\n"
"        OsdPatchParamBufferSet osdBuffer,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"        device MTLQuadTessellationFactorsHalf& quadFactors\n"
"        )\n"
"{\n"
"    OsdComputePerPatchGregoryFactors(\n"
"        patchParam,\n"
"        tessLevel,\n"
"        projectionMatrix,\n"
"        modelViewMatrix,\n"
"        osdBuffer.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,\n"
"#if !USE_PTVS_FACTORS\n"
"        osdBuffer.patchTessBuffer[patchID],\n"
"#endif\n"
"        quadFactors\n"
"        );\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Gregory.Vertex\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerPatchVertex(\n"
"        int3 patchParam,\n"
"        unsigned ID,\n"
"        unsigned PrimitiveID,\n"
"        unsigned ControlID,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"        OsdPatchParamBufferSet osdBuffers\n"
"        )\n"
"{\n"
"    OsdComputePerPatchVertexGregory(\n"
"            patchParam,\n"
"            ID,\n"
"            PrimitiveID,\n"
"            patchVertices,\n"
"            osdBuffers.perPatchVertexBuffer[ControlID],\n"
"            osdBuffers);\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Gregory.Domain\n"
"//----------------------------------------------------------\n"
"\n"
"template<typename PerPatchVertexGregory>\n"
"OsdPatchVertex ds_gregory_patches(\n"
"        const float tessLevel,\n"
"#if !USE_PTVS_FACTORS\n"
"        float4 tessOuterLo,\n"
"        float4 tessOuterHi,\n"
"#endif\n"
"        PerPatchVertexGregory patch,\n"
"        int3 patchParam,\n"
"        float2 domainCoord\n"
"        )\n"
"{\n"
"    float3 cv[20];\n"
"    cv[0] = patch[0].P;\n"
"    cv[1] = patch[0].Ep;\n"
"    cv[2] = patch[0].Em;\n"
"    cv[3] = patch[0].Fp;\n"
"    cv[4] = patch[0].Fm;\n"
"    cv[5] = patch[1].P;\n"
"    cv[6] = patch[1].Ep;\n"
"    cv[7] = patch[1].Em;\n"
"    cv[8] = patch[1].Fp;\n"
"    cv[9] = patch[1].Fm;\n"
"    cv[10] = patch[2].P;\n"
"    cv[11] = patch[2].Ep;\n"
"    cv[12] = patch[2].Em;\n"
"    cv[13] = patch[2].Fp;\n"
"    cv[14] = patch[2].Fm;\n"
"    cv[15] = patch[3].P;\n"
"    cv[16] = patch[3].Ep;\n"
"    cv[17] = patch[3].Em;\n"
"    cv[18] = patch[3].Fp;\n"
"    cv[19] = patch[3].Fm;\n"
"\n"
"#if USE_PTVS_FACTORS\n"
"    float4 tessOuterLo(0), tessOuterHi(0);\n"
"    OsdGetTessLevelsUniform(tessLevel, patchParam, tessOuterLo, tessOuterHi);\n"
"#endif\n"
"\n"
"    float2 UV = OsdGetTessParameterization(domainCoord,\n"
"                                           tessOuterLo,\n"
"                                           tessOuterHi);\n"
"\n"
"    OsdPatchVertex output;\n"
"\n"
"    float3 P = float3(0), dPu = float3(0), dPv = float3(0);\n"
"    float3 N = float3(0), dNu = float3(0), dNv = float3(0);\n"
"\n"
"    OsdEvalPatchGregory(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);\n"
"\n"
"    // all code below here is client code\n"
"    output.position = P;\n"
"    output.normal = N;\n"
"    output.tangent = dPu;\n"
"    output.bitangent = dPv;\n"
"#if OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    output.Nu = dNu;\n"
"    output.Nv = dNv;\n"
"#endif\n"
"\n"
"    output.tessCoord = UV;\n"
"    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);\n"
"\n"
"    return output;\n"
"}\n"
"\n"
"#if USE_STAGE_IN\n"
"template<typename PerPatchVertexGregoryBasis>\n"
"#endif\n"
"OsdPatchVertex OsdComputePatch(\n"
"        float tessLevel,\n"
"        float2 domainCoord,\n"
"        unsigned patchID,\n"
"#if USE_STAGE_IN\n"
"        PerPatchVertexGregoryBasis osdPatch\n"
"#else\n"
"        OsdVertexBufferSet osdBuffers\n"
"#endif\n"
"        )\n"
"{\n"
"    return ds_gregory_patches(\n"
"            tessLevel,\n"
"#if !USE_PTVS_FACTORS\n"
"#if USE_STAGE_IN\n"
"            osdPatch.tessOuterLo,\n"
"            osdPatch.tessOuterHi,\n"
"#else\n"
"            osdBuffers.patchTessBuffer[patchID].tessOuterLo,\n"
"            osdBuffers.patchTessBuffer[patchID].tessOuterHi,\n"
"#endif\n"
"#endif\n"
"#if USE_STAGE_IN\n"
"            osdPatch.cv,\n"
"            osdPatch.patchParam,\n"
"#else\n"
"            osdBuffers.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,\n"
"            osdBuffers.patchParamBuffer[patchID],\n"
"#endif\n"
"            domainCoord);\n"
"}\n"
"\n"
);
static std::string gregoryBasisShaderSource(
"#line 0 \"osd/mtlPatchGregoryBasis.metal\"\n"
"\n"
"//\n"
"//   Copyright 2015 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.GregoryBasis.Hull\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerVertex(\n"
"        float4 position,\n"
"        threadgroup HullVertex& hullVertex,\n"
"        int vertexId,\n"
"        float4x4 modelViewProjectionMatrix,\n"
"        OsdPatchParamBufferSet osdBuffers\n"
"        )\n"
"{\n"
"    hullVertex.position = position;\n"
"#if OSD_ENABLE_PATCH_CULL\n"
"    float4 clipPos = mul(modelViewProjectionMatrix, position);\n"
"    short3 clip0 = short3(clipPos.x < clipPos.w,\n"
"                          clipPos.y < clipPos.w,\n"
"                          clipPos.z < clipPos.w);\n"
"    short3 clip1 = short3(clipPos.x > -clipPos.w,\n"
"                          clipPos.y > -clipPos.w,\n"
"                          clipPos.z > -clipPos.w);\n"
"    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);\n"
"#endif\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.GregoryBasis.Factors\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerPatchGregoryFactors(\n"
"        int3 patchParam,\n"
"        float tessLevel,\n"
"        float4x4 projectionMatrix,\n"
"        float4x4 modelViewMatrix,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"#if !USE_PTVS_FACTORS\n"
"        device OsdPerPatchTessFactors& patchFactors,\n"
"#endif\n"
"        device MTLQuadTessellationFactorsHalf& quadFactors\n"
"        )\n"
"{\n"
"    float4 tessLevelOuter = float4(0);\n"
"    float2 tessLevelInner = float2(0);\n"
"    float4 tessOuterLo = float4(0);\n"
"    float4 tessOuterHi = float4(0);\n"
"\n"
"#if OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    // Gather bezier control points to compute limit surface tess levels\n"
"    float3 bezcv[16];\n"
"    bezcv[ 0] = patchVertices[ 0].position.xyz;\n"
"    bezcv[ 1] = patchVertices[ 1].position.xyz;\n"
"    bezcv[ 2] = patchVertices[ 7].position.xyz;\n"
"    bezcv[ 3] = patchVertices[ 5].position.xyz;\n"
"    bezcv[ 4] = patchVertices[ 2].position.xyz;\n"
"    bezcv[ 5] = patchVertices[ 3].position.xyz;\n"
"    bezcv[ 6] = patchVertices[ 8].position.xyz;\n"
"    bezcv[ 7] = patchVertices[ 6].position.xyz;\n"
"    bezcv[ 8] = patchVertices[16].position.xyz;\n"
"    bezcv[ 9] = patchVertices[18].position.xyz;\n"
"    bezcv[10] = patchVertices[13].position.xyz;\n"
"    bezcv[11] = patchVertices[12].position.xyz;\n"
"    bezcv[12] = patchVertices[15].position.xyz;\n"
"    bezcv[13] = patchVertices[17].position.xyz;\n"
"    bezcv[14] = patchVertices[11].position.xyz;\n"
"    bezcv[15] = patchVertices[10].position.xyz;\n"
"\n"
"    OsdEvalPatchBezierTessLevels(\n"
"        tessLevel,\n"
"        projectionMatrix,\n"
"        modelViewMatrix,\n"
"        bezcv,\n"
"        patchParam,\n"
"        tessLevelOuter,\n"
"        tessLevelInner,\n"
"        tessOuterLo,\n"
"        tessOuterHi\n"
"        );\n"
"#else\n"
"    OsdGetTessLevelsUniform(\n"
"        tessLevel,\n"
"        patchParam,\n"
"        tessLevelOuter,\n"
"        tessLevelInner,\n"
"        tessOuterLo,\n"
"        tessOuterHi\n"
"        );\n"
"#endif\n"
"\n"
"    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];\n"
"    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];\n"
"    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];\n"
"    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];\n"
"    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];\n"
"    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];\n"
"#if !USE_PTVS_FACTORS\n"
"    patchFactors.tessOuterLo = tessOuterLo;\n"
"    patchFactors.tessOuterHi = tessOuterHi;\n"
"#endif\n"
"}\n"
"\n"
"void OsdComputePerPatchFactors(\n"
"        int3 patchParam,\n"
"        float tessLevel,\n"
"        unsigned patchID,\n"
"        float4x4 projectionMatrix,\n"
"        float4x4 modelViewMatrix,\n"
"        OsdPatchParamBufferSet osdBuffer,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"        device MTLQuadTessellationFactorsHalf& quadFactors\n"
"        )\n"
"{\n"
"    OsdComputePerPatchGregoryFactors(\n"
"        patchParam,\n"
"        tessLevel,\n"
"        projectionMatrix,\n"
"        modelViewMatrix,\n"
"        patchVertices,\n"
"#if !USE_PTVS_FACTORS\n"
"        osdBuffer.patchTessBuffer[patchID],\n"
"#endif\n"
"        quadFactors\n"
"        );\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.GregoryBasis.Vertex\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerPatchVertex(\n"
"        int3 patchParam,\n"
"        unsigned ID,\n"
"        unsigned PrimitiveID,\n"
"        unsigned ControlID,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"        OsdPatchParamBufferSet osdBuffers\n"
"        )\n"
"{\n"
"    //Does nothing, all transforms are in the PTVS\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.GregoryBasis.Domain\n"
"//----------------------------------------------------------\n"
"\n"
"#define USE_128BIT_GREGORY_BASIS_INDICES_READ 1\n"
"\n"
"\n"
"#if USE_STAGE_IN\n"
"template<typename PerPatchVertexGregoryBasis>\n"
"#endif\n"
"OsdPatchVertex ds_gregory_basis_patches(\n"
"        const float tessLevel,\n"
"#if !USE_PTVS_FACTORS\n"
"        float4 tessOuterLo,\n"
"        float4 tessOuterHi,\n"
"#endif\n"
"#if USE_STAGE_IN\n"
"        PerPatchVertexGregoryBasis patch,\n"
"#else\n"
"        const device OsdInputVertexType* patch,\n"
"        const device unsigned* patchIndices,\n"
"#endif\n"
"        int3 patchParam,\n"
"        float2 domainCoord\n"
"        )\n"
"{\n"
"#if USE_STAGE_IN\n"
"    float3 cv[20];\n"
"    for(int i = 0; i < 20; i++)\n"
"        cv[i] = patch[i].position;\n"
"#else\n"
"#if USE_128BIT_GREGORY_BASIS_INDICES_READ\n"
"    float3 cv[20];\n"
"    for(int i = 0; i < 5; i++) {\n"
"        int4 indices = ((device int4*)patchIndices)[i];\n"
"\n"
"        int n = i * 4;\n"
"        cv[n + 0] = (patch + indices[0])->position;\n"
"        cv[n + 1] = (patch + indices[1])->position;\n"
"        cv[n + 2] = (patch + indices[2])->position;\n"
"        cv[n + 3] = (patch + indices[3])->position;\n"
"    }\n"
"#else\n"
"    float3 cv[20];\n"
"    for (int i = 0; i < 20; ++i) {\n"
"        cv[i] = patch[patchIndices[i]].position;\n"
"    }\n"
"#endif\n"
"#endif\n"
"\n"
"#if USE_PTVS_FACTORS\n"
"    float4 tessOuterLo(0), tessOuterHi(0);\n"
"    OsdGetTessLevelsUniform(tessLevel, patchParam, tessOuterLo, tessOuterHi);\n"
"#endif\n"
"\n"
"    float2 UV = OsdGetTessParameterization(domainCoord,\n"
"                                           tessOuterLo,\n"
"                                           tessOuterHi);\n"
"\n"
"    OsdPatchVertex output;\n"
"\n"
"    float3 P = float3(0), dPu = float3(0), dPv = float3(0);\n"
"    float3 N = float3(0), dNu = float3(0), dNv = float3(0);\n"
"\n"
"    OsdEvalPatchGregory(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);\n"
"\n"
"    output.position = P;\n"
"    output.normal = N;\n"
"    output.tangent = dPu;\n"
"    output.bitangent = dPv;\n"
"#if OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    output.Nu = dNu;\n"
"    output.Nv = dNv;\n"
"#endif\n"
"\n"
"    output.tessCoord = UV;\n"
"    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);\n"
"\n"
"    return output;\n"
"}\n"
"\n"
"#if USE_STAGE_IN\n"
"template<typename PerPatchVertexGregoryBasis>\n"
"#endif\n"
"OsdPatchVertex OsdComputePatch(\n"
"        float tessLevel,\n"
"        float2 domainCoord,\n"
"        unsigned patchID,\n"
"#if USE_STAGE_IN\n"
"        PerPatchVertexGregoryBasis osdPatch\n"
"#else\n"
"        OsdVertexBufferSet osdBuffers\n"
"#endif\n"
"        )\n"
"{\n"
"    return ds_gregory_basis_patches(\n"
"            tessLevel,\n"
"#if !USE_PTVS_FACTORS\n"
"#if USE_STAGE_IN\n"
"            osdPatch.tessOuterLo,\n"
"            osdPatch.tessOuterHi,\n"
"#else\n"
"            osdBuffers.patchTessBuffer[patchID].tessOuterLo,\n"
"            osdBuffers.patchTessBuffer[patchID].tessOuterHi,\n"
"#endif\n"
"#endif\n"
"#if USE_STAGE_IN\n"
"            osdPatch.cv,\n"
"            osdPatch.patchParam,\n"
"#else\n"
"            osdBuffers.vertexBuffer,\n"
"            osdBuffers.indexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,\n"
"            osdBuffers.patchParamBuffer[patchID],\n"
"#endif\n"
"            domainCoord\n"
"            );\n"
"}\n"
"\n"
);
static std::string gregoryTriangleShaderSource(
"#line 0 \"osd/mtlPatchGregoryTriangle.metal\"\n"
"\n"
"//\n"
"//   Copyright 2019 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.GregoryTriangle.Hull\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerVertex(\n"
"        float4 position,\n"
"        threadgroup HullVertex& hullVertex,\n"
"        int vertexId,\n"
"        float4x4 modelViewProjectionMatrix,\n"
"        OsdPatchParamBufferSet osdBuffers\n"
"        )\n"
"{\n"
"    hullVertex.position = position;\n"
"#if OSD_ENABLE_PATCH_CULL\n"
"    float4 clipPos = mul(modelViewProjectionMatrix, position);\n"
"    short3 clip0 = short3(clipPos.x < clipPos.w,\n"
"                          clipPos.y < clipPos.w,\n"
"                          clipPos.z < clipPos.w);\n"
"    short3 clip1 = short3(clipPos.x > -clipPos.w,\n"
"                          clipPos.y > -clipPos.w,\n"
"                          clipPos.z > -clipPos.w);\n"
"    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);\n"
"#endif\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.GregoryTriangle.Factors\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerPatchGregoryTriangleFactors(\n"
"        int3 patchParam,\n"
"        float tessLevel,\n"
"        float4x4 projectionMatrix,\n"
"        float4x4 modelViewMatrix,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"#if !USE_PTVS_FACTORS\n"
"        device OsdPerPatchTessFactors& patchFactors,\n"
"#endif\n"
"        device MTLTriangleTessellationFactorsHalf& triFactors\n"
"        )\n"
"{\n"
"    float4 tessLevelOuter = float(0);\n"
"    float2 tessLevelInner = float(0);\n"
"    float4 tessOuterLo = float(0);\n"
"    float4 tessOuterHi = float(0);\n"
"\n"
"#if OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    // Gather bezier control points to compute limit surface tess levels\n"
"    float3 cv[15];\n"
"    cv[ 0] = patchVertices[ 0].position.xyz;\n"
"    cv[ 1] = patchVertices[ 1].position.xyz;\n"
"    cv[ 2] = patchVertices[15].position.xyz;\n"
"    cv[ 3] = patchVertices[ 7].position.xyz;\n"
"    cv[ 4] = patchVertices[ 5].position.xyz;\n"
"    cv[ 5] = patchVertices[ 2].position.xyz;\n"
"    cv[ 6] = patchVertices[ 3].position.xyz;\n"
"    cv[ 7] = patchVertices[ 8].position.xyz;\n"
"    cv[ 8] = patchVertices[ 6].position.xyz;\n"
"    cv[ 9] = patchVertices[17].position.xyz;\n"
"    cv[10] = patchVertices[13].position.xyz;\n"
"    cv[11] = patchVertices[16].position.xyz;\n"
"    cv[12] = patchVertices[11].position.xyz;\n"
"    cv[13] = patchVertices[12].position.xyz;\n"
"    cv[14] = patchVertices[10].position.xyz;\n"
"\n"
"    OsdEvalPatchBezierTriangleTessLevels(\n"
"        tessLevel,\n"
"        projectionMatrix,\n"
"        modelViewMatrix,\n"
"        cv,\n"
"        patchParam,\n"
"        tessLevelOuter,\n"
"        tessLevelInner,\n"
"        tessOuterLo,\n"
"        tessOuterHi\n"
"        );\n"
"#else\n"
"    OsdGetTessLevelsUniformTriangle(\n"
"        tessLevel,\n"
"        patchParam,\n"
"        tessLevelOuter,\n"
"        tessLevelInner,\n"
"        tessOuterLo,\n"
"        tessOuterHi\n"
"        );\n"
"#endif\n"
"\n"
"    triFactors.edgeTessellationFactor[0] = tessLevelOuter[0];\n"
"    triFactors.edgeTessellationFactor[1] = tessLevelOuter[1];\n"
"    triFactors.edgeTessellationFactor[2] = tessLevelOuter[2];\n"
"    triFactors.insideTessellationFactor  = tessLevelInner[0];\n"
"#if !USE_PTVS_FACTORS\n"
"    patchFactors.tessOuterLo = tessOuterLo;\n"
"    patchFactors.tessOuterHi = tessOuterHi;\n"
"#endif\n"
"}\n"
"\n"
"void OsdComputePerPatchFactors(\n"
"        int3 patchParam,\n"
"        float tessLevel,\n"
"        unsigned patchID,\n"
"        float4x4 projectionMatrix,\n"
"        float4x4 modelViewMatrix,\n"
"        OsdPatchParamBufferSet osdBuffer,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"        device MTLTriangleTessellationFactorsHalf& triFactors\n"
"        )\n"
"{\n"
"    OsdComputePerPatchGregoryTriangleFactors(\n"
"        patchParam,\n"
"        tessLevel,\n"
"        projectionMatrix,\n"
"        modelViewMatrix,\n"
"        patchVertices,\n"
"#if !USE_PTVS_FACTORS\n"
"        osdBuffer.patchTessBuffer[patchID],\n"
"#endif\n"
"        triFactors\n"
"        );\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.GregoryTriangle.Vertex\n"
"//----------------------------------------------------------\n"
"\n"
"void OsdComputePerPatchVertex(\n"
"        int3 patchParam,\n"
"        unsigned ID,\n"
"        unsigned PrimitiveID,\n"
"        unsigned ControlID,\n"
"        threadgroup PatchVertexType* patchVertices,\n"
"        OsdPatchParamBufferSet osdBuffers\n"
"        )\n"
"{\n"
"    //Does nothing, all transforms are in the PTVS\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.GregoryTriangle.Domain\n"
"//----------------------------------------------------------\n"
"\n"
"#if USE_STAGE_IN\n"
"template<typename PerPatchVertexGregoryBasis>\n"
"#endif\n"
"OsdPatchVertex ds_gregory_triangle_patches(\n"
"        const float tessLevel,\n"
"#if !USE_PTVS_FACTORS\n"
"        float4 tessOuterLo,\n"
"        float4 tessOuterHi,\n"
"#endif\n"
"#if USE_STAGE_IN\n"
"        PerPatchVertexGregoryBasis patch,\n"
"#else\n"
"        const device OsdInputVertexType* patch,\n"
"        const device unsigned* patchIndices,\n"
"#endif\n"
"        int3 patchParam,\n"
"        float3 domainCoord\n"
"        )\n"
"{\n"
"#if USE_STAGE_IN\n"
"    float3 cv[18];\n"
"    for(int i = 0; i < 18; i++)\n"
"        cv[i] = patch[i].position;\n"
"#else\n"
"    float3 cv[18];\n"
"    for (int i = 0; i < 18; ++i) {\n"
"        cv[i] = patch[patchIndices[i]].position;\n"
"    }\n"
"#endif\n"
"\n"
"#if USE_PTVS_FACTORS\n"
"    float4 tessOuterLo(0), tessOuterHi(0);\n"
"    OsdGetTessLevelsUniform(tessLevel, patchParam, tessOuterLo, tessOuterHi);\n"
"#endif\n"
"\n"
"    float2 UV = OsdGetTessParameterizationTriangle(domainCoord,\n"
"                                                   tessOuterLo,\n"
"                                                   tessOuterHi);\n"
"\n"
"    OsdPatchVertex output;\n"
"\n"
"    float3 P = float3(0), dPu = float3(0), dPv = float3(0);\n"
"    float3 N = float3(0), dNu = float3(0), dNv = float3(0);\n"
"\n"
"    OsdEvalPatchGregoryTriangle(\n"
"        patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);\n"
"\n"
"    output.position = P;\n"
"    output.normal = N;\n"
"    output.tangent = dPu;\n"
"    output.bitangent = dPv;\n"
"#if OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    output.Nu = dNu;\n"
"    output.Nv = dNv;\n"
"#endif\n"
"\n"
"    output.tessCoord = UV;\n"
"    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);\n"
"\n"
"    return output;\n"
"}\n"
"\n"
"#if USE_STAGE_IN\n"
"template<typename PerPatchVertexGregoryBasis>\n"
"#endif\n"
"OsdPatchVertex OsdComputePatch(\n"
"        float tessLevel,\n"
"        float3 domainCoord,\n"
"        unsigned patchID,\n"
"#if USE_STAGE_IN\n"
"        PerPatchVertexGregoryBasis osdPatch\n"
"#else\n"
"        OsdVertexBufferSet osdBuffers\n"
"#endif\n"
"        )\n"
"{\n"
"    return ds_gregory_triangle_patches(\n"
"            tessLevel,\n"
"#if !USE_PTVS_FACTORS\n"
"#if USE_STAGE_IN\n"
"            osdPatch.tessOuterLo,\n"
"            osdPatch.tessOuterHi,\n"
"#else\n"
"            osdBuffers.patchTessBuffer[patchID].tessOuterLo,\n"
"            osdBuffers.patchTessBuffer[patchID].tessOuterHi,\n"
"#endif\n"
"#endif\n"
"#if USE_STAGE_IN\n"
"            osdPatch.cv,\n"
"            osdPatch.patchParam,\n"
"#else\n"
"            osdBuffers.vertexBuffer,\n"
"            osdBuffers.indexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,\n"
"            osdBuffers.patchParamBuffer[patchID],\n"
"#endif\n"
"            domainCoord\n"
"            );\n"
"}\n"
"\n"
);

static std::string GetPatchTypeDefine(
    Far::PatchDescriptor::Type type,
    Far::PatchDescriptor::Type fvarType = Far::PatchDescriptor::NON_PATCH) {

  std::stringstream ss;
  switch (type) {
  case Far::PatchDescriptor::LINES:
    ss << "#define OSD_PATCH_LINES 1\n";
    break;
  case Far::PatchDescriptor::TRIANGLES:
    ss << "#define OSD_PATCH_TRIANGLES 1\n";
    break;
  case Far::PatchDescriptor::QUADS:
    ss << "#define OSD_PATCH_QUADS 1\n";
    break;
  case Far::PatchDescriptor::REGULAR:
    ss << "#define OSD_PATCH_BSPLINE 1\n"
          "#define OSD_PATCH_REGULAR 1\n";
    break;
  case Far::PatchDescriptor::LOOP:
    ss << "#define OSD_PATCH_BOX_SPLINE_TRIANGLE 1\n";
    break;
  case Far::PatchDescriptor::GREGORY:
    ss << "#define OSD_PATCH_GREGORY 1\n";
    break;
  case Far::PatchDescriptor::GREGORY_BOUNDARY:
    ss << "#define OSD_PATCH_GREGORY_BOUNDARY 1\n";
    break;
  case Far::PatchDescriptor::GREGORY_BASIS:
    ss << "#define OSD_PATCH_GREGORY_BASIS 1\n";
    break;
  case Far::PatchDescriptor::GREGORY_TRIANGLE:
    ss << "#define OSD_PATCH_GREGORY_TRIANGLE 1\n";
    break;
  default:
    assert("Unknown Far::PatchDescriptor::Type" && 0);
    return "";
  }
  switch (fvarType) {
  case Far::PatchDescriptor::REGULAR:
    ss << "#define OSD_FACEVARYING_PATCH_REGULAR 1\n";
    break;
  case Far::PatchDescriptor::GREGORY_BASIS:
    ss << "#define OSD_FACEVARYING_PATCH_GREGORY_BASIS 1\n";
    break;
  default:
    return ss.str();
  }
  return ss.str();
}

static std::string GetPatchTypeSource(Far::PatchDescriptor::Type type) {

  switch (type) {
  case Far::PatchDescriptor::QUADS:
  case Far::PatchDescriptor::TRIANGLES:
    return "";
  case Far::PatchDescriptor::REGULAR:
    return bsplineShaderSource;
  case Far::PatchDescriptor::LOOP:
    return boxSplineTriangleShaderSource;
  case Far::PatchDescriptor::GREGORY:
    return gregoryShaderSource;
  case Far::PatchDescriptor::GREGORY_BOUNDARY:
    return gregoryShaderSource;
  case Far::PatchDescriptor::GREGORY_BASIS:
    return gregoryBasisShaderSource;
  case Far::PatchDescriptor::GREGORY_TRIANGLE:
    return gregoryTriangleShaderSource;
  default:
    assert("Unknown Far::PatchDescriptor::Type" && 0);
    return "";
  }
}

/*static*/
std::string MTLPatchShaderSource::GetPatchDrawingShaderSource() {
#if TARGET_OS_IPHONE
  return std::string("#define OSD_METAL_IOS 1\n")
      .append(commonShaderSource)
      .append(commonTessShaderSource);
#elif TARGET_OS_OSX
  return std::string("#define OSD_METAL_OSX 1\n")
      .append(commonShaderSource)
      .append(commonTessShaderSource);
#endif
}

/*static*/
std::string MTLPatchShaderSource::GetCommonShaderSource() {
  return GetPatchDrawingShaderSource().append(patchLegacyShaderSource);
}

/*static*/
std::string MTLPatchShaderSource::GetPatchBasisShaderSource() {
  std::stringstream ss;
  ss << "#define OSD_PATCH_BASIS_METAL 1\n";
#if defined(OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES)
  ss << "#define OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES 1\n";
#endif
  ss << patchBasisTypesShaderSource;
  ss << patchBasisShaderSource;
  return ss.str();
}

/*static*/
std::string
MTLPatchShaderSource::GetVertexShaderSource(Far::PatchDescriptor::Type type) {
  std::stringstream ss;
  ss << GetPatchTypeDefine(type);
  ss << GetCommonShaderSource();
  ss << GetPatchTypeSource(type);
  return ss.str();
}

/*static*/
std::string MTLPatchShaderSource::GetVertexShaderSource(
    Far::PatchDescriptor::Type type, Far::PatchDescriptor::Type fvarType) {
  std::stringstream ss;
  ss << GetPatchTypeDefine(type, fvarType);
  ss << GetCommonShaderSource();
  ss << GetPatchTypeSource(type);
  return ss.str();
}

/*static*/
std::string
MTLPatchShaderSource::GetHullShaderSource(Far::PatchDescriptor::Type type) {
  std::stringstream ss;
  ss << GetPatchTypeDefine(type);
  ss << GetCommonShaderSource();
  ss << GetPatchTypeSource(type);
  return ss.str();
}

/*static*/
std::string
MTLPatchShaderSource::GetHullShaderSource(Far::PatchDescriptor::Type type,
                                          Far::PatchDescriptor::Type fvarType) {
  std::stringstream ss;
  ss << GetPatchTypeDefine(type, fvarType);
  ss << GetCommonShaderSource();
  ss << GetPatchTypeSource(type);
  return ss.str();
}

/*static*/
std::string
MTLPatchShaderSource::GetDomainShaderSource(Far::PatchDescriptor::Type type) {
  std::stringstream ss;
  ss << GetPatchTypeDefine(type);
  ss << GetCommonShaderSource();
  ss << GetPatchTypeSource(type);
  return ss.str();
}

/*static*/
std::string MTLPatchShaderSource::GetDomainShaderSource(
    Far::PatchDescriptor::Type type, Far::PatchDescriptor::Type fvarType) {
  std::stringstream ss;
  ss << GetPatchTypeDefine(type, fvarType);
  ss << GetCommonShaderSource();
  ss << GetPatchTypeSource(type);
  return ss.str();
}

} // end namespace Osd

} // end namespace OPENSUBDIV_VERSION
} // end namespace OpenSubdiv
